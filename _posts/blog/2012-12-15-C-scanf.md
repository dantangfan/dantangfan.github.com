---
layout: post
title: C语言学习-让人头疼的scanf
description: 记录下吧，差点被这玩意儿玩儿傻了
category: blog
---
## stdin/stdout/stderr
提到输入数出，最先要说的就是字节流，它是一种线性的数据结构。流是有方向的，就向您在阅读这篇文章的时候肯定是从左往右读下去的。

而任何流都是有源头，也有流向的，最长见的就是我们经常说到的I/O流。c语言为我们提供了三个流，一个是输入流stdin，默认指向的源头的键盘。还有两个流是stdout和stderr，默认情况下流向指向屏幕，也就是从屏幕输出。对任何一个输入输出函数，如果没有特殊的参数指明，默认都是从stdin读取字节，再从stdout输出。

虽然说stdout和stderr都是输出到屏幕，但是他们是有很大区别的。输出到stdout的内容首先要保存到缓冲区中，而stderr直接输出到屏幕（因为我们总是希望尽快就看到错误提示）。如果希望马上就的到错误信息，常用如下语句

    fprintf(stderr,"something wrong\n");

无论是stdin或者是stdout都是不可修改的，因为它们是常量。虽然c语言有提供重定向函数`freopen()`，但是一般不建议使用。

## 字符输入输出函数

在介绍scanf之前，我们还是循序渐进的现介绍以下他的兄弟连——各种字符输入输出函数。

首先是最简单的getchar(),putchar()，需要注意的是这两个函数都是读取一个字符，无论他是不是空白字符（这里的空白字符主要是指\n,\t,以及空格等）。虽然简单，但是还是可能出现一些小问题。

    char a,b;
    getchar(a);
    putchar('a');putchar(a);putchar('\n');
    getchar(b);
    putchar('b');putchar(b);putchar('\n');

首先，当我们输出xy再回车的时候，出现的我们预期的结果

    ax
    by

但是当我们输入x回车的时候却出现了

    ax
    b

这就是刚刚说的getchar(),putchar()会接收当下的任何字符，包括回车。

然后是字符串输入输出函数gets()和puts()。需要了解的就是gets()总是以回车结束，所以不会带走回车，但是可以带走中间的/t,/b等等空白符。

## scanf

下面是本文的主要内容scanf。我们需要清楚两个关键的概念：缓冲区和空白符。空白符前面已经说过了，什么是缓冲区呢？在使用scanf或者gets函数的时候，键盘的输入最先都被保存在缓冲区中，直到输入回车，相应的输入函数才会从缓冲区中读取数据。输入函数从缓冲区读取数据的时候，如果缓冲区为空，函数将等待用户输入，如果不为空，会直接从缓冲区中读取字符。这是一个比较关键的概念，有助于理解下面的问题。

scanf的函数定义原型如下

    int scanf("格式",地参数);

可以看到，函数的返回值是int类型。实际上，scanf函数正确匹配了几个输入参数，返回值就是几。

下面一个例子来说明scanf函数的主要方面。

    scanf("%c,%s %d",&ch,str,&a);

要正确的输入该改函数，我们需要从键盘输入`字符,字符串 整数`，如果如果成功的读入，返回值将是3（而不是5）。在输入过程中，一定要在正确的位置输入`,`和` `与格式匹配。如果不匹配，scanf会失败并且退出。值得注意的是，如果格式里面又空白字符，那么scanf会从stdin中读取空白字符匹配，直到遇到下一个非空白字符，也就是说输入两三个空白字符也是无所谓的。

`scanf("%c",&c)`在读取单个字符的时候跟`getchar()`完全一样，读取数字的时候只要类型匹配就对了，不必多说。最扰人的地方是读取字符串，而出事的关键就在于缓冲区！如果还不理解缓冲区，那就管会google一下

下面看一个几乎所有初学者都遇到过的问题

    int i;
    while(1){
        printf("*");
        scanf("%d",&i);
        if(i==1)
            break;
    }

上面函数，只要任意输入一个非数字字符，函数就会陷入死循环不停的输出\*，您最好亲自再试一试是不是这样的。

造成无限循环的原因就是scanf按照格式读取的时候失败自动退出，但是他*不会清空缓冲区*。于是，我们在输入错误一次后，比如说输入a，scanf发现不匹配，马斯就退出了，但是当下次循环时候，scanf发现缓冲区不空就不会等待输入，又继续匹配不成功，一直这样想去就死循环了。

那么，这时候我们就需要在每次匹配过后清空缓冲区，我是这样写的

    int a;
    char c;
    while(1){
        printf("*");
        scanf("%d",&a);
        while((c=getchar)!='\n' && c!=EOF)
            ;
        if(a==1)
            break;
    }

有些书上说fflush(stdin)可以清空缓冲区，但是我在使用gcc的时候并没有成功。

## 总结

除了缓冲区和格式匹配之外，scanf还可能引发其他很多奇奇怪怪的问题。很多时候我们知道它错了，但是却不知道它为什么错了。所以把scanf说成c函数库中最复杂的函数之一是没问题的。

解决问题最好的方法就是不让他发生，所以在不熟悉的情况下，尽量使用其他函数来代替scanf，比如说先用fgets()来读取用户输入的整行，然后再用sscanf，strtol，atoi等函数来解析读取的行。这样的好处是，就算我们解析失败了，还可以用其他解析函数来重新解析fgets中的数据

最长用的算是sscanf了，他从字符串中读取与指定格式匹配的数据。比如说

    char buf[1024];
    fgets(buf,sizeof(buf),stdin);
    if(sscanf(buf,"%d %c %d",&a,&b,&c)==3)
        printf("OK\n");

从上面罗嗦的过程中，我们可以简单总结出几个要点

* scanf输入字符的时候，任何字符都不会被忽视

* scanf输入数字和字符串的时候，空白字符会被当成输入结束

* 键盘的输入都被保存到缓冲区，直到输入回车输入函数才会去读取缓冲区。输入函数读取缓冲区的时候，如果缓冲区为空，程序会等待输入；如果不为空，程序会直接读取缓冲区中字符

* scanf读取成功会清空缓冲区，读取不成功不会清空缓冲区


