<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
	<channel>
		<title>Dantangfan</title>
		<link></link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Example content</title>
        <description>&lt;p class=&quot;lead&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla ullamcorper est in imperdiet molestie. Curabitur aliquet sem in ante venenatis.&lt;/p&gt;


&lt;p&gt;Morbi ultrices libero imperdiet &lt;a href=&quot;#&quot;&gt;lectus&lt;/a&gt; dignissim, sit amet bibendum nisl consectetur. Morbi erat purus, pretium at ligula tincidunt, faucibus commodo sem. Etiam vel porttitor est, vitae maximus ligula. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque sapien turpis, cursus non porta ac.&lt;/p&gt;

&lt;h2&gt;Lorem&lt;/h2&gt;

&lt;p&gt;Quisque sodales euismod nibh, gravida venenatis nibh dignissim eget. Morbi gravida enim vel lectus aliquet aliquet.&lt;/p&gt;

&lt;h3&gt;Ipsum&lt;/h3&gt;

&lt;p&gt;Nunc nec aliquam tellus. Etiam faucibus magna nibh, ut fermentum velit consectetur id. Nullam vehicula iaculis tortor, in cursus enim auctor vitae. Duis semper pulvinar justo, at vestibulum dolor. Cras fermentum nibh quis nisl imperdiet ornare. Sed nisi nunc, dictum sit amet gravida in, finibus rhoncus orci. Donec scelerisque commodo turpis ac venenatis.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Nam vitae commodo ex. Nunc vel tellus leo.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;Dugem&lt;/h2&gt;

&lt;p&gt;Nullam vehicula iaculis tortor, in cursus enim auctor vitae. Duis semper pulvinar justo, at vestibulum dolor. Cras fermentum nibh quis nisl imperdiet ornare. Sed nisi nunc, dictum sit amet gravida in, finibus rhoncus orci. Donec scelerisque commodo turpis ac venenatis.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;trigger_alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Lorem Ipsum dolor sit amet&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;trigger_alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Golem&lt;/h3&gt;

&lt;p&gt;Quisque sodales euismod nibh, gravida venenatis nibh dignissim eget. Morbi gravida enim vel lectus aliquet aliquet.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Praesent commodo cursus magna.&lt;/li&gt;
&lt;li&gt;Donec id elit non mi porta gravida at eget metus.&lt;/li&gt;
&lt;li&gt;Nulla vitae elit libero, a pharetra augue.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Cras fermentum nibh quis nisl imperdiet ornare. Sed nisi nunc, dictum sit amet gravida in, finibus rhoncus orci. Donec scelerisque commodo turpis ac venenatis.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vestibulum id ligula porta felis euismod semper.&lt;/li&gt;
&lt;li&gt;Cum sociis natoque penatibus.&lt;/li&gt;
&lt;li&gt;Maecenas sed diam eget risus.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Nam ante lacus, ornare ut lacus in, aliquet gravida orci. Donec non dignissim elit. Integer facilisis lorem sed porttitor elementum. Etiam a eleifend justo.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;HyperText Markup Language (HTML)&lt;/dt&gt;
  &lt;dd&gt;The language used to describe and define the content of a Web page&lt;/dd&gt;

  &lt;dt&gt;Cascading Style Sheets (CSS)&lt;/dt&gt;
  &lt;dd&gt;Used to describe the appearance of Web content&lt;/dd&gt;

  &lt;dt&gt;JavaScript (JS)&lt;/dt&gt;
  &lt;dd&gt;The programming language used to build advanced Web sites and applications&lt;/dd&gt;
&lt;/dl&gt;


&lt;p&gt;Sed nisi nunc, dictum sit amet gravida in, finibus rhoncus orci. Donec scelerisque commodo turpis ac venenatis.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://placehold.it/800x400&quot; title=&quot;Large example image&quot; alt=&quot;Large example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/400x200&quot; title=&quot;Medium example image&quot; alt=&quot;Medium example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/200x200&quot; title=&quot;Small example image&quot; alt=&quot;Small example image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Rank&lt;/th&gt;
      &lt;th&gt;Score&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Cookie&lt;/td&gt;
      &lt;td&gt;#69&lt;/td&gt;
      &lt;td&gt;169&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Buther&lt;/td&gt;
      &lt;td&gt;#70&lt;/td&gt;
      &lt;td&gt;169&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stuart&lt;/td&gt;
      &lt;td&gt;#71&lt;/td&gt;
      &lt;td&gt;168&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;
</description>
				<pubDate>Sun, 09 Aug 2015 00:00:00 +0800</pubDate>
				<link>/2015/08/09/example-content.html</link>
				<guid isPermaLink="true">/2015/08/09/example-content.html</guid>
			</item>
		
			<item>
				<title>Whats Jekyll?</title>
        <description>&lt;p class=&quot;lead&quot;&gt; &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; is a static site generator, an open-source tool for creating simple yet powerful websites of all shapes and sizes.&lt;/p&gt;


&lt;p&gt;From &lt;a href=&quot;https://github.com/jekyll/jekyll/blob/master/README.markdown&quot;&gt;the project&#39;s readme&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Jekyll is a simple, blog aware, static site generator. It takes a template directory [...] and spits out a complete, static website suitable for serving with Apache or your favorite web server. This is also the engine behind GitHub Pages, which you can use to host your project’s page or blog right here from GitHub.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&#39;s an immensely useful tool. Find out more by &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;visiting the project on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
				<pubDate>Sat, 08 Aug 2015 00:00:00 +0800</pubDate>
				<link>/2015/08/08/whats-jekyll.html</link>
				<guid isPermaLink="true">/2015/08/08/whats-jekyll.html</guid>
			</item>
		
			<item>
				<title>PEP333中文概要</title>
        <description>&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;PEP333的原文在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0333/&quot;&gt;PEP333&lt;/a&gt;，这篇文章是对他的一个大体翻译，好多语句不知道怎么翻译就用自己的话说了。有些觉得不影响理解的东西就没有翻译直接跳过，因为看原文总是比看翻译好的。&lt;/p&gt;

&lt;p&gt;再次深深的感受到了国外作者的屁话真是太多了，就跟写毕业论文一样天花乱坠。。&lt;/p&gt;

&lt;p&gt;在Python Web 开发中，服务端程序分为两个部分：服务器和应用程序。前者接收客户端请求，后者处理具体逻辑。常用的框架就是把这些功能封装起来，统一使用。不同的框架有不同的开发模式，这样，服务器程序就需要为不同的框架提供不同的支持。这样纷繁复杂，就需要定一个统一的标准来让服务器支持符合标准的框架，框架能跑在符合标准的服务器上。&lt;/p&gt;

&lt;h2&gt;摘要&lt;/h2&gt;

&lt;p&gt;本文档的主要目的是拟定web服务器和PythonWeb应用程序或框架之间的标准接口，用于加强web应用程序在不同web服务器之间的可移植性。&lt;/p&gt;

&lt;h2&gt;基本原理和目标&lt;/h2&gt;

&lt;p&gt;python目前拥有大量的web框架 ，如 Zope, Quixote, Webware, SkunkWeb, PSO, and Twisted Web等。过多的选择对新手来说往往是个问题，因为web框架的选择往往直接限制了web服务器的选择，反之亦然。&lt;/p&gt;

&lt;p&gt;相比之下，虽然java也有很多web框架，但是java的&lt;code&gt;servlet&lt;/code&gt;API能够让用任意java-web框架写出来的应用程序运行在支持&lt;code&gt;servlet&lt;/code&gt;API的web服务器上（没用过java，我神码都不知道）。&lt;/p&gt;

&lt;p&gt;在服务器端对这种Python API（不管这些服务器使用Python写的，还是内嵌Python，或是通过网关协议如CGI来启动Python）的使用和普及，可以把开发人员对web框架和web服务器的选择分离开，让用户自由的选择自己喜欢的组合，同时让框架和服务器的开发者专注于自己的领域。&lt;/p&gt;

&lt;p&gt;因此，这份PEP提出了一个web服务器和web应用或框架之间的简单接口规范，也就是Python Web Server Gateway Interface (WSGI)。&lt;/p&gt;

&lt;p&gt;但仅仅存在一个WSGI规范的无助于解决现有状态。服务器和框架的作者或维护者必须自己实现一份WSGI才能让规范生效。&lt;/p&gt;

&lt;p&gt;由于没有现成的服务器或框架支持WSGI，并且对实现WSGI的作者也很少有直接的收获或奖励。因此，WSGI的实现就必须足够简单，最大化的减少实现成本。&lt;/p&gt;

&lt;p&gt;但是请注意，一个作者实现WSGI的简单性和一个用户使用web框架的简单性并不是同一件事。WSGI也不能有太多规定，比如说cookie、session之类的应该留给框架自己决定，这样才能保证框架的灵活多样。请牢记，WSGI的目标是促进现有的服务器和应用程序或框架容易互连，而不是制造一个新的web框架。&lt;/p&gt;

&lt;p&gt;另外，WSGI不需要除当前版本python之外的任何功能，也不会依赖于任何模块。&lt;/p&gt;

&lt;p&gt;除了能轻松实现程序和框架之间的互联，它也应该能轻松的创建请求预处理器、响应后处理器和其他的基于WSGI的中间件的组建（对于服务器来说这些组建是应用程序，对于应用程序来说这些组建是服务器）。&lt;/p&gt;

&lt;p&gt;如果中间件可以既简单又健壮，并且WSGI广泛使用于服务器和框架，那么就会有一种全新的Python的Web应用程序框架：一个仅仅由几个松散-耦合（loosely-coupled）的WSGI中间件组成的web框架。事实上，现有的框架作者都偏向于重构现有框架来让框架以这种方式提供服务（就是全新的web应用程序框架），使他们看起来更像是配合使用WSGI的库，而不是整体框架。这让web应用的开发者能自由的选择合适的组合，而不需要把所有的功能都让一个框架提供。&lt;/p&gt;

&lt;p&gt;很明显，这一天的到来还遥遥无期，在这期间，一个合理的目标就是让任何框架在任何服务器上运行起来。&lt;/p&gt;

&lt;p&gt;最后，应该提及的是，当前版本的WSGI并没有明确的规定一个web应用需要以什么方式部署在web服务器或gateway上。目前，者需要服务器或者gateway来定义和实现。&lt;/p&gt;

&lt;p&gt;在有足够多的服务器和框架实现了WSGI并在实践中产生这个需求之后，再创建一份PEP来描述WSGI服务器和应用程序的架构部署标准也不迟。&lt;/p&gt;

&lt;p&gt;简单解释中间件：它处于服务器程序与应用程序之间，对服务器程序来说，它相当于应用程序，对应用程序来说，它相当于服务器程序。于是，对用户请求的处理，可以变成多个中间件叠加在一起，每个middleware实现不同的功能。请求从服务器来的时候，依次通过中间件；响应从应用程序返回的时候，反向通过层层中间件。我们可以方便地添加，替换中间件，以便对用户请求作出不同的处理。&lt;/p&gt;

&lt;h2&gt;概览&lt;/h2&gt;

&lt;p&gt;WSGI接口有两种形式：一种针对服务器或gateway，另一种针对web应用或web框架。服务器调用一个由应用程序提供的可调用对象（callable），至于该对象是如何被调用的就要取决于服务器或者gateway。一些服务器或者gateway需要应用程序的部署人员编写一个脚本来起启动服务器或gateway的实例，并把应用程序对象提供给服务器。其他服务器或gateway可以使用配置文件或其他机制来指定应用程序对象该从那里导入或者获取。&lt;/p&gt;

&lt;p&gt;除了&lt;code&gt;pure&lt;/code&gt;（纯）服务器/gateway和web框架/应用，也可以实现创建实现了这份WSGI的中间件。这种中间件对于包含它们的服务器序而言是应用程序，对于它们包含的应用程序而言是服务器，并且用来提供扩展的API，内容转换、导航等其他有用的功能。&lt;/p&gt;

&lt;p&gt;在整篇文章中，我们使用的属于&lt;code&gt;可调用&lt;/code&gt;（callable）的意思是一个函数、方法、类、或者一个包含&lt;code&gt;__call__&lt;/code&gt;方法的实例。者依赖于服务器/框架根据自己所需要的技术来选择实现方式。但是，一个服务器/框架调用一个可调用程序的时候不能依赖调用程序的实现方式。可调用程序仅仅是用来调用的，而不是用来自省的（意思是可调用程序跟&lt;strong&gt;call&lt;/strong&gt;方法没有关系，只是这里的一个术语）。&lt;/p&gt;

&lt;h3&gt;框架/应用程序端&lt;/h3&gt;

&lt;p&gt;应用程序对象是一个接收两个参数的可调用对象。这里的&lt;code&gt;对象&lt;/code&gt;并不是一个真正的对象（python对象），一个函数、方法、类、或者一个包含&lt;code&gt;__call__&lt;/code&gt;方法的实例可以用作应用程序对象。应用程序对象必须能被多次调用，因为几乎所有的服务器/gateway（除了CGI）都会重复的请求。&lt;/p&gt;

&lt;p&gt;（注意：尽管我们把它叫做应用程序对象，但并不是说开发人员要把WSGI当成API来调用。我们假定应用程序开发者仍然使用现有的，高层的框架服务来开发他们的应用程序。WSGI 是一个给框架和服务器开发者用的工具，并且不会提供对应用程序开发者的直接支持。）&lt;/p&gt;

&lt;p&gt;如下是应用程序对象的两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def simple_server(environ, start_response):
    &quot;&quot;&quot;Simplest possible application object&quot;&quot;&quot;
    status = &quot;200 OK&quot;
    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]
    start_response(status, response_headers)
    return [&#39;Hello world !\n&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;class AppClass:
    &quot;&quot;&quot;Produce the same output, but using a class
    注意：AppClass 就是这里的 application，所以调用它的时候会返回AppClass的一个实例，这个实例迭代的返回‘application callable’该返回的对象。
    如果我们想使用AppClass的实例，我们需要实现一个__call__方法，外部通过调用这个方法来执行应用程序，并且我们需要创建一个实例给服务器使用
    &quot;&quot;&quot;
    def __init__(self, environ, start_response):
        self.environ = environ
        self.start_response = start_response

    def __iter__(self):
        status = &quot;200 OK&quot;
        response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]
        self.start_response(status, response_headers)
        yield &quot;Hello world !\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;服务器/gateway端&lt;/h3&gt;

&lt;p&gt;每次收到从HTTP客户端来的请求服务器就会调用应用程序。下面是一个简单的CGI gateway，以一个接受一个应用程序对象作为参数的函数来实现。这个简单的例子还拥有有限的容错功能，因为未捕捉的异常默认会写到 sys.error 里并被web服务器记录下来.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import os, sys

def run_with_cgi(application):

    environ = dict(os.environ.items())
    environ[&#39;wsgi.input&#39;]        = sys.stdin
    environ[&#39;wsgi.errors&#39;]       = sys.stderr
    environ[&#39;wsgi.version&#39;]      = (1, 0)
    environ[&#39;wsgi.multithread&#39;]  = False
    environ[&#39;wsgi.multiprocess&#39;] = True
    environ[&#39;wsgi.run_once&#39;]     = True

    if environ.get(&#39;HTTPS&#39;, &#39;off&#39;) in (&#39;on&#39;, &#39;1&#39;):
        environ[&#39;wsgi.url_scheme&#39;] = &#39;https&#39;
    else:
        environ[&#39;wsgi.url_scheme&#39;] = &#39;http&#39;

    headers_set = []
    headers_sent = []

    def write(data):
        if not headers_set:
             raise AssertionError(&quot;write() before start_response()&quot;)

        elif not headers_sent:
             # Before the first output, send the stored headers
             status, response_headers = headers_sent[:] = headers_set
             sys.stdout.write(&#39;Status: %s\r\n&#39; % status)
             for header in response_headers:
                 sys.stdout.write(&#39;%s: %s\r\n&#39; % header)
             sys.stdout.write(&#39;\r\n&#39;)

        sys.stdout.write(data)
        sys.stdout.flush()

    def start_response(status, response_headers, exc_info=None):
        if exc_info:
            try:
                if headers_sent:
                    # Re-raise original exception if headers sent
                    raise exc_info[0], exc_info[1], exc_info[2]
            finally:
                exc_info = None     # avoid dangling circular ref
        elif headers_set:
            raise AssertionError(&quot;Headers already set!&quot;)

        headers_set[:] = [status, response_headers]
        return write

    result = application(environ, start_response)
    try:
        for data in result:
            if data:    # don&#39;t send headers until body appears
                write(data)
        if not headers_sent:
            write(&#39;&#39;)   # send headers now if body was empty
    finally:
        if hasattr(result, &#39;close&#39;):
            result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;中间件&lt;/h3&gt;

&lt;p&gt;我们知道有些中间件又能当成服务器又能当成应用程序，这些中间件可以提供这样的一些功能
- 根据目标url将请求传递到不同应用程序对象
- 允许多个应用程序和框架在同一个进程中执行
- 通过在网络上传递请求和响应实现负载均衡和远程处理
- 对内容进行加工&lt;/p&gt;

&lt;p&gt;中间件对于服务器和应用程序都是透明的，所以不需要特殊支持。想在应用程序中加入中间件的用户只需要把中间件当成应用程序提供给服务器。当然，这里的中间件包裹的“应用程序”可能还还有中间件，层层包裹就形成了所谓的&lt;code&gt;中间件堆栈&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;大多数情况下，中间件需要符合服务器端和应用程序端的限制和要求。有时候，中间件的要求会比纯纯服务器和纯应用程序的要求更苛刻。&lt;/p&gt;

&lt;p&gt;这里有一个中间件组件的例子，它用Joe Strout的piglatin.py将text/plain的响应转换成pig latin（注意：真正的中间件应该使用更加安全的方式——应该检查内容的类型和内容的编码，这个简单的例子还忽略了一个单词跨块进行行分裂的可能性)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from piglatin import piglatin

class LatinIter:

    &quot;&quot;&quot;Transform iterated output to piglatin, if it&#39;s okay to do so

    Note that the &quot;okayness&quot; can change until the application yields
    its first non-empty string, so &#39;transform_ok&#39; has to be a mutable
    truth value.
    &quot;&quot;&quot;

    def __init__(self, result, transform_ok):
        if hasattr(result, &#39;close&#39;):
            self.close = result.close
        self._next = iter(result).next
        self.transform_ok = transform_ok

    def __iter__(self):
        return self

    def next(self):
        if self.transform_ok:
            return piglatin(self._next())
        else:
            return self._next()

class Latinator:

    # by default, don&#39;t transform output
    transform = False

    def __init__(self, application):
        self.application = application

    def __call__(self, environ, start_response):

        transform_ok = []

        def start_latin(status, response_headers, exc_info=None):

            # Reset ok flag, in case this is a repeat call
            del transform_ok[:]

            for name, value in response_headers:
                if name.lower() == &#39;content-type&#39; and value == &#39;text/plain&#39;:
                    transform_ok.append(True)
                    # Strip content-length if present, else it&#39;ll be wrong
                    response_headers = [(name, value)
                        for name, value in response_headers
                            if name.lower() != &#39;content-length&#39;
                    ]
                    break

            write = start_response(status, response_headers, exc_info)

            if transform_ok:
                def write_latin(data):
                    write(piglatin(data))
                return write_latin
            else:
                return write

        return LatinIter(self.application(environ, start_latin), transform_ok)


# Run foo_app under a Latinator&#39;s control, using the example CGI gateway
from foo_app import foo_app
run_with_cgi(Latinator(foo_app))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;详细信息&lt;/h2&gt;

&lt;p&gt;应用程序对象必须接收两个参数，我们把它命名为&lt;code&gt;environ&lt;/code&gt;和&lt;code&gt;start_response&lt;/code&gt;（可随意修改），服务器&lt;strong&gt;必须&lt;/strong&gt;根据关键字位置（而不是名称）调用应用程序如&lt;code&gt;result = application(environ, start_response)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里&lt;code&gt;environ&lt;/code&gt;是一个包含CGI-style环境变量的字典对象，这个对象&lt;strong&gt;必须&lt;/strong&gt;是python内建的字典对象（不是子类、UserDict或其他字典对象），应用程序可以自由的修改这个对象。这个字典还必须包含一些必须的WSGI所需要的变量（后文有描述），还可能包含一些服务器特定的变量，这些变量根据下文描述的惯例命名。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;是一个接收两个必选参数和一个可选参数的可调用对象，把这几个参数依次命名为&lt;code&gt;status&lt;/code&gt;、&lt;code&gt;response_headers&lt;/code&gt;、&lt;code&gt;exc_info&lt;/code&gt;（可随意修改命名），调用的时候&lt;strong&gt;必须&lt;/strong&gt;根据参数位置调用如&lt;code&gt;start_response(status, response_headers)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;status&lt;/code&gt;是格式如&lt;code&gt;999 msg here&lt;/code&gt;的状态码，&lt;code&gt;response_headers&lt;/code&gt;是一个由如&lt;code&gt;(header_name, header_value)&lt;/code&gt;的元组组成的列表，它描述了HTTP响应的响应头。&lt;code&gt;exc_info&lt;/code&gt;将会在下文的 &lt;a href=&quot;&quot;&gt;The start_response() Callable&lt;/a&gt;、&lt;a href=&quot;&quot;&gt;出错处理&lt;/a&gt;中讲到，这个参数只有在应用程序捕获出错并且要将错误输出到浏览器的时候才会用到。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;可调用程序必须返回一个可调用的&lt;code&gt;write(body_data)&lt;/code&gt;，它接收一个可选参数：一个可以作为HTTP响应体(response body)一部分的字符串。（注意：提供可调用的write()只是为了支持现有的框架必要的输出API，新的框架应尽可能避免使用，详见&lt;a href=&quot;&quot;&gt;Buffering and Streaming&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;当被调用时，应用程序对象必须返回一个可以产生0或者多个字符串的iterable（yielding zero or more strings）。有很多方法可以实现这个目标，比如返回一个字符串列表，或者应用程序本身是个可以返回字符串的生成器函数(generator function that yield strings)，或者应用程序本身是一个可以产生可迭代对象的类。&lt;/p&gt;

&lt;p&gt;服务器必须将产生的的字符串（也就是上文中返回的yielded string）无缓冲的发送给客户端，每次传输完成之后才能取下一个字符串（换句话说，应用程序需要实现自己的缓冲区，&lt;a href=&quot;&quot;&gt;Buffering and Streaming&lt;/a&gt;阐述了更多关于如何处理输出的问题。。。这句话的意思是不能将东西缓冲在服务器内，但是可以缓冲在狂间/应用程序内）&lt;/p&gt;

&lt;p&gt;服务器应该把产生的字符串当成字节流处理：特别的是，要确保行末尾没被修改（it should ensure that line endings are not altered）。应用程序负责保证输出的这些字符串的编码是与客户端匹配的。&lt;/p&gt;

&lt;p&gt;如果调 len(iterable) 成功，服务器将认为返回的结果是正确的。也就是说，应用程序返回的可迭代的字符串提供了一个有用 的&lt;strong&gt;len&lt;/strong&gt;() 方法，那么肯定返回了正确的结果。&lt;/p&gt;

&lt;p&gt;如果可迭代对象返回了&lt;code&gt;close()&lt;/code&gt;方法，那么不管这个请求是否成果完成，每次请求结束前服务器都必须在请求结束之前调用这个方法（这是用来支持应用程序对象占用资源的释放）。&lt;/p&gt;

&lt;p&gt;（注意：应用程序必须在可迭代对象产生第一个字符串之前调用&lt;code&gt;start_response&lt;/code&gt;，这样服务器才能先发送header再发送body。但是这个过程也可以发生在可迭代对象第一次迭代前，所以服务器不能保证迭代开始前&lt;code&gt;start_response&lt;/code&gt;已经被调用过了。）&lt;/p&gt;

&lt;p&gt;最后，服务器不能直接调用应用程序返回的可迭代对象的其他任何属性，除非这个属性是针对服务器实现的特定实例。&lt;/p&gt;

&lt;h3&gt;environ变量&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;environ&lt;/code&gt;需要包含如下CGI定义的环境变量。下面的变量必须被呈现出来，除非他的值是空（这时候如果没有特别指出，空值会被忽略）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;REQUEST_METHOD：HTTP请求的方式，比如 &quot;GET&quot; 或者 &quot;POST&quot;， 这个不能是空字符串并且也是必须给出的字段。&lt;/li&gt;
&lt;li&gt;SCRIPT_NAME：请求URL中路径的开始部分，对应应用程序对象，这样应用程序就知道它的虚拟位置。如果该应用程序对应服务器的根的话， 它可能是为空字符串。&lt;/li&gt;
&lt;li&gt;PATH_INFO：请求URL中路径的剩余部分，指定请求的目标在应用程序内部的虚拟位置。如果请求的目标是应用程序跟并且没有trailing slash的话，可能为空字符串 。&lt;/li&gt;
&lt;li&gt;QUERY_STRING：请求URL中跟在&quot;?&quot;后面的那部分,可能为空或不存在。&lt;/li&gt;
&lt;li&gt;CONTENT_TYPE：HTTP请求中任何 Content-Type 域的内容。&lt;/li&gt;
&lt;li&gt;CONTENT_LENGTH：HTTP请求中任何 Content-Length 域的内容。可能为空或不存在。&lt;/li&gt;
&lt;li&gt;SERVER_NAME , SERVER_PORT ：SCRIPT_NAME和PATH_INFO结合可以产生完整的url。但是，如果HTTP_HOST存在的话，优先使用它代替SCRIIPT_NAME。这两个参数都不能为空。&lt;/li&gt;
&lt;li&gt;SERVER_PROTOCOL ：浏览器返送请求的协议版本（如HTTP/1.0），这将决定应用程序如何处理浏览器发送的headers。&lt;/li&gt;
&lt;li&gt;HTTP_ Variables：以&lt;code&gt;HTTP_&lt;/code&gt;打头的变量，也就是对应客户端提供的HTTP请求headers。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;服务器应该尽可能的提供做够多的其他CGI变量。另外，如果使用了SSL，那服务器还要提供足够多的Apache SSL环境变量。但是，请注意，任何使用比上面列出的其他变量的CGI应用程序必然是不可移植到不支持扩展相关的Web服务器。&lt;/p&gt;

&lt;p&gt;注意：不需要的变量一定要移除environ，还有就是CGI定义的变量都是字符串类型（str）。&lt;/p&gt;

&lt;p&gt;除了CGI变量之外，&lt;code&gt;environ&lt;/code&gt;还可以包含操作系统环境变量，下面是必须包含的环境变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wsgi.version：用元组(1,0)表示1.0版本&lt;/li&gt;
&lt;li&gt;wsgi.url_scheme：代表被调用应用程序url的“scheme”字段，通常是&quot;http&quot;或&quot;https&quot;&lt;/li&gt;
&lt;li&gt;wsgi.input：输入流（文件对象），HTTP请求body可以从里面读取&lt;/li&gt;
&lt;li&gt;wsgi.errors：输出流（文件对象），可以将错误写入。这应该是一个文本模式的流，应用程序使用&quot;\n&quot;作为一行的结束，并且假定它可以被服务器转换成正确的行。对许多服务器来说，wsgi.errors是服务器主要的错误日志，也就是说，它也可以是sys.stderr，或者日志文件。&lt;/li&gt;
&lt;li&gt;wsgi.multithread：如果为True，那么应用程序对象就可以在被同一进程中的另一个线程同时调用。&lt;/li&gt;
&lt;li&gt;wsgi.multiprocess：....&lt;/li&gt;
&lt;li&gt;wsgi.run_once：如果为True，服务器将认为应用程序只在它所被包含的进程的生命周期中调用一次。通常，只有在基于CGI的网关中才为True。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后 environ 字典也可以包含服务器定义的变量。这些变量的名字必须是小写字母、数字、点和下划线，并且应该带一个能唯一代表服务器的前缀。比如， mod_python可能会定义象这样的一些变量:&lt;code&gt;mod_python.some_variable&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;输入和错误流&lt;/h4&gt;

&lt;p&gt;输入和错误流必须支持如下方法&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 方法名         &lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;  流      &lt;/th&gt;
&lt;th style=&quot;text-align:right;&quot;&gt;  注解  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; read(size)    &lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt; input    &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;  1     &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; readline()    &lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt; input    &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;   1,2  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;readlines(hint)&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt; input    &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt; 1,3   &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;iter&lt;/strong&gt;()     &lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;input     &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;        &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flush()        &lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error     &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;    4   &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;write(str)     &lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error     &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;        &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;writelines(seq)&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error     &lt;/td&gt;
&lt;td style=&quot;text-align:right;&quot;&gt;        &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;ol&gt;
&lt;li&gt;服务器不需要通过读取客户端全部内容来计算Content-Length长度，但是如果应用程序试图这样做，就可以用这一点来模拟文件结束的条件。应用程序不应该读取长度大于Content-Length变量的数据。&lt;/li&gt;
&lt;li&gt;readline并不支持可选参数’size‘，因为它对于服务器开发者来实现有些复杂了，并且也不常使用&lt;/li&gt;
&lt;li&gt;可选参数’hint‘对应用程序和服务器都是可有可无的&lt;/li&gt;
&lt;li&gt;由于错误流可能无法倒回，服务器端可以无缓冲的转发写操作，flash()方法可以是空。应用程序就不行了，它不能认为flash()是个空操作也不能认为输出无缓冲。它们必须调用flash()来确保输出。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;符合本说明的服务器都必须支持上面这些方法，符合本说明的应用程序/框架使用输入流对象及错误流对象时，只能使用这些方法，禁止使用其它方法。需要指出的是，应用程序不能试图关闭这些流，即便他们有close()方法。&lt;/p&gt;

&lt;h3&gt;start_response()&lt;/h3&gt;

&lt;p&gt;这是应用程序/框架对象的第二个参数&lt;code&gt;start_response(status,response_headers,exc_info=None)&lt;/code&gt;，&lt;code&gt;start_response&lt;/code&gt;是用来开始一个HTTP响应的，而且它必须返回一个&lt;code&gt;write(body_data)&lt;/code&gt;的可调用对象。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;status&lt;/code&gt;只能是&lt;code&gt;404 Not Found&lt;/code&gt;这种格式的，不能有回车之类乱七八糟的控制字符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;response_headers&lt;/code&gt;前面说过了，是&lt;code&gt;(header_name, header_value)&lt;/code&gt;类型的元组(type(response_headers) is List)，内容可以由服务器修改但&lt;code&gt;header_name&lt;/code&gt;必须符合HTTP标准。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;header_value&lt;/code&gt;不能包含任何控制字符。&lt;/p&gt;

&lt;p&gt;一般情况下，服务器需要保证送到客户端的HTTP头是正确的：如果应用程序省略了HTTP需要的头，服务器就要加上去。&lt;/p&gt;

&lt;p&gt;（注意：HTTP头的名字是大小写敏感的，在应用程序检查的时候要注意这个问题）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;不能直接传输响应headers，它需要为服务器保存这些headers，直到应用程序返回值的第一个迭代对象yields一个非空字符串，或者应用程序第一次调用&lt;code&gt;write()&lt;/code&gt;方法的时候，服务器才传输这些headers。换句话说，只有当body data可用时或者应用程序返回的可迭代对象耗尽时才传输这些headers，唯一的例外是头部Content-Length本身就为0(这其实是在说，HTTP响应body部分必须有数据，不能只返回一个header。有这句话前面句简直废话还看不懂)。&lt;/p&gt;

&lt;p&gt;响应头的传输延迟是为了确保缓冲和异步应用程序能在请求结束前的任何时刻用error message代替原本的输出。例如，当在缓冲区内的body产生的时候出错，应用程序就要把响应码从“200 OK”改成“500 Internal Error”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exc_info&lt;/code&gt;一旦被提供的话，就必须是&lt;code&gt;sys.exc_info()&lt;/code&gt;返回值的相同元组格式的。只有在&lt;code&gt;start_response&lt;/code&gt;被error handler调用的时候，这个参数才需要被提供。如果有&lt;code&gt;exc_info&lt;/code&gt;参数，并且还没有HTTP headers被输出，&lt;code&gt;start_response&lt;/code&gt;就需要用新的HTTP response headers替换当前存储的HTTP response headers，从而使应用程序在出错的时候“改变主意”。&lt;/p&gt;

&lt;p&gt;但是如果&lt;code&gt;exc_info&lt;/code&gt;被提供了，而且HTTP headers也被发送了，&lt;code&gt;start_response&lt;/code&gt;就必须raise a error，也需要raise the exc_info
tuple， 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;raise exc_info[0], exc_info[1], exc_info[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将重新抛出被应用程序捕获的异常，并且原则上要终止应用程序（在HTTP headers被发送之后还继续将错误信息发送到浏览器是不安全的）。如果使用了&lt;code&gt;exc_info&lt;/code&gt;参数，应用程序不能捕获任何&lt;code&gt;start_response&lt;/code&gt;抛出的异常，应该交给服务器处理。&lt;/p&gt;

&lt;p&gt;只有当&lt;code&gt;exc_info&lt;/code&gt;被提供的时候，应用程序才有可能多次调用&lt;code&gt;start_response&lt;/code&gt;。 （参见示例：CGI gateway 正确的逻辑的示意图。）&lt;/p&gt;

&lt;p&gt;注意：为了避免循环引用，start_response实现时需要保证 exc_info在函数调用后不再包含引用。服务器或者中间件实现&lt;code&gt;start_response&lt;/code&gt;的时候要确保在函数生命周期之后&lt;code&gt;exc_info&lt;/code&gt;的值是空，要做到这一点最简单的办法是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def start_response(status, response_headers, exc_info=None):
    if exc_info:
         try:
             # do stuff w/exc_info here
         finally:
             exc_info = None    # Avoid circular ref.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CGI gateway也提供了这个技术的示意图&lt;/p&gt;

&lt;h4&gt;处理Content-Length&lt;/h4&gt;

&lt;p&gt;如果应用程序支持 Content-Length，那么服务器程序传递的数据大小不应该超过 Content-Length，当发送了足够的数据后，应该停止迭代，或者raise一个error。当然，如果应用程序返回的数据大小没有它指定的Content-Length那么多，那么服务器程序应该关闭连接，使用Log记录，或者报告错误。&lt;/p&gt;

&lt;p&gt;如果应用程序没有提供这个header，服务器就需要从多种处理办法中选一个处理，最简单的处理方式就是在响应结束时关闭客户端连接。&lt;/p&gt;

&lt;p&gt;有时候，服务器有可能可以自己添加一个Content-Length header，或者至少避免直接关闭连接。如果应用程序没有调用write()，并且返回的可迭代对象的len()是1，服务器就能自动的用可迭代对象yield的第一个字符串的长度当成Content-Length的长度。&lt;/p&gt;

&lt;h3&gt;Buffering and Streaming&lt;/h3&gt;

&lt;p&gt; 一般情况下，应用程序会把需要返回的数据放在缓冲区里，然后一次性发送出去。之前说的应用程序会返回一个可迭代对象，多数情况下，这个可迭代对象，都只有一个元素，这个元素包含了HTML内容。但是在有些情况下，数据太大了，无法一次性在内存中存储这些数据，所以就需要做成一个可迭代对象，每次迭代只发送一块数据。&lt;/p&gt;

&lt;p&gt;禁止服务器程序延迟任何一块数据的传送，要么把一块数据完全传递给客户端，要么保证在产生下一块数据时，继续传递这一块数据。&lt;/p&gt;

&lt;p&gt;服务器/中间件可以从下面三种方法中选取一种实现：
1. 在收回应用程序控制权之前把全部的数据块发送给操作系统。
2. 在应用程序产生下一个块的时候另起一个线程来传输
3. （中间件才能实现）把数据传输给父容器（服务器/中间件）&lt;/p&gt;

&lt;h4&gt;中间件处理程序块边界&lt;/h4&gt;

&lt;p&gt;为了更好的处理异步，如果 middleware调用的应用程序产生了数据，那么middleware至少要产生一个数据，即使它想等数据积累到一定程度再返回，它也需要产生一个空的bytestring。&lt;/p&gt;

&lt;p&gt; 注意，这也意味着只要middleware调用的应用程序产生了一个可迭代对象，middleware也必须返回一个可迭代对象。 同时，禁止middleware使用可调用对象write传递数据，write是middleware调用的应用程序使用的。&lt;/p&gt;

&lt;h4&gt;write()&lt;/h4&gt;

&lt;p&gt;一些现有的框架可能提供了不符合WSGI的输出API，比如说无缓冲的&lt;code&gt;write&lt;/code&gt;，或者有缓冲的&lt;code&gt;write&lt;/code&gt;但是是使用&lt;code&gt;flush&lt;/code&gt;技术清空缓冲区。但是这些API不能用WSGI的返回迭代的方式实现，除非使用了线程或者其他特别的技术。所以，为了让这些框架能继续使用当前的API，WSGI就包含了一个特殊的&lt;code&gt;write&lt;/code&gt;可调用对象，他由&lt;code&gt;start_response&lt;/code&gt;返回。&lt;/p&gt;

&lt;p&gt;但是，如果能避免使用这个 write，最好避免使用，这是为兼容以前的应用程序而设计的。这个write的参数是HTTP response body的一部分，这意味着在write()返回前，必须保证传给它的数据已经完全被传送到客户端，或者已经放在缓冲区了。&lt;/p&gt;

&lt;p&gt;应用程序必须返回一个可迭代对象，即使它使用write产生HTTP response body。&lt;/p&gt;

&lt;h3&gt;unicode问题&lt;/h3&gt;

&lt;p&gt;HTTP和这里的接口都不会直接支持unicode，所有的编码解码问题都要应用程序来做：传递到服务器的字符串必须是&lt;code&gt;python byte string&lt;/code&gt;而不是&lt;code&gt;unicode object&lt;/code&gt;，如果格式不对，结果会是未定义。&lt;/p&gt;

&lt;p&gt;同时，传递给&lt;code&gt;start_response&lt;/code&gt;的字符串必须&lt;code&gt;RFC 2616&lt;/code&gt;编码，也就是说它必须是&lt;code&gt;ISO-8859-1&lt;/code&gt;的字符串或者&lt;code&gt;RFC 2047 MIME&lt;/code&gt;编码。&lt;/p&gt;

&lt;p&gt;本规范涉及到的所有string都是&lt;code&gt;str&lt;/code&gt;或&lt;code&gt;StringType&lt;/code&gt;，决不能是&lt;code&gt;unicode&lt;/code&gt;或&lt;code&gt;unicodeType&lt;/code&gt;的。即使当前平台支持多余8微的字符串，在本规范中的字符串也只能取低8位。&lt;/p&gt;

&lt;h3&gt;出错处理&lt;/h3&gt;

&lt;p&gt;一般情况下，应用程序应该尽可能的捕获自己内部的错误，并且在浏览器中显示有用的信息。&lt;/p&gt;

&lt;p&gt;要显示这种信息，应用程序就必须还没有发送任何数据到浏览器，否则会破坏正常的响应。因此WSGI提供了一种机制，它允许应用程序发送错误信息，或终止响应：在&lt;code&gt;start_response&lt;/code&gt;中给出&lt;code&gt;exc_info&lt;/code&gt;参数，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;try:
    # regular application code here
    status = &quot;200 Froody&quot;
    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
    start_response(status, response_headers)
    return [&quot;normal body goes here&quot;]
except:
    # XXX should trap runtime issues like MemoryError, KeyboardInterrupt
    #     in a separate handler before this bare &#39;except:&#39;...
    status = &quot;500 Oops&quot;
    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
    start_response(status, response_headers, sys.exc_info())
    return [&quot;error body goes here&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果发生异常的时候还没有任何数据被写入，那么&lt;code&gt;start_response&lt;/code&gt;就会返回正常，应用程序也会返回一个出错body给浏览器。如果异常时已经有数据发送给浏览器，那么&lt;code&gt;start_response&lt;/code&gt;就会重新抛出异常。这种异常不应该被应用程序捕获，这样应用程序才能被终止！服务器可以捕获这种（致命）的错误，然后终止响应。&lt;/p&gt;

&lt;p&gt;服务器需要捕获并且记录那些使应用程序或者应用程序返回的可迭代对象终止的异常，如果在异常之前已经有数据发送给浏览器，那么服务器将尝试添加一个error message浏览器，如果已经发送的数据中有&lt;code&gt;text/*&lt;/code&gt;，服务器也知道该如何处理。&lt;/p&gt;

&lt;p&gt;有些中间件可能希望提供额外的出错处理服务，或者说拦截、替换应用程序产生的出错信息。这种情况下，中间件可以不用为&lt;code&gt;start_response&lt;/code&gt;提供&lt;code&gt;exc_info&lt;/code&gt;参数，而是抛出一个特定的额中间件异常，或者干脆存储提供参数之后无异常。这就让应用程序返回its error body iterable，并且允许中间件修改error output。只要开发人员尊需以下规则，这项技术就可以工作：
1. 当发生一个error response的时候总是提供&lt;code&gt;exc_info&lt;/code&gt;
2. 当&lt;code&gt;exc_info&lt;/code&gt;被提供的时候，绝对不要捕获&lt;code&gt;start_response&lt;/code&gt;产生的异常。&lt;/p&gt;

&lt;h3&gt;HTTP 1.1 Expect/Continue&lt;/h3&gt;

&lt;h3&gt;Other HTTP Features&lt;/h3&gt;

&lt;h3&gt;线程支持&lt;/h3&gt;

&lt;p&gt;是否支持线程，也取决于服务器。可并行运行多个请求的服务器也应该提供单线程运行应用程序的选项，如此一来，非线程安全的框架或者应用程序都能使用这个服务器。&lt;/p&gt;

&lt;h2&gt;实现&lt;/h2&gt;

&lt;h3&gt;服务器扩展API&lt;/h3&gt;

&lt;p&gt;有些服务器作者可能想给出更先进的API，这些API可以用于让框架作者处理专门的功能。例如，基于&lt;code&gt;mod_python&lt;/code&gt;的gateway可能希望提供Apache 的一部分API作为WSGI的扩展。&lt;/p&gt;

&lt;p&gt;简单情况下，这种实现值需要在&lt;code&gt;environ&lt;/code&gt;中添加特定的环境变量就行了，比如&lt;code&gt;mod_python.some_api&lt;/code&gt;。但多数情况下，中间可能会带来困难。比如一个API可以访问一个特定的能在&lt;code&gt;environ&lt;/code&gt;中找到的HTTP header，但是很有可能访问到的只是被中间件修改过后的值。&lt;/p&gt;

&lt;p&gt;一般情况下，扩展API和中间件的不兼容会带来风险，服务器开发者也不应该假设每人会使用中间件。&lt;/p&gt;

&lt;p&gt;为了提供最大程度额兼容，提供扩展API代替WSGIAPI的服务器必须把这些API设计成像被替代的那一部分API的调用方式那样调用。如果扩展API不能保证永远与&lt;code&gt;environ&lt;/code&gt;中的HTTP header标志的内容一致，就必须拒绝应用程序跑在这个服务器上，比如说可以raise a error 或者返回 None。&lt;/p&gt;

&lt;p&gt;同样，如果扩展API提供了写响应数据或者headers的手段，就必须在应用程序得到扩展服务之前让&lt;code&gt;start_response&lt;/code&gt;被传入。如果传入的对象和服务器原先给出的不一样，它就不能保证正确的操作，并且应该被终止。&lt;/p&gt;

&lt;p&gt;让服务器/中间件开发者遵循安全的可扩展API规定是很重要也很必要的！&lt;/p&gt;

&lt;h3&gt;应用配置&lt;/h3&gt;

&lt;p&gt;这里并不是定义服务器如何去调用一个应用程序，因为这些选项有关服务器高级配置，需要服务器作者在文档中写明。&lt;/p&gt;

&lt;p&gt;同样，框架的作者也需要在文档中说明如何利用框架创建一个可执行的应用程序。用户必须自己把选择的框架和服务器结合在一起。尽管框架和服务器有共同的接口，但这仅仅是物理上的问题，比不影响每个框架/服务器的配对。&lt;/p&gt;

&lt;p&gt;有些应用程序、框架或中间件可能希望通过&lt;code&gt;environ&lt;/code&gt;来获取简单的配置字符串，这时候服务器应该支持应用程序能向&lt;code&gt;environ&lt;/code&gt;中加入键值对。简单情况下，这个过程只需要把&lt;code&gt;os.environ&lt;/code&gt;所提供的环境变量加入到&lt;code&gt;environ&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;应用程序应该尽量把这种需求降到最低，因为并不是所有的服务器都支持简单配置。最坏情况下，部署人员可以提供一个简单的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from the_app import application

def new_app(environ, start_response):
    environ[&#39;the_app.configval1&#39;] = &#39;something&#39;
    return application(environ, start_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大多数常见的框架都只需要一个&lt;code&gt;environ&lt;/code&gt;的值来指定应用程序的配置文件地址（当然，应用程序应该cache这些配置，以避免每次调用都需要重新读取文件）。&lt;/p&gt;

&lt;h3&gt;URL重建&lt;/h3&gt;

&lt;p&gt;如果一个应用程序希望重建完整的请求url，那么他可能需要下面的算法，contributed by Ian Bicking：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from urllib import quote
url = environ[&#39;wsgi.url_scheme&#39;]+&#39;://&#39;

if environ.get(&#39;HTTP_HOST&#39;):
    url += environ[&#39;HTTP_HOST&#39;]
else:
    url += environ[&#39;SERVER_NAME&#39;]

    if environ[&#39;wsgi.url_scheme&#39;] == &#39;https&#39;:
        if environ[&#39;SERVER_PORT&#39;] != &#39;443&#39;:
           url += &#39;:&#39; + environ[&#39;SERVER_PORT&#39;]
    else:
        if environ[&#39;SERVER_PORT&#39;] != &#39;80&#39;:
           url += &#39;:&#39; + environ[&#39;SERVER_PORT&#39;]

url += quote(environ.get(&#39;SCRIPT_NAME&#39;, &#39;&#39;))
url += quote(environ.get(&#39;PATH_INFO&#39;, &#39;&#39;))
if environ.get(&#39;QUERY_STRING&#39;):
    url += &#39;?&#39; + environ[&#39;QUERY_STRING&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候重建的url可能跟浏览器请求的url不太一样，有可能是服务器重写url的规则把客户端请求的url修改成了服务器认为规范的形式，或者其他原因。&lt;/p&gt;

&lt;h3&gt;Supporting Older( &amp;lt; 2.2)Versions of Python&lt;/h3&gt;

&lt;h3&gt;特定平台文件处理&lt;/h3&gt;

&lt;p&gt;有些操作环境提供高效的文件级传输设备，比如说Unix的&lt;code&gt;sendfile()&lt;/code&gt;调用。服务器可以通过&lt;code&gt;environ&lt;/code&gt;中配置&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;选项来揭露此功能。应用程序可以使用这个“file wrapper”来把file-like的对象转换为iterable再返回。
&lt;code&gt;python
if &#39;wsgi.file_wrapper&#39; in environ:
    return environ[&#39;wsgi.file_wrapper&#39;](filelike, block_size)
else:
    return iter(lambda: filelike.read(block_size), &#39;&#39;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果服务器支持&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;，那么他的值必须是一个可以接一个必填参数和一个可选参数的可调用对象。第一个参数是将要发送文件的对象，第二个是建议的block size（服务器中不需要使用）。这个可调用对象必须返回一个iterable object，而且只有在应用程序把这个iterable返回给服务器并且服务器收到的时候，它才可以传输数据。&lt;/p&gt;

&lt;p&gt;一个file-like对象必须有接收一个可选叫块大小的可选参数的read()方法，它也可以有close()方法有，一旦有close()方法，&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;对象就必须有一个可以调用file-like文件close()方法的close()方法。如果file-like对象有任何跟Python内置文件对象相同的方法或者属性（如fileon()），&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;可以假设这些方法和属性都是和内置的方法属性一样。&lt;/p&gt;

&lt;p&gt;特定平台文件处理的实际调用都必须在应用程序返回之后，由服务器检查是否返回了一个wrapper对象。&lt;/p&gt;

&lt;p&gt;跟处理&lt;code&gt;close()&lt;/code&gt;不同的是，从应用程序返回一个file wrapper和返回iter(filelike.read,&quot;&quot;)的语义是一样的。也就是说，传输开始时，起始位置应该是文件的当前位置，这个过程一直持续到结束。&lt;/p&gt;

&lt;p&gt;当然，特定平台的文件传输API并不会接收任意的file-like对象。因此一个&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;必须自省(检查)所提供的file-like对象以确定是否支持。&lt;/p&gt;

&lt;p&gt;需要注意的是，即便该file-like对象不支持对应平台的API，&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;也应该返回一个包含read()和close()的iterator，这样应用程序才是可移植的。就像下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;class FileWrapper:

    def __init__(self, filelike, blksize=8192):
        self.filelike = filelike
        self.blksize = blksize
        if hasattr(filelike, &#39;close&#39;):
            self.close = filelike.close

    def __getitem__(self, key):
        data = self.filelike.read(self.blksize)
        if data:
            return data
        raise IndexError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是一个服务器利用上面方法来访问特定平台API的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;environ[&#39;wsgi.file_wrapper&#39;] = FileWrapper
result = application(environ, start_response)

try:
    if isinstance(result, FileWrapper):
        # check if result.filelike is usable w/platform-specific
        # API, and if so, use that API to transmit the result.
        # If not, fall through to normal iterable handling
        # loop below.

    for data in result:
        # etc.

finally:
    if hasattr(result, &#39;close&#39;):
        result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Q &amp;amp; A&lt;/h2&gt;
</description>
				<pubDate>Tue, 31 Mar 2015 00:00:00 +0800</pubDate>
				<link>/2015/03/31/zh-cn-PEP333.html</link>
				<guid isPermaLink="true">/2015/03/31/zh-cn-PEP333.html</guid>
			</item>
		
			<item>
				<title>python小技巧</title>
        <description>&lt;h4&gt;迭代一个列表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;string=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
for index in range(len(string)):
    print index, string[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;string=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
for index, item in enumerate(string):
    pring index, item
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;检查列表中的每个元素&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;python &quot;&gt;numbers = [10,100,1000,10000]
if [number for numeber in numbers if number&amp;lt;10000]:
    print &quot;at list one small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python &quot;&gt;numbers = [10,100,1000,10000]
if any(number &amp;lt; 10000 for number in numbers):
    print &quot;at list one small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python &quot;&gt;numbers = [10,100,1000,10000]
if all(number &amp;lt; 10000 for number in numbers):
    print &quot;all small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;函数&lt;/h2&gt;

&lt;h4&gt;默认值只被计算一次&lt;/h4&gt;

&lt;p&gt;在python中，函数的默认值是在函数定义的时候实例化的，而不是在函数调用的时候！所以会出现下面结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python &quot;&gt;def func(item, stuff=[]):
    stuff.append(item)
    print stuff
func(1)
#print &quot;[1]&quot;
func(2)
#print &quot;[1,2]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def foo(number=[]):
    number.append(9)
    print number
foo()
#[9]
foo([1,2])
#[1,2,9]
foo()
#[9]
foo()
#[9,9]
foo()
#[9,9,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要理解的是，调用函数的时候，这个默认值会被赋成不同值是因为每次在给函数指定一个默认值的时候，python都会储存这个值。如果在调用函数的时候重写了默认值，那么这个储存的值就不会被使用。当你不重写默认值的时候，python就会让默认值引用储存的值（例子中的number）。它并不是将存储的值拷贝来为这个变量赋值，可以这样理解：有两个变量，一个是内部的，一个是当前运行时的变量。现实就是我们有两个变量来用相同的值进行交互，所以一旦number发生变化，也会改变python里面保存的初始记录。&lt;/p&gt;

&lt;p&gt;但是问题不是我们想想那么简单的，比如下面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def foo(count=0):
    count+=1
    print count
foo()
#1
foo()
#1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么上面函数运行的时候又是符合预期的呢？原因很简单，整形是一种不可变的类型，跟list不同，在函数的执行过程中，整形变量是不能被改变的。当我们执行count+=1的时候，我们并没有改变count的值，而是将count指向了新的地址；而在前面使用list的时候，我们是直接在当前地址操作了变量。&lt;/p&gt;

&lt;p&gt;需要记住的有两个点：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;在python中，函数的默认值是在函数定义的时候实例化的，而不是在函数调用的时候！&lt;/p&gt;

&lt;p&gt;默认值会发生改变，是因为我们直接操作的默认值的地址。&lt;/p&gt;&lt;/blockquote&gt;
</description>
				<pubDate>Wed, 04 Feb 2015 00:00:00 +0800</pubDate>
				<link>/2015/02/04/python-skills.html</link>
				<guid isPermaLink="true">/2015/02/04/python-skills.html</guid>
			</item>
		
			<item>
				<title>博客搬家</title>
        <description>&lt;p&gt;新地址给出之前，这里都不会停止更新&lt;/p&gt;
</description>
				<pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
				<link>/2014/11/10/nothing.html</link>
				<guid isPermaLink="true">/2014/11/10/nothing.html</guid>
			</item>
		
			<item>
				<title>重用命令记录</title>
        <description>&lt;h2&gt;基础命令：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;显示时间：date
显示日历：cal [ [ month] year ]
计算器：bc
列出文件：ls
复制：cp
切换目录：cd
切换用户：su 
内核版本查看：uname [ra]
查看当前目录：pwd
创建删除目录：mkdir 、 rmdir
移动和重命名文件：mv
删除文件：rm 
查看文件内容：cat [AbEnTv]
反向查看文件内容：tac
添加行号打印：nl
翻页查看：more，less
提取数据部分行：head，tail
读取非纯文本文件：od [acdfox]
修改文件创建时间或新建文件：touch
文件默认权限：umask
文件影藏属性：chattr（设置），lsattr（显示）
查看文件类型：file
查找执行文件：which
寻找特定文件：whereis，locate，find（后面做详细介绍）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;linux文件属性&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;权限：rwx权值分别是421
chgrp：更改文件所属用户组 chgrp group1 test.txt
chown：更改文件所有者： chown user1 test.txt
chmod：更改权限 chmod 744 test.txt
参数-R可以递归将文件夹下面的所有更改
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;硬件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;查看主板的序列号: dmidecode | grep -i ’serial number’
用硬件检测程序kuduz探测新硬件：service kudzu start ( or restart)
查看CPU信息：cat /proc/cpuinfo [dmesg | grep -i &#39;cpu&#39;][dmidecode -t processor]
查看内存信息：cat /proc/meminfo [free -m][vmstat]
查看板卡信息：cat /proc/pci
查看显卡/声卡信息：lspci |grep -i ‘VGA’[dmesg | grep -i &#39;VGA&#39;]
查看网卡信息：dmesg | grep -i ‘eth’[cat /etc/sysconfig/hwconf | grep -i eth][lspci | grep -i &#39;eth&#39;]
查看PCI信息：lspci (相比cat /proc/pci更直观）
查看USB设备：cat /proc/bus/usb/devices
查看键盘和鼠标:cat /proc/bus/input/devices
查看系统硬盘信息和使用情况：fdisk &amp;amp; disk – l &amp;amp; df
查看各设备的中断请求(IRQ):cat /proc/interrupts
查看系统体系结构：uname -a
查看及启动系统的32位或64位内核模式：isalist –v [isainfo –v][isainfo –b]
dmidecode查看硬件信息，包括bios、cpu、内存等信息
测定当前的显示器刷新频率：/usr/sbin/ffbconfig –rev /?
查看系统配置：/usr/platform/sun4u/sbin/prtdiag –v
查看当前系统中已经应用的补丁：showrev –p
显示当前的运行级别：who –rH
查看当前的bind版本信息：nslookup –class=chaos –q=txt version.bind
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;dmesg | more 查看硬件信息
lspci 显示外设信息, 如usb，网卡等信息
lsnod 查看已加载的驱动
lshw
psrinfo -v 查看当前处理器的类型和速度（主频）
prtconf -v 打印当前的OBP版本号
iostat –E 查看硬盘物理信息(vendor, RPM, Capacity)
prtvtoc /dev/rdsk/c0t0d0s 查看磁盘的几何参数和分区信息
df –F ufs –o i 显示已经使用和未使用的i-node数目
isalist –v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cpuinfo 主机CPU信息
Dma 主机DMA通道信息
Filesystems 文件系统信息
Interrupts 主机中断信息
Ioprots 主机I/O端口号信息
Meninfo 主机内存信息
Version Linux内存版本信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;备注： proc – process information pseudo-filesystem 进程信息伪装文件系统&lt;/p&gt;

&lt;h2&gt;系统&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# uname -a # 查看内核/操作系统/CPU信息
# head -n 1 /etc/issue # 查看操作系统版本
# cat /proc/cpuinfo # 查看CPU信息
# hostname # 查看计算机名
# lspci -tv # 列出所有PCI设备
# lsusb -tv # 列出所有USB设备
# lsmod # 列出加载的内核模块
# env # 查看环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# free -m # 查看内存使用量和交换区使用量
# df -h # 查看各分区使用情况
# du -sh # 查看指定目录的大小
# grep MemTotal /proc/meminfo # 查看内存总量
# grep MemFree /proc/meminfo # 查看空闲内存量
# uptime # 查看系统运行时间、用户数、负载
# cat /proc/loadavg # 查看系统负载
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;磁盘和分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mount | column -t # 查看挂接的分区状态
# fdisk -l # 查看所有分区
# swapon -s # 查看所有交换分区
# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)
# dmesg | grep IDE # 查看启动时IDE设备检测状况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网络&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ifconfig # 查看所有网络接口的属性
# iptables -L # 查看防火墙设置
# route -n # 查看路由表
# netstat -lntp # 查看所有监听端口
# netstat -antp # 查看所有已经建立的连接
# netstat -s # 查看网络统计信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ps -ef # 查看所有进程
# top # 实时显示进程状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# w # 查看活动用户
# id &amp;lt;用户名&amp;gt; # 查看指定用户信息
# last # 查看用户登录日志
# cut -d: -f1 /etc/passwd # 查看系统所有用户
# cut -d: -f1 /etc/group # 查看系统所有组
# crontab -l # 查看当前用户的计划任务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# chkconfig –list # 列出所有系统服务
# chkconfig –list | grep on # 列出所有启动的系统服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# rpm -qa # 查看所有安装的软件包
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;linux文件目录内容：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/ 与开机系统有关，/usr与软件安装执行有关，/var与系统运作有关
/usr 软件放置处
/opt第三方软件
/etc配置文件
/boot开机与内核文件
/var/mail用户邮件
/var/run程序相关
/var/spool/news新闻
/var/lock程序相关
/bin可执行文件
/dev设备与接口
/home主文件夹
/lib函数库
/media可以删除的设备
/mnt暂时挂载的额外设备
/root管理员文件夹
/sbin管理员才能执行的命令，多数是用来设置系统环境
/srv是service缩写，网络服务启动后所需要取用的目录数据
/tmp一般用户正在执行的程序暂时放置，建议开机启动时候清空
/lost+found文件系统发生错误时，丢失的片段放置位置
/proc虚拟文件系统，不占空间，内容都在内存中，如内核、进程、外设、网络状态等信息
/sys虚拟文件系统，记录内核相关信息，包括已加载模块和硬件设备等
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;几个主要目录&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;根目录/：/etc,/bin,/dev,/lib,/slib必须放在根目录下。
/usr目录（UNIX software resource）：操作系统软件资源，类似于c:\windows和c:\program files的合体
/usr/D11R6：xwindow系统主要数据目录
/usr/bin：巨大部分用户可以使用命令都在这里，与/bin不同的是是否与开机过程相关
/usr/include：头文件和liclude文件放置处
/usr/local：系统管理员在本机安装自己下载软件，建议到此目录
/usr/sbin：非系统正常运行所需要的系统命令
/usr/share：共享文件
/usr/src：源码文件建议放置处
/var目录：针对变动性文件
/var/cache：进程缓存文件
/var/lock
/var/log：登录文件放置处
/var/mail：个人电子邮件
/var/run：程序或者进程pid放置处
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
				<link>/2014/11/09/command.html</link>
				<guid isPermaLink="true">/2014/11/09/command.html</guid>
			</item>
		
			<item>
				<title>服务器编程的几种常见模型</title>
        <description>&lt;p&gt;废话不说，进入主题，例子都用为代码描述。&lt;/p&gt;

&lt;h2&gt;同步阻塞式&lt;/h2&gt;

&lt;p&gt;这是最简单的一种IO模型，它就是一个一问一答的形式。多数的python网络编程socket一节都会有一个简单服务器例子，就是这个模型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;bind(serverfd);
listen(serverfd);
while(1):{
    clientfd = accept(serverfd, ...); //接收客户端传来的数据
    read(clientfd, buf, ...); //读取客户端数据
    do_logic(buf); //对数据进行操作，内部逻辑处理
    write(clientfd, buf); //返回客户端数据
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显的可以看到，上面有几个地方是需要等待的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;等待客户端请求，如果没有客户端发起请求的话，就会一直等着。&lt;/li&gt;
&lt;li&gt;读取客户端数据，建立请求后，就需要等着客户端送来数据(我们知道tcp连接是有几次握手的，所以不能直接来数据)，此时不能接受其他客户端的连接。&lt;/li&gt;
&lt;li&gt;同样，写回客户端的时候也需要等待。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;多进程&lt;/h2&gt;

&lt;p&gt;同步的方式几乎已经失传了，多进程稍稍改进了同步阻塞的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;bind(serverfd);
listen(serverfd);
while(1){
    clientfd = accept(serverfd, ...);
    ret = fork();
    switch(ret){
        case -1: //出错
            error();
            break;
        case 0: //子进程
            client(clientfd);
            break;
        default:
            close(clientfd);
            continue;
    }
}

void clien(clientfd){
    read(clientfd, buf, ...);
    do_logic(buf);
    write(clientfd, buf);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做的效果很明显，可以让每个进程处理一个请求，所以有多个请求来的时候就不会等待了。&lt;/p&gt;

&lt;p&gt;但是劣势也很明显，fork一个进程的资源耗费太大了，而且系统资源有限，所以能处理请求的个数也很有限。&lt;/p&gt;

&lt;h2&gt;多线程&lt;/h2&gt;

&lt;p&gt;这个就不用多说了，跟多进程的处理方式差不多，只是把进程换成了线程。这样虽然相对减少了资源消耗，但是如果一个线程跪了，其他的都得跪。&lt;/p&gt;

&lt;h2&gt;I/O多路复用之select&lt;/h2&gt;

&lt;p&gt;多进程/线程模型每个进程/线程都只能处理一路IO，这样过多的请求也会让服务器不堪重负。而通过IO复用，让一个进程可以处理多个请求，简单描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;bind(serverfd);
listen(serverfd);
FD_ZERO(&amp;amp;allset);
FD_SET(serverfd, &amp;amp;allset); //allset是一个数组，用于记录监听的连接
while(1){
    select(...);
    if(FD_ISSET(serverfd, &amp;amp;rset)){ //有新的连接来了
        clientfd = accept();
        clientarray[] = clientfd; //保存新连接的套接字
        FD_SET(clientfd, &amp;amp;allset); //将新连接的描述符加入到监听数组中
    }
    for(;;){//检查所有已经连接的客户端是否有数据参与读写
        fd = clientarray[i];
        if(FD_ISSET(fd, &amp;amp;rset)){
            do_logic();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中我们可以看到这种模型一样有缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单个进程能够监听的文件描述符有限，监听得越多性能越差（在大于一定的数量之后）&lt;/li&gt;
&lt;li&gt;内核/用户空间之间拷贝数据，产生大量开销&lt;/li&gt;
&lt;li&gt;内核返回的是含有整个句柄的数组，应用程序要遍历数组才能知道哪些句柄发生了事件。&lt;/li&gt;
&lt;li&gt;select是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符的IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;IO多路复用之epoll&lt;/h2&gt;

&lt;p&gt;因为select/epoll都是使用的水平触发，所以这里简单学习下水平触发(LT)和边缘触发(ET)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平触发：只要满足条件就发生一个IO事件&lt;/li&gt;
&lt;li&gt;边缘触发：每当状态变化时发生一个IO事&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;用人话简单解释的话大概是这个意思：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;水平触发：内核告诉你一个文件描述符就绪，然后你就可以对这个描述符进行IO操作。如果你不操作，那么内核就一直给你说这个文件描述符已经就绪了。默认是不能操作描述符的，只有通知了你你才能操作。&lt;/li&gt;
&lt;li&gt;边缘触发：当描述符从未就绪变成就绪的时候，内核就告诉你。然后内核就假设你已经知道这个描述符就绪，就算你没有对它进行任何操作，内核也再也不会给你说了。默认是可以操作描述符的，因为只会通知你一次，你可以随时去取。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;那epoll使用水平触发的有点在哪里呢：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为select也是使用的epoll，所以当某些系统epoll不可用的时候能优雅的降级到select&lt;/li&gt;
&lt;li&gt;水平触发对应用程序更简单（实现），也更适合http这种请求响应的模式（读完就写，不用管写的状态）。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这里有参考文章，里面介绍了epoll的实现机理。&lt;a href=&quot;http://www.cricode.com/3499.html&quot;&gt;高并发网络编程之epoll详解&lt;/a&gt;但是我觉得这些东西了解就行了，至于怎样才能让他更高效，这应该是内核开发人员的事情。&lt;/p&gt;

&lt;p&gt;所以简要介绍epoll，这里选取了来自知乎的答案&lt;a href=&quot;http://www.zhihu.com/question/20122137&quot;&gt; epoll 或者 kqueue 的原理是什么？&lt;/a&gt;，如下&lt;/p&gt;

&lt;p&gt;首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。
不管是文件，还是套接字，还是管道，我们都可以把他们看作流。
之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。&lt;/li&gt;
&lt;li&gt;非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。
大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。&lt;/p&gt;

&lt;p&gt;为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。
假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。&lt;/li&gt;
&lt;li&gt;但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。&lt;/li&gt;
&lt;li&gt;假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”&lt;/li&gt;
&lt;li&gt;也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。&lt;/p&gt;

&lt;p&gt;然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。
于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while true {
    for i in stream[]{
        if i has data
        read until unavailable;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。&lt;/p&gt;

&lt;p&gt;为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while true {
    select(streams[]);
    for i in streams[] {
        if i has data
        read until unavailable;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次
说了这么多，终于能好好解释epoll了
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数）
在讨论epoll的实现细节之前，先把epoll的相关操作列出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;epoll_create 创建一个epoll对象，一般epollfd = epoll_create()
epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件
比如
epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回
epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回
epoll_wait(epollfd,...)等待直到注册的事件发生
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。
一个epoll模式的代码大概的样子是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while true {
    active_stream[] = epoll_wait(epollfd);
    for i in active_stream[] {
        read or write till unavailable
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;python中使用epoll&lt;/h3&gt;

&lt;p&gt;这里只使用了水平触发的方式写做示例。如果使用边缘触发，那程序就需要在每次调用epoll.poll()之前处理完当前事件，这样就需要加入多个for循环，不过也不难理解。&lt;/p&gt;

&lt;p&gt;更多的示例请参见&lt;a href=&quot;http://scotdoyle.com/python-epoll-howto.html&quot;&gt;python-epoll-howto&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import socket, select  # select模块中已经集成了epoll

EOL1 = b&#39;\n\n&#39;
EOL2 = b&#39;\n\r\n&#39;
response  = b&#39;HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n&#39;
response += b&#39;Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n&#39;
response += b&#39;Hello, world!&#39;

serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
serversocket.bind((&#39;0.0.0.0&#39;, 8080))
serversocket.listen(1)
serversocket.setblocking(0)  # socket默认是阻塞的，我们需要手动设置成非阻塞

epoll = select.epoll()  # 建立一个epoll对象
epoll.register(serversocket.fileno(), select.EPOLLIN)  #注册服务器socket，监听读取事件，服务器socket收到一个连接时，产生一个读取事件

try:
    connections = {}; requests = {}; responses = {}  # connections存储网络连接的文件描述符(file descripors, 整型)
    while True:
        events = epoll.poll(1)  # epoll对象查询是否有感兴趣对象产生， 参数1表示最多等1秒。如果有事件发生，立即返回事件列表。
        for fileno, event in events:
            if fileno == serversocket.fileno():  # 如果是服务器socket事件，就新建一个连接
                connection, address = serversocket.accept()
                connection.setblocking(0)  # 设置成非阻塞模式
                epoll.register(connection.fileno(), select.EPOLLIN)  # 注册socket的read事件，等待从客户端读
                connections[connection.fileno()] = connection
                requests[connection.fileno()] = b&#39;&#39;
                responses[connection.fileno()] = response
            elif event &amp;amp; select.EPOLLIN:  # 如果read事件发生，就从客户端读取事件
                requests[fileno] += connections[fileno].recv(1024)
                if EOL1 in requests[fileno] or EOL2 in requests[fileno]:  # 分片读取，如果http请求结束，取消注册读取，并注册写回
                    epoll.modify(fileno, select.EPOLLOUT)
                    print(&#39;-&#39;*40 + &#39;\n&#39; + requests[fileno].decode()[:-2])
            elif event &amp;amp; select.EPOLLOUT:  # 如果是写回，发送数据给客户端
                byteswritten = connections[fileno].send(responses[fileno])
                responses[fileno] = responses[fileno][byteswritten:]
                if len(responses[fileno]) == 0:  # 每次发送一部分数据，直到结束。取消注册的写回事件，
                    epoll.modify(fileno, 0)
                    connections[fileno].shutdown(socket.SHUT_RDWR)  # 关闭连接（可选）
            elif event &amp;amp; select.EPOLLHUP:  # 客户端断开连接
                epoll.unregister(fileno)
                connections[fileno].close()
                del connections[fileno]
finally:  # 可选，因为socket会主动关闭连接
    epoll.unregister(serversocket.fileno())
    epoll.close()
    serversocket.close()
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Mon, 20 Oct 2014 00:00:00 +0800</pubDate>
				<link>/2014/10/20/server-program-model.html</link>
				<guid isPermaLink="true">/2014/10/20/server-program-model.html</guid>
			</item>
		
			<item>
				<title>Python Tornado学习</title>
        <description>&lt;p&gt;这篇文章是对tornado官方入门文档的简单翻译，语句不通顺，但是至少还是可以读的。&lt;/p&gt;

&lt;p&gt;不知道为什么pages始终不支持tornado的html模板样式，于是我也就只能放个链接了&lt;a href=&quot;https://github.com/dantangfan/dantangfan.github.com/blob/master/_posts/blog/study-tornado.md&quot;&gt;tornado简介&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 08 Oct 2014 00:00:00 +0800</pubDate>
				<link>/2014/10/08/study-tornado.html</link>
				<guid isPermaLink="true">/2014/10/08/study-tornado.html</guid>
			</item>
		
			<item>
				<title>学习记录</title>
        <description>&lt;p&gt;找工作的时候和平时复习的时候遇到的一些个问题，幸好都简单记录下来了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/4cefea0f-5c4c-4f54-8c32-c848bdf79fa2/f5d310e23af425a1ab2af19c07b26edf&quot;&gt;简单算法篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65313&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/4d78c743-340e-489e-9c7d-a799834bd08d/f9f548dd3410e6ec45896f0edeafa5ff&quot;&gt;C++语言基础篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65314&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/87d176ad-3fcb-4f82-a6d1-daf7072532d9/67be614287ee2321fcaefb00d4a2af65&quot;&gt;乱七八糟问题篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65316&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 03 Oct 2014 00:00:00 +0800</pubDate>
				<link>/2014/10/03/findwork.html</link>
				<guid isPermaLink="true">/2014/10/03/findwork.html</guid>
			</item>
		
			<item>
				<title>python2.7.x和python3.x的简单区别</title>
        <description>&lt;p&gt;许多python初学者都在为难到底是选择python2还是python3，我刚刚学python的时候也有这个疑问。大佬们各有个的说法，但学完基础之后，我觉得你选一个适合自己的就是最好的了，看哪个爽就学哪个。开源东西没有专门维护和标准，果然还是够但疼。&lt;/p&gt;

&lt;p&gt;我觉得也没有什么好坏之分，简单了解了之后，你会发现他们支持的库已经基本差不太多了。这里就简单的说说两个版本的一些区别，以免后面东西学咋了就什么都忘了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;future&lt;/strong&gt;模块&lt;/h2&gt;

&lt;p&gt;这应该是python中最有用的模块之一了，虽然python3中有一些python2不支持的关键字和特性，但他们都可以在python2的&lt;code&gt;__future__&lt;/code&gt;中找到。所以如果你打算在你的python2中体验python3语言的特性，就可以简单通过导入&lt;strong&gt;future&lt;/strong&gt;模块。比如说我们想在python2中使用python3的整除算法，可以这样做&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from __future__ import division
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;strong&gt;future&lt;/strong&gt;并不是专门为从python2跨越到python3准备的，它只是提供了向后兼容，也就是说python2.1中的&lt;strong&gt;future&lt;/strong&gt;可以导入python2.2的特性，以此类推。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/library/__future__.html#module-__future__&quot;&gt;更多的&lt;strong&gt;future&lt;/strong&gt;特性可以从官方文档中看到&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;print函数&lt;/h2&gt;

&lt;p&gt;print在python2中还只是一个表达式，但在python3中已经成了一个函数调用了，所以括号必不可少。&lt;/p&gt;

&lt;p&gt;python2里面这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &#39;Python&#39;, python_version()
print &#39;Hello, World!&#39;
print(&#39;Hello, World!&#39;)
print(&#39;Hello&#39;,&#39;World!&#39;)
print &quot;text&quot;, ; print &#39;print more text on the same line&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会给出这样的答案&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python 2.7.6
Hello, World!
Hello, World!
(&#39;Hello&#39;,&#39;World!&#39;)
text print more text on the same line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python3中这样写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&#39;Python&#39;, python_version())
print(&#39;Hello, World!&#39;)

print(&quot;some text,&quot;, end=&quot;&quot;) 
print(&#39; print more text on the same line&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会给出这样的答案&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python 3.4.1
Hello, World!
some text, print more text on the same line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果你不争气的在python3中写出了这样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &#39;Hello, World!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那你就只能得到这样的答案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  File &quot;&amp;lt;ipython-input-3-139a7c5835bd&amp;gt;&quot;, line 1
    print &#39;Hello, World!&#39;
                        ^
SyntaxError: invalid syntax
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;整除方法&lt;/h2&gt;

&lt;p&gt;这个改变有点变态，因为如果当你把python2的代码移植到python3上的时候，虽然写法一样，但是操作结果却不一样。&lt;/p&gt;

&lt;p&gt;比如在python2中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &#39;Python&#39;, python_version()
print &#39;3 / 2 =&#39;, 3 / 2
print &#39;3 // 2 =&#39;, 3 // 2
print &#39;3 / 2.0 =&#39;, 3 / 2.0
print &#39;3 // 2.0 =&#39;, 3 // 2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python 2.7.6
3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在python3中同样的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&#39;Python&#39;, python_version())
print(&#39;3 / 2 =&#39;, 3 / 2)
print(&#39;3 // 2 =&#39;, 3 // 2)
print(&#39;3 / 2.0 =&#39;, 3 / 2.0)
print(&#39;3 // 2.0 =&#39;, 3 // 2.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出却是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Python 3.4.1
3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这个坑等着你跳，而且相信有很多人会跳&lt;/p&gt;

&lt;h2&gt;字符串&lt;/h2&gt;

&lt;p&gt;python2使用的是ASCII编码来表示字符串，与unicode()不同，而且没有byte类型。
python3默认是使用Unicode(UTF-8)来表示字符串，并且有byte和bytearrays两种类型(类)。&lt;/p&gt;

&lt;p&gt;python2的如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print type(unicode(&#39;this is like a python3 str type&#39;))
print type(b&#39;byte type does not exist&#39;)
print &#39;they are really&#39; + b&#39; the same&#39;
print type(bytearray(b&#39;bytearray oddly does exist though&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将得到如下输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;type &#39;unicode&#39;&amp;gt;
&amp;lt;type &#39;str&#39;&amp;gt;
they are really the same
&amp;lt;type &#39;bytearray&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&#39;strings are now utf-8 \u03BCnico\u0394é!&#39;)
print(&#39; has&#39;, type(b&#39; bytes for storing data&#39;))
print(&#39;and Python&#39;, python_version(), end=&quot;&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将得到下面输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strings are now utf-8 μnicoΔé!
has &amp;lt;class &#39;bytes&#39;&amp;gt;
also has &amp;lt;class &#39;bytearray&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;异常处理&lt;/h2&gt;

&lt;p&gt;这里只是写法不一样，python2允许使用两种错误抛出的写法，python3中值允许一种，如下：&lt;/p&gt;

&lt;p&gt;在python2中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;raise IOError, &quot;file error&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;raise IOError(&quot;file error&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都可以可以得到输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
&amp;lt;ipython-input-8-25f049caebb0&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 raise IOError, &quot;file error&quot;

IOError: file error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在python3中只有&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;raise IOError(&quot;file error&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;才能得到正确的输出&lt;/p&gt;

&lt;h2&gt;except&lt;/h2&gt;

&lt;p&gt;python2中的except表达式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;try:
    let_us_cause_a_NameError
except NameError, err:
    print err, &#39;--&amp;gt; our error message&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在python3中必须使用as关键字，有些不习惯。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, &#39;--&amp;gt; our error message&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们都能输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name &#39;let_us_cause_a_NameError&#39; is not defined --&amp;gt; our error message
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;for循环&lt;/h2&gt;

&lt;p&gt;这是一个很棒的改进，for-loop中的变量不再会泄漏到全局命名空间了！&lt;/p&gt;

&lt;p&gt;比如在python2中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;i = 1
print &#39;before: i =&#39;, i
print &#39;comprehension: &#39;, [i for i in range(5)]
print &#39;after: i =&#39;, i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到这样的输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在python3中，就正常了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;i = 1
print(&#39;before: i =&#39;, i)
print(&#39;comprehension:&#39;, [i for i in range(5)])
print(&#39;after: i =&#39;, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;比较大小&lt;/h2&gt;

&lt;p&gt;还有一个重要的改变是比较功能，不同类型比较的时候python3会抛出错误了。&lt;/p&gt;

&lt;p&gt;python2代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &quot;[1, 2] &amp;gt; &#39;foo&#39; = &quot;, [1, 2] &amp;gt; &#39;foo&#39;
print &quot;(1, 2) &amp;gt; &#39;foo&#39; = &quot;, (1, 2) &amp;gt; &#39;foo&#39;
print &quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的比较能得到结果，是c/c艹程序员想都不敢想的。但python2就能得到结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2] &amp;gt; &#39;foo&#39; =  False
(1, 2) &amp;gt; &#39;foo&#39; =  True
[1, 2] &amp;gt; (1, 2) =  False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在跑一趟好哦你3中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&quot;[1, 2] &amp;gt; &#39;foo&#39; = &quot;, [1, 2] &amp;gt; &#39;foo&#39;)
print(&quot;(1, 2) &amp;gt; &#39;foo&#39; = &quot;, (1, 2) &amp;gt; &#39;foo&#39;)
print(&quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会抛出异常&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-16-a9031729f4a0&amp;gt; in &amp;lt;module&amp;gt;()
      1 print(&#39;Python&#39;, python_version())
----&amp;gt; 2 print(&quot;[1, 2] &amp;gt; &#39;foo&#39; = &quot;, [1, 2] &amp;gt; &#39;foo&#39;)
      3 print(&quot;(1, 2) &amp;gt; &#39;foo&#39; = &quot;, (1, 2) &amp;gt; &#39;foo&#39;)
      4 print(&quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2))

TypeError: unorderable types: list() &amp;gt; str()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;input&lt;/h2&gt;

&lt;p&gt;python3的input函数也有所改变，它把把接收的数据都当成&lt;code&gt;str&lt;/code&gt;处理。而在python中，我们还需要raw_input()来解决这个问题&lt;/p&gt;

&lt;p&gt;python2代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; my_input = input(&#39;enter a number: &#39;)
enter a number: 123
&amp;gt;&amp;gt;&amp;gt; type(my_input)
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; my_input = raw_input(&#39;enter a number: &#39;)
enter a number: 123
&amp;gt;&amp;gt;&amp;gt; type(my_input)
&amp;lt;type &#39;str&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;python3代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; my_input = input(&#39;enter a number: &#39;)
enter a number: 123
&amp;gt;&amp;gt; type(my_input) &amp;lt;class &#39;str&#39;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xrange()&lt;/h2&gt;

&lt;p&gt;在python2总我们广泛的使用&lt;code&gt;xrange()&lt;/code&gt;来做迭代，通常情况下&lt;code&gt;xrange()&lt;/code&gt;会比&lt;code&gt;range()&lt;/code&gt;快一点，但是python3中取消了&lt;code&gt;xrange()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;比如函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import timeit

n = 10000
def test_range(n):
    return for i in range(n):
        pass

def test_xrange(n):
    for i in xrange(n):
        pass    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在python2中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &#39;\ntiming range()&#39;
%timeit test_range(n)

print &#39;\n\ntiming xrange()&#39;
%timeit test_xrange(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timing range()
1000 loops, best of 3: 433 µs per loop
timing xrange()
1000 loops, best of 3: 350 µs per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在python3中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&#39;\ntiming range()&#39;)
%timeit test_range(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timing range()
1000 loops, best of 3: 520 µs per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不断继续补充中。。。。。&lt;/h4&gt;
</description>
				<pubDate>Thu, 11 Sep 2014 00:00:00 +0800</pubDate>
				<link>/2014/09/11/diff-py2-py3.html</link>
				<guid isPermaLink="true">/2014/09/11/diff-py2-py3.html</guid>
			</item>
		
			<item>
				<title>LinOTP简单使用教程</title>
        <description>&lt;p&gt;LinOTP是Google官方开源的one time password企业管理应用，但在国内使用的企业貌似不多。实习的时候老师要求配置一个系统，但国内很少有人给出了实际使用方法，而且官方的document写得真的是不忍吐槽。于是就自己写一个简单教程，也算是对官方教程的一个简单翻译和整合。&lt;/p&gt;

&lt;p&gt;看完这个教程，你将能搭建最基础的应用。但是如果你想把它作为你的企业应用，最好还是自己摸索一番，或者直接联系开发者和邮件列表。&lt;/p&gt;

&lt;h2&gt;一、从安装说起&lt;/h2&gt;

&lt;p&gt;ubuntu和debian有标准的一键安装，加入软件源后直接可用，red hat和centos等其他发行版需要使用pypi安装，并且手动安装所有依赖。
这里以centos6.5为例子，说明简要的安装过程：&lt;/p&gt;

&lt;p&gt;首先安装virtualenv用于建立一个隔离的python环境，由于virtualenv的存在，我们可以在任何一个发行版中用pypi安装和使用linotp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;yum install python-virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单独建立一个文件夹来构造linotp独立的python环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mkdir -p /opt/LINOTP
virtualenv –-no-site-packages /opt/LINOTP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入LINOTP文件夹，开始并切换工作目录到当前虚拟环境，&lt;strong&gt;每次需要启动或者使用LINOTP文件夹内的app时都需要使用下面命令&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;cd /opt/LINOTP
source bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面命令退出虚拟环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要在虚拟环境中安装所需的依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install python-devel swig gcc openssl-devel openldap-devel mysql-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以直接使用pip安装linotp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install linotp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装使用各种token所需要的依赖（可能并不是所有包到都能安装）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install pil
pip install m2crypto
pip install psycopg2
pip install MySQL-python
pip install SMSProvider
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;注意：为了方便，我们应该把配置文件都放在/etc文件夹下，而不是直接放在/opt/LINTOP/etc/linotp2下面，所以直接拷贝配置文件到/etc目录下&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;cp -rf /opt/LINOTP/etc/linotp2 /etc/linotp2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;警告：pip不会自动的更新所安装的软件，所以我们安装的依赖并不是最新的，也最好不要手动编译安装，LinOTP提供了更新命令&lt;code&gt;linotp-pip-update&lt;/code&gt;，但是一定不要使用（至少在centos6.5下不要使用），因为高版本的库并不支持linotp。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;二、建立你的数据库&lt;/h2&gt;

&lt;p&gt;如果使用的是mysql，可以直接使用下面命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql -u root -p mysql
create database L2demo;
grant all privileges on L2demo.* to &#39;linotp&#39;@&#39;localhost&#39; identified by &#39;mySecret&#39;;
flush privileges;
quit;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;注意：linotp里面有个默认配置叫&lt;code&gt;/etc/linotp2/linotp.ini.example&lt;/code&gt;，为使用此配置，我们需要重命名该文件为&lt;code&gt;/etc/linotp2/linotp.ini&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;在linotp.ini中找到&lt;code&gt;sqlalchemy.url&lt;/code&gt;，并修改为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sqlalchemy.url = mysql://linotp:mySecret@localhost/L2demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要创建一个加密密钥&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dd if=/dev/urandom of=/etc/linotp2/encKey bs=1 count=96
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建log文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /var/log/linotp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以正式创建数据库表单了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paster setup-app /etc/linotp2/linotp.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、在apache上把样例跑起来&lt;/h2&gt;

&lt;p&gt;我们需要借用apache使用webUI的管理页面，首先使用下面命令创建一个文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;htdigest /etc/linotp2/admins “LinOTP2 admin area” admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们需要安装并激活以下模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install mod_wsgi
yum install mod_ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;注意：在使用过程中端口会遭到iptables的拦截，这时候我们可以简单的关闭iptables&lt;code&gt;/etc/init.d/iptables stop&lt;/code&gt;或者开放指定端口,在/etc/sysconfig/iptables文件中添加如下命令(或许还需要更多端口)&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;-A INPUT -p tcp -m tcp --sport 443 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -p tcp -m tcp --sport 3389 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 3389 -j ACCEPT
-A INPUT -p tcp -m tcp --sport 5001 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 5001 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要建立一个wsgi的文件夹，不然WSGI模块不能正常启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /var/run/wsgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以进一步配置apache-server了。
首先创建一个认证文件&lt;code&gt;touch /etc/[httpd|apache2]/linotp-auth.conf&lt;/code&gt;(centos是httpd文件夹下)
在此文件中添加以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AuthType Digest
AuthName “LinOTP2 admin area”
AuthDigestProvider file
AuthUserFile /etc/linotp2/admins
Require valid-user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论LinOTP的配置文件放在哪里，都需要包含以下内容。这里我直接添加到&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;文件的最后（针对不同的系统，可能要对文件中文件的路径进行修改）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Listen 443
WSGIPythonHome /opt/LINOTP
WSGISocketPrefix /var/run/wsgi
&amp;lt;VirtualHost _default_:443&amp;gt;
   ServerAdmin webmaster@localhost
   DocumentRoot /var/www
   &amp;lt;Directory /&amp;gt;
      Options FollowSymLinks
      AllowOverride None
   &amp;lt;/Directory&amp;gt;
   &amp;lt;Directory /var/www/&amp;gt;
      Options Indexes FollowSymLinks MultiViews
      AllowOverride None
      Order allow,deny
      allow from all
   &amp;lt;/Directory&amp;gt;

   Alias /doc/html         /usr/share/doc/linotpdoc/html
   WSGIScriptAlias /       /etc/linotp2/linotpapp.wsgi
   #
   # The daemon is running as user &#39;linotp&#39;
   # This user should have access to the encKey database encryption file
   WSGIDaemonProcess linotp processes=1 threads=15 display-name=%{GROUP} user=linotp
   WSGIProcessGroup linotp
   WSGIPassAuthorization On

   &amp;lt;Location /admin&amp;gt;
      Include /etc/httpd/linotp-auth.conf
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /audit&amp;gt;
      Include /etc/httpd/linotp-auth.conf
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /gettoken&amp;gt;
      AuthType Digest
      AuthName &quot;LinOTP2 gettoken&quot;
      AuthDigestProvider file
      AuthUserFile /etc/linotp2/gettoken-api
      Require valid-user
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /manage&amp;gt;
             Include /etc/httpd/linotp-auth.conf
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /selfservice&amp;gt;
      # The authentication for selfservice is done from within the application
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /system&amp;gt;
     Include /etc/httpd/linotp-auth.conf
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /license&amp;gt;
     Include /etc/httpd/linotp-auth.conf
   &amp;lt;/Location&amp;gt;
   &amp;lt;Location /validate&amp;gt;
      # No Authentication
   &amp;lt;/Location&amp;gt;

   ErrorLog /var/log/httpd/error.log
   LogLevel warn

   # Do not use %q! This will reveal all parameters, including setting PINs and Keys!
   # Using SSL_CLIENT_S_DN_CN will show you, which administrator did what task
   LogFormat &quot;%h %l %u %t %&amp;gt;s \&quot;%m %U %H\&quot;  %b \&quot;%{Referer}i\&quot; \&quot;%{User-agent}i\&quot; &quot; LinOTP2
   CustomLog /var/log/httpd/ssl_access.log LinOTP2

   #   SSL Engine Switch:
   #   Enable/Disable SSL for this virtual host.
   SSLEngine on

   #   If both key and certificate are stored in the same file, only the
   #   SSLCertificateFile directive is needed.
   SSLCertificateFile    /etc/ssl/certs/linotpserver.pem
   SSLCertificateKeyFile /etc/ssl/private/linotpserver.key
   &amp;lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&amp;gt;
      SSLOptions +StdEnvVars
   &amp;lt;/FilesMatch&amp;gt;
   &amp;lt;Directory /usr/lib/cgi-bin&amp;gt;
      SSLOptions +StdEnvVars
   &amp;lt;/Directory&amp;gt;
   BrowserMatch &quot;.*MSIE.*&quot; \
     nokeepalive ssl-unclean-shutdown \
     downgrade-1.0 force-response-1.0

   ErrorDocument 500 &quot;&amp;lt;h1&amp;gt;Internal Server Error&amp;lt;/h1&amp;gt; Possible reasons can be missing modules or bad access rights \
                     on LinOTP configuration files or log files. Please check the apache logfile \
                     &amp;lt;pre&amp;gt;/var/log/httpd/error_log&amp;lt;/pre&amp;gt; for more details.&quot;

&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;注意：centos的mod_ssl在&lt;code&gt;/etc/httpd/conf.d/&lt;/code&gt;中自带了一个&lt;code&gt;ssl.conf&lt;/code&gt;的配置文件，里面已经定义了&lt;code&gt;VirtualHost&lt;/code&gt;,所以这里需要相应的调整不然端口会发生冲突。（为方便可以直接重命名为&lt;code&gt;ssl.conf.old&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;注意：如果发现&lt;code&gt;linotpserver.pem&lt;/code&gt;等密钥不存在，那我么需要手动生成一些&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;WSGI的进程默认使用名字叫&lt;code&gt;linotp&lt;/code&gt;的用户，所以我们需要新建一个用户来使用它&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adduser -r linotp -d /opt/LINOTP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以把&lt;code&gt;/opt/LINOTP/etc/linotp2/linotpapp.wsgi&lt;/code&gt;文件复制到&lt;code&gt;/etc/linotp2&lt;/code&gt;文件夹中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /opt/LINOTP/etc/linotp2/linotpapp.wsgi /etc/linotp2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后查看我们建立的文件的权限，只有在适合的权限下才能正常使用linotp-server。我们希望看到的权限如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/linotp2/linotp.ini - linotp should have read access&lt;/li&gt;
&lt;li&gt;/etc/linotp2/encKey - linotp should have read access&lt;/li&gt;
&lt;li&gt;/etc/linotp2/data/ - This is a template directory, linotp should have write access&lt;/li&gt;
&lt;li&gt;/var/log/linotp/ - linotp should have write access&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;注意：如果权限不当，可以使用&lt;code&gt;linotp-fix-access-rights -f /etc/linotp2/linotp.ini -u linotp&lt;/code&gt;来修复权限&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;重启apache和mysql&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apachectl restart#输入你设定的密码
service mysqld restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以从命令行启动服务器了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paster serve /etc/linotp2/linotp.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linotp会监听你在linotp.ini中定义的端口，接下来在浏览器中访问&lt;code&gt;http://&amp;lt;yourserverIP&amp;gt;:5001/manage&lt;/code&gt;就可以进入manage的页面。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;警告！！！：这里的管理页面是不需要用户名和密码就能登录的，只供测试使用。密码需要自行在apache中配置&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;四、admin管理界面&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage1.png&quot; alt=&quot;manage1.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1.创建用户&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;LinOTP config-&amp;gt;useridresover&lt;/code&gt;创建一个useridresover。这里有三种创建方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuring LDAP UserIdResolver&lt;/li&gt;
&lt;li&gt;Configuring SQL UserIdResolver&lt;/li&gt;
&lt;li&gt;Configuring Passwd (Flatfile) UserIdResolver&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然最间但的是flatfile方式创建，这中格式的用户文件和*nix中的/etc/passwd文件格式一样，因此我们可以直接导入文件&lt;code&gt;/etc/passwd&lt;/code&gt;，导入后刷新就可以看到成功导入的用户。但是这样做有一个问题，&lt;code&gt;/etc/passwd&lt;/code&gt;文件中的并没有保存用户密码/加密后的信息，就让我们的用户实际无法登录，因此更好更简洁的办法是把是使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;linotp-create-pwidresolver-user -u [username] -i [userid] -p [password] -d [description]&amp;gt;&amp;gt; passwd-file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建测试用户,可以用此方法创建多个，然后导入的时候直接导入&lt;code&gt;passwd-file&lt;/code&gt;文件&lt;/p&gt;

&lt;h3&gt;2.创建用户组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;LinOTP config-&amp;gt;realms&lt;/code&gt;按提示创建就行，并且指定一个默认的用户组&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage2.png&quot; alt=&quot;manage2.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;3.创建token&lt;/h3&gt;

&lt;p&gt;token可以从文件中导入，可以从官方文档中查看支持的token和导入方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/supported-tokens.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/supported-tokens.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/managingtokens/index.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/managingtokens/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;更简单的方法是手动创建token，点击左边侧烂&lt;code&gt;enroll&lt;/code&gt;可以看到创建token选项，这里我选择&lt;code&gt;HMAC eventbased&lt;/code&gt;，并勾选&lt;code&gt;Generate HMAC key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage3.png&quot; alt=&quot;manage3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击&lt;code&gt;enroll&lt;/code&gt;看到了生成的二维码，点击&lt;code&gt;OK&lt;/code&gt;就可以在主页上&lt;code&gt;Token view&lt;/code&gt;看到生成的token&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage4.png&quot; alt=&quot;manage4.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4.把user注册到token上面&lt;/h3&gt;

&lt;p&gt;方法很简单，在&lt;code&gt;Token view&lt;/code&gt;单击想要的token，切换到&lt;code&gt;User view&lt;/code&gt;下面单击相应的user，就可以在页面的左上角看到相应的信息类似如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage5.png&quot; alt=&quot;manage5.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;5.policy&lt;/h3&gt;

&lt;p&gt;这是最重要的一部分，关系到了用户的权限问题。policy有很多种类型，具体可以参见官方文档&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/policy/index.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/policy/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里，我以selfpolicy为例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/policy.png&quot; alt=&quot;policy.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;action是最重要的一部分，它直接指明了user的权限。不同的user类型有不同的权限，官方文档给出了一个推荐的最佳配置&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/policy/best-practice.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/policy/best-practice.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;policy配置好之后，就可以从浏览器登录用户了。&lt;/p&gt;

&lt;p&gt;浏览器输入&lt;code&gt;http://[yourIP]:5001/account/login&lt;/code&gt;根据用户名和密码就可以登录&lt;/p&gt;

&lt;h3&gt;6.system config&lt;/h3&gt;

&lt;p&gt;从manage页面我们还可以设置&lt;code&gt;LinOTP config-&amp;gt;system config&lt;/code&gt;，不过配置对简单的实验影响不大，官方文档有也把配置方式写得很清楚&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/system-config.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/system-config.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;五、Selfservice Protal管理界面&lt;/h2&gt;

&lt;p&gt;登录后我们可以看到如下界面，根据对&lt;code&gt;policy-&amp;gt;action&lt;/code&gt;的设置，界面可能有所不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/portal1.png&quot; alt=&quot;portal1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方文档写得很简要&lt;a href=&quot;http://www.linotp.org/doc/latest/part-user/workflow.html&quot;&gt;http://www.linotp.org/doc/latest/part-user/workflow.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里，我通过一个小例子说明。&lt;/p&gt;

&lt;p&gt;比如我们选择&lt;code&gt;Enroll Google Authenticator&lt;/code&gt;，然后点击&lt;code&gt;Enroll Google Authenticator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/portal2.png&quot; alt=&quot;portal2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到页面左上生成了一个token（这个时候退回去看manage页面，发现也生成了一个token）。然后在你的iphone/Android上安装 google authenticator ，并扫描这个时候生成的二维码。再次使用该应用时候，就可以看到手机上出现了六位数字。这个数字就是你登录自己应用的时候所需要的密码。&lt;/p&gt;

&lt;p&gt;我们可以登录&lt;code&gt;http://[yourIP]:5001/auth/index&lt;/code&gt;来测试应用是否成功。&lt;/p&gt;
</description>
				<pubDate>Thu, 07 Aug 2014 00:00:00 +0800</pubDate>
				<link>/2014/08/07/linotp.html</link>
				<guid isPermaLink="true">/2014/08/07/linotp.html</guid>
			</item>
		
			<item>
				<title>进程同步的若干问题</title>
        <description>&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;首先我们来看一个&lt;code&gt;生产者-消费者&lt;/code&gt;的问题，在实际应用中我们使用&lt;code&gt;有限缓冲&lt;/code&gt;方案。生产者消费者进程共享代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define BUFFER_SIZE 10
typedef struct{
...
} item;
item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共享缓冲区是通过循环数组和两个逻辑指针来实现的：in和out。变量in指向缓冲区的下一个空位；out指向缓冲区的第一个非空位。当in==out的时候缓冲区空，当(in+1)%BUFFER_SIZE==out的时候，缓冲器满。&lt;/p&gt;

&lt;p&gt;用counter记录缓冲区中的项，生产者进程有一个局部变量nextProducted存储锁新产生的项目，那么生产者的代码可以简单如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while(1){
    while(counter==BUFFER_SIZE)
        ;
    buffer[in] = nextProducted;
    in = (in+1)%BUFFER_SIZE;
    counter++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消费者有一个局部变量nextConsumed存储要使用的项,消费者的代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while(1){
    while(counter==0)
        ;
    nextConsumed=buffer[out];
    out = (out+1)%BUFFER_SIZE;
    counter--;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生产者消费者各自的程序都正确，但是当并发执行的时候他们可能并不能正确的执行。原因是他们同时执行的过程中代码交叉是乱序的，两个程序可能对counter同时进行操作，导致判断结果不准确。这样的情况，即多个进程并发访问和操作同一数据并且执行结果与访问发生的特定顺序有关，称为竞争条件。为了防止竞争条件，需要确保一段之间里面只有一个进程能操作共享数据（counter），于是就需要进程同步。&lt;/p&gt;

&lt;h3&gt;临界区&lt;/h3&gt;

&lt;p&gt;每个进程有一个代码段称为&lt;code&gt;临界区&lt;/code&gt;，该区中的进程可能修改共享变量、更新一个表、写一个文件等。这种系统的重要特征是当一个进程在临界区内执行时，没有其他进程被允许在临界区内执行。因此，临界区在时间上是互斥的。临界区的问题是设计一个进程能用来协作的协议，每个进程必须请求其进入临界区。实现这一请求的代码称为&lt;code&gt;进入区&lt;/code&gt;，临界区之后有&lt;code&gt;退出区&lt;/code&gt;，其他代码叫&lt;code&gt;剩余区&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关于临界区的问题的解答必须满足下面三项要求&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;互斥：一个进程在临界区内执行，其他进程都不能在其临界区内&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有空让进：如果没有进程在临界区且有进程希望进入临界区，那么只有哪些在剩余区内执行的进程能参加决策，选取谁能进入临界区，并且这种选取不能无限延迟&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有限等待：在一个进程作出进入其临界区的请求到被允许的其间，其他进程进入临界区的次数有一个上限&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;信号量&lt;/h2&gt;

&lt;p&gt;为了解决临界区问题，通常做法是使用称为&lt;code&gt;信号量&lt;/code&gt;的同步工具。信号量S是一个整数变量，除了初始化之外，只能通过两个标准的&lt;code&gt;原子操作&lt;/code&gt;wait和signal来访问。wait的经典定义可以用位代码表示为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;wait(S){
    while(S&amp;lt;=0)
        ;
       S--;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;signal的经典定义可以用伪代码表示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;signal(S){
    S++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在wait和signal操作中，对信号量整数值的修改必须不可分的执行，当一个进程修改信号量时，不能有其他进程同时修改同一信号量。而且对于wait操作，对s数值的测试（S&amp;lt;=0）和对其可能的修改(S++)也必须没有中断的执行。&lt;/p&gt;

&lt;h3&gt;用法&lt;/h3&gt;

&lt;p&gt;可以用信号量来解决n个进程临界区问题。n个进程共享一个信号量mutex并初始化为1,每个进程的组织结构就如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;do{
    wait(mutex);
    临界区;
    signal(mutex);
    剩余区；
}while(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用信号量来解决各种同步问题。比如两个正在并发执行的进程P1,P2，P1有语句S1,P2有语句S2,假设只有S1执行完之后才能有S2。那么我们可以让两个进程共享一个信号量synch,并且初始化为0,在P1中插入语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S1;
signal(synch);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在P2中插入语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait(synch);
S2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;简单的信号量主要的缺点就是&lt;code&gt;忙等待&lt;/code&gt;：当一个进程位于其临界区时，任何其他试图进入其临界区的进程都必须在其进入代码中连续的循环。为了克服忙等待，可以修改wait和signal的定义，当一个进程执行wait时，发现信号量不为正则它必须等待。然而，该进程不是忙等待而是&lt;code&gt;阻塞&lt;/code&gt;自己。阻塞操作讲一个进程放入到放入到与信号量相关的等待队列中，且该进程状态被切换成等待状态。接着，控制被转到CPU&lt;code&gt;调度程序&lt;/code&gt;，以选择一个进程执行。&lt;/p&gt;

&lt;p&gt;一个进程阻塞且等待信号量S，可以在其他进程执行signal后重新被执行。该进程的重新执行通过一个wakeup操作来进行，该操作讲进程从等待状态切换到就绪状态，接着放入就绪队列中。我们可以将信号量定义成一个结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef struct{
    int value;
    struct process *L;
}semaphore;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个信号都有一个整数值和一个进程表，当一个进程必须等待信号量shah，就加入到进程链表上。操作signal会从等待进程链表中取出一个进程唤醒。&lt;/p&gt;

&lt;p&gt;信号量wait操作可以如下定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void wait(semaphore S){
    S.value--;
    if(S.value&amp;lt;0){
        add this process to S.L;
        block();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;信号量signal操作如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void signal(semaphore S){
    S.value++;
    if(S.value&amp;lt;=0){
        remove a process P from S.L;
        wakeup(P);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作block挂起调用它的进程。操作wakeup重新启动阻塞的进程，他们都是操作系统提供的系统调用。&lt;/p&gt;

&lt;p&gt;信号量的关键之处是他们原子执行。必须确保没有两个进程能同时对一个信号量进程wait和signal操作。其实现在定义的信号量也没有取消忙等待，只是取消了应用程序进入临界区的忙等待。而且把忙等待限制在了wait和signal操作的临界区内。&lt;/p&gt;

&lt;h3&gt;死锁&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;死锁&lt;/code&gt;：两个或多个进程无限的等待一个事件，而该事件只能又这些等待进程之一来产生。&lt;/p&gt;

&lt;h2&gt;经典同步问题&lt;/h2&gt;

&lt;h3&gt;哲学家就餐&lt;/h3&gt;

&lt;p&gt;哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。&lt;/p&gt;
</description>
				<pubDate>Tue, 20 May 2014 00:00:00 +0800</pubDate>
				<link>/2014/05/20/process-signal.html</link>
				<guid isPermaLink="true">/2014/05/20/process-signal.html</guid>
			</item>
		
			<item>
				<title>备忘录</title>
        <description>&lt;h2&gt;把/home目录搬家&lt;/h2&gt;

&lt;p&gt;还是小菜鸟的时候，到处都建议把所有分区直接挂载在/目录，但是变成老菜鸟之后发现这样是不行的，最好还是单独分区出来，要不然/目录迟早会不够用的。有个逗逼的办法是扩展/目录，但是这样风险太大，于是就想到了不要那么逗逼的办法，把/home目录转义到新的分区。&lt;/p&gt;

&lt;p&gt;首先建立一个新的分区并格式化之，比如是sda4。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mkfs.ext4 /dev/sda4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂载分区用于拷贝当前home下的文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /mnt/newhome
mount -t ext4 /dev/sda4 /mnt/newhome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把home目录下的文件全部拷贝过来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /home
find . -depth -print0 | cpio --null --sparse -pvd /mnt/newhome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改新分区名字&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;umount /mnt/newhome
mv /home /old_home
mkdir /home
mount /dev/sda4 /home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候其实已经把/home目录移动好了。但是我们必须告诉计算机开机的时候该在哪里找home，所以需要修改一下配置文件,在/etc/fstab文件中添加下面一行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/sda4 /home ext4 nodev,nosuid 0 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新启动就成功了。如果不成功也没事，直接用root用户原来的工作都撤销就行了，也不影响大局。&lt;/p&gt;

&lt;h2&gt;linux/windows双系统问题&lt;/h2&gt;

&lt;p&gt;安装linux后第一次开机直接进入grub：
有的童鞋运气不好，第一次开机就出现错误，这很有可能是你安装不当或者系统自身有bug造成的（我们要有怀疑精神，不要老是觉得就是自己的错），没问题。这个时候我们就需要好好的利用tab键了。依次键入
root （hd0,0）--》如果你不确定你的win系统安装盘符可以 root （hd0，【tab】之后就会有提示，选中你需要的盘符就可以了，这里不    .                              细说每  个文件系统的意思了，要是真的什么都不知道就一个一个试就是了，总有一个可以的。
rootnoverify (hd0,0)--》后面那个0就是你自己选择的东东
chainloader +1
boot
好了，现在你又可以见到你亲爱的win了、、、、&lt;/p&gt;

&lt;h2&gt;ubuntu&lt;/h2&gt;

&lt;p&gt;电脑升级到麒麟14.04后从，在实验室办公室中上网插上网线一切正常，但是在宿舍中却不行，一直提示有线网络已断开，google了一下 修改ip 修改/etc/network/interfaces的方法都试过了还是不能解决，
后来看到网上有人说过网卡与交换机的不兼容性问题，于是百度了一下，果然有类似的问题。电脑网卡的工作模式设置不正确有可能导致与交换机不能通讯。
于是乎问题解决了
解决过程如下
1.安装ethtool软件设置网卡的工作模式sudo apt-get install ethtool
. ethtool的命令概要：
ethtool ethX       //查询ethX网口基本设置
ethtool –h         //显示ethtool的命令帮助(help)
ethtool –i ethX    //查询ethX网口的相关信息
ethtool –d ethX    //查询ethX网口注册性信息
ethtool –r ethX    //重置ethX网口到自适应模式
ethtool –S ethX    //查询ethX网口收发包统计&lt;/p&gt;

&lt;p&gt;ethX 是网卡的代表，具体可以用ifconfig命令查看 第一块有线网卡是eth0
这是我电脑设置过的网卡信息Settings for eth0:
      Supported ports: [ TP MII ]
      Supported link modes:   10baseT/Half 10baseT/Full
                              100baseT/Half 100baseT/Full
                              1000baseT/Half 1000baseT/Full
      Supported pause frame use: No
      Supports auto-negotiation: Yes
      Advertised link modes:Not reported
      Advertised pause frame use: No
      Advertised auto-negotiation: No
      Speed: 100Mb/s
      Duplex: Full
      Port: MII
      PHYAD: 1
      Transceiver: internal
      Auto-negotiation: off
Cannot get wake-on-lan settings: Operation not permitted
      Current message level: 0x000020c6 (8390)
                               probe link rx_err tx_err hw
Cannot get link status: Operation not permitted
关闭了网卡的自动协商功能，设置网卡在100M下工作，设置全双工的工作模式
命令如下sudo ethtool -s eth0 autoneg off speed 100 duplex full设置以后 电脑奇迹般的能连上有线网络了&lt;/p&gt;

&lt;p&gt;3.设置 开机自启动
打开/etc/init.d/rc.localsudo vim /etc/init.c/rc.local在文件的最后添加/sbin/ethtool -s eth0 autoneg off speed 100 duplex full到此结束&lt;/p&gt;

&lt;h2&gt;解决python2.x中爬虫爬到的网页数据包含中英文报错&lt;/h2&gt;

&lt;p&gt;import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)&lt;/p&gt;
</description>
				<pubDate>Sat, 12 Apr 2014 00:00:00 +0800</pubDate>
				<link>/2014/04/12/memo.html</link>
				<guid isPermaLink="true">/2014/04/12/memo.html</guid>
			</item>
		
			<item>
				<title>简单爬虫</title>
        <description>&lt;h3&gt;基础知识要求：uri，url，html，http，正则表达式&lt;/h3&gt;

&lt;h3&gt;1.获取网页源代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib# import urllib2
response = urllib.urlopen(&#39;www.baidu.com&#39;)#获取网页
html = response.read()#获取网页内容
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在urllib2里面有Request对象来映射你提供的http请求，制造一个请求，而不是直接连接网页&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2
request = urllib2.Request(&#39;www.baidu.com&#39;)
response = urllib2.urlopen(request)
html = response.read()
效果跟上面是一样的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.一些网站不愿意被非自动化程序访问（非浏览器），那么我们就需要在获取网页的时候添加一点header内容，把自己伪装成浏览器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
import urllib2
url = &#39;www.baidu.com&#39;
user_agent = &#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#39;    
values = {&#39;name&#39; : &#39;WHY&#39;,    
          &#39;location&#39; : &#39;SDU&#39;,    
          &#39;language&#39; : &#39;Python&#39; }    

headers = { &#39;User-Agent&#39; : user_agent }    
data = urllib.urlencode(values)#需要对头进行编码
req = urllib2.Request(url, data, headers)    
response = urllib2.urlopen(req)    
the_page = response.read() 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.简单的异常处理&lt;/h3&gt;

&lt;p&gt;当由于各种原因连接不成功的时候，会发生异常。我们可以简单的处理这个异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2

req = urllib2.Request(&#39;http://www.baidu.com&#39;)
try:
    http = urllib2.urlopen(req)
except urllib2.URLError, e:
    print e.reason#它会返回出错的原因
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*知识：http状态码&lt;/p&gt;

&lt;p&gt;urllib2中还有很多错误反馈信息，可以参见urllib2的教程或者文档。对于常规情况来说，我们只要知道不能联通就够了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;from urllib2 import Request, urlopen, URLError, HTTPError

req = Request(&#39;http://www.baidu.com&#39;)
try:
    http = urlopen(req)
except URLError, e:
    if hasattr(e,&#39;reason&#39;):
        print e.reason
    elif hasattr(e,&#39;code&#39;):
        print e.code
    else:
        print &#39;unknow error&#39;
else:
    print &#39;successful&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.Openers和Handles:&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Openers:&lt;/code&gt;当我们打开一个url的时候我们使用默认的的opener是urlopen（他是urllib2.OpenerDirector的实例），除此之外，我们可以自己构造opener&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Handers:&lt;/code&gt;Openers使用handlers处理各种事物，每个handler知道如何通过特殊的协议打开特定的url，或者处理特定url打开时的各个方面，例如http重定向。因此，我们就需要自己创建handers来处理我们的需要，比如创建能处理cookie的handler&lt;/p&gt;

&lt;p&gt;下面转自http://blog.csdn.net/pleasecallmewhy/article/details/8924889&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;要创建一个 opener，可以实例化一个OpenerDirector，然后调用.add_handler(some_handler_instance)。&lt;/p&gt;

&lt;p&gt;同样，可以使用build_opener，这是一个更加方便的函数，用来创建opener对象，他只需要一次函数调用。&lt;/p&gt;

&lt;p&gt;build_opener默认添加几个处理器，但提供快捷的方法来添加或更新默认处理器。&lt;/p&gt;

&lt;p&gt;其他的处理器handlers你或许会希望处理代理，验证，和其他常用但有点特殊的情况。&lt;/p&gt;

&lt;p&gt;install_opener 用来创建（全局）默认opener。这个表示调用urlopen将使用你安装的opener。&lt;/p&gt;

&lt;p&gt;Opener对象有一个open方法。&lt;/p&gt;

&lt;p&gt;该方法可以像urlopen函数那样直接用来获取urls：通常不必调用install_opener，除了为了方便。&lt;/p&gt;

&lt;p&gt;说完了上面两个内容，下面我们来看一下基本认证的内容，这里会用到上面提及的Opener和Handler。&lt;/p&gt;

&lt;p&gt;Basic Authentication 基本验证&lt;/p&gt;

&lt;p&gt;为了展示创建和安装一个handler，我们将使用HTTPBasicAuthHandler。&lt;/p&gt;

&lt;p&gt;当需要基础验证时，服务器发送一个header(401错误码) 请求验证。这个指定了scheme 和一个‘realm’，看起来像这样：Www-authenticate: SCHEME realm=&quot;REALM&quot;.&lt;/p&gt;

&lt;p&gt;例如:Www-authenticate: Basic realm=&quot;cPanel Users&quot;&lt;/p&gt;

&lt;p&gt;客户端必须使用新的请求，并在请求头里包含正确的姓名和密码。&lt;/p&gt;

&lt;p&gt;这是“基础验证”，为了简化这个过程，我们可以创建一个HTTPBasicAuthHandler的实例，并让opener使用这个handler就可以啦。&lt;/p&gt;

&lt;p&gt;HTTPBasicAuthHandler使用一个密码管理的对象来处理URLs和realms来映射用户名和密码。&lt;/p&gt;

&lt;p&gt;如果你知道realm(从服务器发送来的头里)是什么，你就能使用HTTPPasswordMgr。&lt;/p&gt;

&lt;p&gt;通常人们不关心realm是什么。那样的话，就能用方便的HTTPPasswordMgrWithDefaultRealm。&lt;/p&gt;

&lt;p&gt;这个将在你为URL指定一个默认的用户名和密码。&lt;/p&gt;

&lt;p&gt;这将在你为特定realm提供一个其他组合时得到提供。&lt;/p&gt;

&lt;p&gt;我们通过给realm参数指定None提供给add_password来指示这种情况。&lt;/p&gt;

&lt;p&gt;最高层次的URL是第一个要求验证的URL。你传给.add_password()更深层次的URLs将同样合适。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# -*- coding: utf-8 -*-
import urllib2

# 创建一个密码管理者
password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()

# 添加用户名和密码

top_level_url = &quot;http://example.com/foo/&quot;

# 如果知道 realm, 我们可以使用他代替 ``None``.
# password_mgr.add_password(None, top_level_url, username, password)
password_mgr.add_password(None, top_level_url,&#39;why&#39;, &#39;1223&#39;)

# 创建了一个新的handler
handler = urllib2.HTTPBasicAuthHandler(password_mgr)

# 创建 &quot;opener&quot; (OpenerDirector 实例)
opener = urllib2.build_opener(handler)

a_url = &#39;http://www.baidu.com/&#39;

# 使用 opener 获取一个URL
opener.open(a_url)

# 安装 opener.
# 现在所有调用 urllib2.urlopen 将用我们的 opener.
urllib2.install_opener(opener)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：以上的例子我们仅仅提供我们的HHTPBasicAuthHandler给build_opener。
默认的openers有正常状况的handlers：ProxyHandler，UnknownHandler，HTTPHandler，HTTPDefaultErrorHandler， HTTPRedirectHandler，FTPHandler， FileHandler， HTTPErrorProcessor。
代码中的top_level_url 实际上可以是完整URL(包含&quot;http:&quot;，以及主机名及可选的端口号)。
例如：http://example.com/。
也可以是一个“authority”(即主机名和可选的包含端口号)。
例如：“example.com” or “example.com:8080”。
后者包含了端口号。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;5.简单方法和函数&lt;/h3&gt;

&lt;p&gt;urllib2中的urlopen返回的对象有两个方法很常用，info(),geturl()&lt;/p&gt;

&lt;p&gt;&lt;code&gt;geturl()&lt;/code&gt;非常有用，因为urlopen可能会有重定向，比如说常见的新浪微博中，页面分享的视屏链接在新窗口中打开之后，链接会完全变化，这个时候的链接才是真正的url&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2

lod = &#39;http://t.cn/8si16mR&#39;
req = urllib2.Request(old)
http = urllib2.urlopen(req)
new = http.geturl
#这个时候的old和new是完全不一样的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;info()&lt;/code&gt;返回一个字典，描述了获取的页面的状态，通常是服务器发送过来特定的header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2
http = urllib2.urlopen(&#39;http://www.baidu.com&#39;)
print http.info()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;proxy&lt;/code&gt;的设置：urllib2会使用环境变量http_proxy来设置HTTP Proxy，如果想在程序中控制proxy，可以设置代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2
enable_proxy = True
proxy_handler = urllib2.ProxyHandler({&#39;http&#39;:&#39;http://some-proxy.com:8080&#39;})
null_proxy_handler = urllib2.ProxyHandler({})
if enable_proxy:
    opener = urllib.build_opener(porxy_handler)
else:
    opener = urllib.build_opener(null_proxy_handler)
urllib.install_opener(opener)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;timeout&lt;/code&gt;的设置：urllib2.urlopen(url,timeout = 10)&lt;/p&gt;

&lt;p&gt;在request中加入特定的头：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib2
request = urllib2.Request(&#39;http://www.baidu.com&#39;)
request.add_header(&#39;User-Agent&#39;,&#39;fake-client&#39;)
response = urllib2.urlopen(request)

cookie:
import urllib2
import cookielib
cookie = cookielib.CookieJar()
opener = urllib.build_opener(urllib2.HTTPCoolieProcessor(cookie))
response = opener.open(&#39;http://www.baidu.com&#39;)
for i in cookie:
    print &#39;name&#39;+i.name
    print &#39;value&#39;+i.value
#运行之后就可以得到访问百度的cookie值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;表单处理&lt;/code&gt;：从浏览器和抓包工具可以看到我们需要填写哪些表单,通常用字典的形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
import urllib2
postdata = urllib.urlencode({
    &#39;username&#39;:&#39;xxx&#39;
    &#39;passwd&#39;:&#39;xxx&#39;
    ...
})
request = urllib2.Request(url,postdata)
http = urllib2.urlopen(request)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;文件下载：&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import urllib
download = urllib.urlretrieve(url)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6.&lt;a href=&quot;http://www.jb51.net/article/15707.htm&quot;&gt;正则表达式&lt;/a&gt;&lt;/h3&gt;

&lt;h3&gt;7.实战，用爬虫访问insysu.com&lt;/h3&gt;

&lt;p&gt;首先浏览器进入我们美到一逼的第三方教务系统&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/python-spider/1.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;肯定是需要登录信息的，所以我们先&lt;F12&gt;查看以下登录目标在哪里&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/python-spider/2.png&quot; alt=&quot;2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;太明显了，本页就是登录点&lt;/p&gt;

&lt;p&gt;然后我们再看看登录需要提交的东西在哪里，点击登录，成功登录后查看network有一个post，点进去再点header一看就知道了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/python-spider/3.png&quot; alt=&quot;3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;恩，然后我们肯定是有cookie的，顺便也记录以下就行了&lt;/p&gt;

&lt;p&gt;于是开始编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;# =============================================================================
#      FileName: insysu.py
#          Desc: a spider to walk through the isysu.com using your name and passwd
#        Author: huangjin
#         Email: dantangfan@gmail.com
#      HomePage: https://www.github.com/dantangfan
#       Version: 0.0.1
#    LastChange: 2014-04-04 14:48:11
#       History:
# =============================================================================

#!/bin/env python
# -*-coding: utf-8 -*-

import urllib
import urllib2
import cookielib

cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))

#your post data

postdata = urllib.urlencode({
    &#39;username&#39;:&#39;11331130&#39;,
    &#39;password&#39;:&#39;09192970&#39;
    })
#make a request
require = urllib2.Request(url = &#39;http://insysu.com/sign_in&#39;,data = postdata)
#visit
result = opener.open(require)
#print
print result.read()
#print cookie
for item in cookie:
    print &#39;cookie: Name = &#39;+item.name
    print &#39;cookie: Value = &#39;+ item.value

#visit the target web site after login
result = opener.open(&#39;http://www.insysu.com&#39;)
print result.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意的是要先登录，然后才能进入主页面。看看结果如何&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/python-spider/4.png&quot; alt=&quot;4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;貌似达到了预期效果。&lt;/p&gt;

&lt;p&gt;接下来就可以进入相应的页面提取要的数据了&lt;/p&gt;
</description>
				<pubDate>Mon, 30 Dec 2013 00:00:00 +0800</pubDate>
				<link>/2013/12/30/python-spider.html</link>
				<guid isPermaLink="true">/2013/12/30/python-spider.html</guid>
			</item>
		
			<item>
				<title>半天简单总结python</title>
        <description>&lt;p&gt;help(func)随便什么函数都可以查到&lt;/p&gt;

&lt;h2&gt;数据类型&lt;/h2&gt;

&lt;p&gt;整数定义跟c语言一样,type(ver)返回变量类型&lt;/p&gt;

&lt;p&gt;&quot;&quot;&quot;三引号表示注释,三引号表示格式化输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;mail = &quot;&quot;&quot; Hi
    I am 
    Jim
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列切片--&gt;str[x:y],str[x,step,y]&lt;/p&gt;

&lt;p&gt;序列都有的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;len()
+
*    str=str1*5
in   &#39;s&#39; in str
max()
min()
cmp(tuple1,tuple2)
id(str)查看内存空间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内存存储的是值，不是元素，每当变量值改变的时候，内存都会变化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;str = &quot;ssg&quot;
id(str)
str = &quot;ss&quot;
id(str)#两次结果是不一样的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;元组：元组不可以单独元素变化，&lt;/h3&gt;

&lt;p&gt;创建元祖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;myempty = ()
singleone = (2,)
many = (1,3,4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;列表：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;list.append(msg)
list.remove(&#39;msg&#39;)选第一次出现的msg删除
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;字典：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;key不可变，value可变
keys()返回键列表
values()返回键值列表
items()返回字典中的元组
fdict = dict([&#39;x&#39;,1],[&#39;y&#39;,2])生成字典
dict.pop(key,val=msg)删除,不存在的时候返回msg（可选）
del(dict[key])删除
dict.clear()删除所有元素
del dict删除字典
dict.git(key,&#39;msg&#39;)取值不存在返回msg，msg可选
dict.fromkeys(seq,val=None)以seq中的元素为键创建一个字典，键值为空
dict.has_key(key) 判断是否存在key，常用in或者not in 代替
dict.update(temp_dict)把temp中的元素添加到dict，不存在则建立，存在则覆盖
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分支语句：if,if-else,if-elif-else&lt;/p&gt;

&lt;h2&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def f(x,*args.**kwarg):
    print x
    if(args):
        print args
    if(kwarg):
        print kwarg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传入任意数量参数，f(&#39;x&#39;,1,2,y=9)&lt;/p&gt;

&lt;p&gt;lambda x,y:x&lt;em&gt;y 直接返回x&lt;/em&gt;y&lt;/p&gt;

&lt;p&gt;比如阶乘 reduce (lambda x,y:x*y , range(1,100))&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在目录下创建__init__.py 就可以把文件变成一个包，使用import xxx.xxx导入包内文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;文件操作：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;fileptr = file(filename)
fileptr = open(filename,mode)默认模式是r.
fileptr.read()读取整个文件
fileptr.close()关闭
fileptr.write(&#39;msg&#39;)只有当关闭文件或者缓冲区的时候才会写入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;::r+读写，w+先删除再读写，没有则创建
r+直接从指针开头写入，如果要追加就需要先read()到文件尾部然后再来write
a在文件末尾追加新内容，a+读写
b打开二进制文件&lt;/p&gt;

&lt;h3&gt;文件方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;string = f.readline(size)size可选，小于一行
List = f.readlines(size)...
string = f.read(size)...
file.next()读取一行，指向下一行
for i in open(filename):
    print i#每次读取一行打印出来

f.write(msg)写一行
f.writelines(List)写多行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f.seek(偏移量,选项)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;0：表示将文件指针指到从文件0开始到偏移量处&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1：将指针从当前位置开始到偏移量处，&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2：从文件末尾倒数偏移量处&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;偏移方向用正负控制&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;eg&lt;/code&gt;f.seek(0,0)回到文件开始&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f.flush()提交更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;OS模块：常见函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import os
os.mkdir(&#39;/home/hj/test&#39;)
os.mkdir(path[,mode=0777])
makedirs(name,mode=511)创建多级目录
rmdir(path)
removedirs(path)删除多级目录
listdir(path)
getcwd()==&amp;gt;pwd
chdir(path)
walk(top,topdown=true,onerror=None)
os.isdir(name)判断是否为目录
os.path.join(path)#会把当前路进跟path连接起来
os.walk(path)返回一个元祖，有三个元素，分别为每次遍历的路径名，目录列表，文件列表
g = os.walk(&#39;.&#39;)
g.next()每次遍历一个目录下
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是就有了这样的办法来遍历目录打印全路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;for path,d,filelist in os.walk(&#39;.&#39;):
    for filename in filelist:
        os.path.join(path,filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;面向对象：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;class hj:
    first = 1
    second = 2
    name = &#39;d&#39;
    __var = &quot;私有属性&quot;
    def __init__(self,n=&#39;dd&#39;):
        self.name = n
        pirnt &quot;初始化&quot;
    def stati():
        print = &quot;静态&quot;
    def __se(self):
        print &quot;私有方法&quot;
    def f(self):
        print &#39;hj&#39;
    def __str__(self):
        return &quot;类被调用、运行的时候就自动出现&quot;
    def __del__():
        pass
if __name__==&#39;__main__&#39;:
    me = hj(&#39;hj&#39;)


class parent:
    def f(self):
        print &quot;father&quot;

class son(father):
    def func(self):
        print &#39;I am son&#39;

test = son()
test.f()
test.func()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;正则表达式：&lt;/h2&gt;

&lt;p&gt;import re&lt;/p&gt;

&lt;h3&gt;常用元字符： &lt;code&gt;. ^ $ * + ? {} () \ | []&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;s = r&#39;abx&#39;&lt;/code&gt;字符串前面加r，内部元字符就需要转义后才能匹配&lt;/p&gt;

&lt;p&gt;re.findall(s,&#39;avxxaagadfgdfg&#39;)返回一个列表&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\d 匹配任何十进制数字&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\D 匹配任何非数字&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\s 匹配任何空白字符&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\S 匹配任何非空白&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\w 匹配任何数字字母&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\W 匹配任何非数字字母&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;{8}重复8次&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;常用函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;r = r&#39;\d{3,4}-?\d{8}&#39;
p_tel = re.compile(r)
p_tel.findall(&#39;010-12345678&#39;)效果和re.findall(r,&#39;101-12345678&#39;)一样，但是速度更快
match()决定re是否在字符串刚开始的位置匹配
x = p_tel.match() x是一个迭代器，只判断是否有值
x.group()返回x指向的对象

search()扫描字符串，找到re匹配的位置
findall()返回所有匹配的列表
finditer()找到re匹配的所有字符串，并把他们作为一个迭代器返回
x = p_tel.finditer(msg)
x.group() 返回所有匹配
x.start() 返回第一个匹配
x.end() 返回最后一个匹配
x.span() 返回一个元组，包含(开始，结束)的位置

s.replace(str,str1)字符串替换
使用正则形式如下
rs = r&#39;c..t&#39;
re.sub(rs,&#39;python&#39;, &#39;fsfhglskuegjceet&#39;)用rs替换后者中的位置为中间的

s.split(brk)字符串切割
使用正则形式如下
re.split(r&#39;sfs*&#39;,str)
dir(re)查看re的内置属性和方法，任何包都可以使用

属性
S匹配任何字符，包括换行等re.findall(r,str,re.S)
M多行匹配 re.findall(r,file,re.M)
I大小写不敏感re.I
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;调用外部程序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import subprocess
subprocess.call(&#39;ls -l &#39;, shell=True)#默认false，为true时使用shell执行命令
subprocess.call([&#39;ls&#39;,&#39;l&#39;,&#39;.&#39;])相同效果，推荐使用上面
dir(subprocess)

import os
os.system(&#39;ls -l&#39;)#执行正确返回0，错误返回其他数字。可以接收任何shell命令
os.listdir(&#39;.&#39;)
f = os.popen(&#39;ls&#39;)
f.read()获得内容
stdin, stdout = os.popen2(&#39;sort&#39;)#返回标准输入和输出
stdin.write(&#39;a\n&#39;)
stdin.write(&#39;c\n&#39;)
stdin.write(&#39;b\n&#39;)
stdin.close()
stdout.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;爬虫下载图片&lt;/h2&gt;

&lt;h3&gt;简单爬虫&lt;/h3&gt;

&lt;p&gt;首先查看网页代码，图片代码的特征。正则提取图片地址，开始下载&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/bin/env python

import re
import urllib#从地址获取源代码
#获取指定地址源代码
def getHtml(url):
    page = urllib.urlopen(url)
    html = page.read()
    return html

#获得图片
def getImage(html):
    reg = r&#39;src=&quot;(.*\.jpg)&quot; width&#39;
    imgre = re.compile(reg)
    imglist = re.findall(reg,html)
    x = 1
    for i in imglist:
        urllib.urlretrieve(i,&#39;%s.jpg&#39; % x)
        x = x+1

if __name__==&#39;__main__&#39;:
    getImage(getHtml(&#39;www.baidu.com&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;GUI--wxpython:&lt;/h2&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;导入wxpython包&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类化wxpython应用程序类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义一个应用程序的初始化方法&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个应用程序类的实例&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入这个应用程序的主实践循环&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建应用程序对象：app = wx.app()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建窗口：win = wx.Frame(None)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显示窗口：win.Show()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入应用程序管理循环:app.MainLoop()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;一个简单的记事本，通过像素管理尺寸（特别是文本框）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title=&#39;hj&#39;,size = (410,335))
win.Show()#显示
loadButton = wx.Button(win,lable=&#39;load&#39;,pos = (225,5), size = (80,25))#按钮
saveButton = wx.Button(win,lable=&#39;save&#39;,pos = (315,5), size = (80,25))

filename = wx.TextCtrl(win,pos = (5,5),size = (210,25))#文本框
content = wx.TextCtrl(win, pos = (5,35), size = (390,260), style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;记事本，用尺寸器管理大小&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title=&#39;hj&#39;,size = (410,335))

bkg = wx.Panel(win)#尺寸管理,背景画板

loadButton = wx.Button(bkg,lable=&#39;load&#39;)#按钮
saveButton = wx.Button(bkg,lable=&#39;save&#39;)
filename = wx.TextCtrl(bkg)#文本框
content = wx.TextCtrl(bkg, style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条

#划分组建位置
hbox = wx.BoxSizer()#不加参数，默认左右管理（上面一个文本框两个按钮，上部份）
hbox.add(filename，proportion=1,flag = wx.EXPAND)#proportion表示占位置大小,1为最大空间，flag表示是否拉伸
hbox.add(loadButton, proportion=0,flag = wx.LEFT,boder = 5)#表示在左边有边界，像素5
hbox.add(saveButton, proportion=0,flag = wx.LEFT,boder = 5)

bbox = wx.BoxSizer(wx.VERTICAL)#上下划分页面管理
bbox.add(hbox,proportion = 0,flag = wx.EXPAND | wx.ALL,border=5)
bbox.add(content,proportion = 1,flag = wx.EXPAND | wx.LEFT | wx.BOTTOM | wx.RIGHT,border = 5)

bkg.SetSize(bbox)#让布局管理器生效

win.Show()#显示
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;按钮事件处理，事件绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title=&#39;hj&#39;,size = (410,335))

bkg = wx.Panel(win)#尺寸管理,背景画板

#定义load按钮
def openfile(evt):
    filepath = filename.GetValue()#获取输入
    fopen = open(filepath,&#39;a+&#39;)#打开文件
    content.SetValue(fopen.read())#把文件放在content
    fopen.close()

def savefile(evt):
    filepath = filename.GetValue()
    fopen = open(filepath,&#39;a+&#39;)
    fopen.write(content.GetValue())
    fopen.close()

loadButton = wx.Button(bkg,lable=&#39;load&#39;)#按钮
saveButton = wx.Button(bkg,lable=&#39;save&#39;)
filename = wx.TextCtrl(bkg)#文本框
content = wx.TextCtrl(bkg, style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条

loadButton.Bind(wx.EVT_BUTTON,openfile)#load键绑定了button类型的openfile事件
saveBUtton.Bind(wx.EVT_BUTTON,savefile)
#划分组建位置
hbox = wx.BoxSizer()#不加参数，默认左右管理（上面一个文本框两个按钮，上部份）
hbox.add(filename，proportion=1,flag = wx.EXPAND)#proportion表示占位置大小,1为最大空间，flag表示是否拉伸
hbox.add(loadButton, proportion=0,flag = wx.LEFT,boder = 5)#表示在左边有边界，像素5
hbox.add(saveButton, proportion=0,flag = wx.LEFT,boder = 5)

bbox = wx.BoxSizer(wx.VERTICAL)#上下划分页面管理
bbox.add(hbox,proportion = 0,flag = wx.EXPAND | wx.ALL,border=5)
bbox.add(content,proportion = 1,flag = wx.EXPAND | wx.LEFT | wx.BOTTOM | wx.RIGHT,border = 5)

bkg.SetSize(bbox)#让布局管理器生效

win.Show()#显示
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;多线程：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import thread
import time
def go(name,n):
    for i in xrange(3)
        print name,i
        time.sleep(1)

thread.start_new_thread(go,(&#39;baby&#39;,3))
thread.start_new_thread(go,(&#39;gay&#39;, 3))
time.sleep(6)#线程工作需要时间，如果不sleep，进程就会直接瞬间结束，这个时候线程也就自动结束了，不会相互等待
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;线程锁:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import thread
import time
def go(name,n,l):
    for i in xrange(3)
        print name,i
        time.sleep(1)
    l.release()
locket = thread.allocate_lock()#申明锁对象
locket.acquire()#把锁锁上
print locket.locked()#查看状态

thread.start_new_thread(go,(&#39;baby&#39;,3),locket)

#locket.release()#解锁

while locket.locked():
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实个人感觉python的多线程就是一个坑，很多情况下根本达不到多线程的效果，或者是我根本就不会用。估计是后者。。。orz...&lt;/p&gt;

&lt;h2&gt;Json格式储存文件：&lt;/h2&gt;

&lt;p&gt;Json必须是unicode类型的（utf-32,utf-16,utf-8默认）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import json
d = {&#39;n&#39;:,&#39;tag&#39;:89,&#39;id&#39;:(&#39;sdf&#39;,234),&#39;pk&#39;:[12,&#39;sfs&#39;]}#元组会自动转化成列表
with open(&#39;test.txt&#39;,&#39;w&#39;) as f:
    json.dump(d,f)#顺序储存
    json.dump(d,f,indent = 0)#每个数据存一行
    json.dump(d,f,indent = 2)#每个数据的内部数据缩进为2
&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Wed, 25 Dec 2013 00:00:00 +0800</pubDate>
				<link>/2013/12/25/learn-python.html</link>
				<guid isPermaLink="true">/2013/12/25/learn-python.html</guid>
			</item>
		
			<item>
				<title>树莓派制作wifi控制小车</title>
        <description>&lt;h2&gt;树莓派小车&lt;/h2&gt;

&lt;h3&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://trade.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.8.M4n9cw&amp;amp;tradeID=567688753132954&quot;&gt;树莓派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=19142619516&quot;&gt;SD卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;拓展板(可选)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=19995371946&quot;&gt;电源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36909029780&quot;&gt;电机和电机驱动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36850212461&amp;amp;ali_trackid=2:mm_10062864_0_0,0:1395925709_3k2_39373907&amp;amp;spm=a230z.1.5634029.7.0Be1hk&quot;&gt;摄像头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?spm=a230r.1.14.41.LfxL1r&amp;amp;id=22921464431&amp;amp;_u=rq4fe15dd67&quot;&gt;无线网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36903458968&quot;&gt;底盘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;raspberry基本系统搭建&lt;/h3&gt;

&lt;h4&gt;系统刷写&lt;/h4&gt;

&lt;p&gt;可以选择的系统非常多，有Raspbian，Archlinuxarm，Pidora等等，按需选择。&lt;/p&gt;

&lt;p&gt;刷系统，主要是往SD卡中写入系统，Linux下可以使用dd命令，windows下可以使用Win32DiskImager。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;可以先刷写一个SD卡，然后进行常规配置和自定义配置，提取镜像，再刷人其他SD卡。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raspberrypi.org/downloads&quot;&gt;官方系统下载&lt;/a&gt;,&lt;a href=&quot;http://mirrors.ustc.edu.cn/raspberrypi/images/&quot;&gt;中科大加速镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raspberrypi.org/quick-start-guide&quot;&gt;Quick start guid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mall.egoman.com.cn/index.php?option=com_content&amp;amp;view=article&amp;amp;id=99:-lab1raspberrywindows-&amp;amp;catid=47:shiyongfangan-&amp;amp;Itemid=222&quot;&gt;浙大课程： Lab1:初见树莓派(Raspberry)(windows平台)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangshenjia.com/it/raspberry_pi/mac-raspbian/&quot;&gt;mac下给树莓派安装raspbian系统(DD命令)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;小车底板组装&lt;/h3&gt;

&lt;p&gt;根据实际情况或者买家提供的教程组装&lt;/p&gt;

&lt;h3&gt;配置静态ip&lt;/h3&gt;

&lt;p&gt;无线控制希望每次登录都可以使用同一个ip，省去了查找ip的麻烦。&lt;/p&gt;

&lt;p&gt;配置固定IP，不管是有线还是无线都配置静态ip&lt;/p&gt;

&lt;p&gt;以Raspbian（debain系）为例：（本配置是在实验室环境下路由器提供的ip，请根据实际情况修改）&lt;/p&gt;

&lt;p&gt;编辑 /etc/network/interfaces&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet static
address 192.168.1.10
netmask 255.255.255.0
gateway 192.168.1.1

auto wlan0
iface wlan0 inet static
address 192.168.1.88
netmask 255.255.255.0
gateway 192.168.1.1
wpa-ssid 要连接的wlan ssid
wpa-passphrase wlan密码
wireless-channel 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启网络服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#root用户，或者加sudo
/etc/init.d/networking restart 
OR
service networking restart 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;wifi控制小车&lt;/h3&gt;

&lt;h4&gt;摄像头&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将USB摄像头插上，查看是否找到设备，输入：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;root@raspberrypi:/# lsusb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Logitech就是摄像头，说明找到usb设备了，然后再看看设备驱动是否正常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@raspberrypi:/# ls /dev/vid*
/dev/video0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到video0说明成功。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装必要的软件集：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;sudo apt-get install subversion
sudo apt-get install libv4l-dev
sudo apt-get install libjpeg8-dev
sudo apt-get install imagemagick
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;下载mipg-steamer软件，编译并安装：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;svn co https://mjpg-streamer.svn.sourceforge.net/svnroot/mjpg-streamer mjpg-streamer
cd mjpg-streamer/mjpg-streamer
make USE_LIBV4L2=true clean all
make DESTDIR=/usr install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：如果这个svn的地址可能已经失效，请使用下面源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://sourceforge.net/code-snapshots/svn/m/mj/mjpg-streamer/code/mjpg-streamer-code-182.zip
unzip mjpg-streamer-code-182.zip
cd mjpg-streamer-code-182/mjpg-streamer
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建一个文件video.sh并编辑如下代码&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;#!/bin/sh

STREAMER=mjpg_streamer
DEVICE=/dev/video0
RESOLUTION=320x240
FRAMERATE=25
HTTP_PORT=8001

PLUGINPATH=/usr/lib

$STREAMER -i &quot;$PLUGINPATH/input_uvc.so -n -d $DEVICE -r $RESOLUTION -f $FRAMERATE -y YUYV&quot; -o        &quot;$PLUGINPATH/output_http.so -n -p $HTTP_PORT &quot; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;执行代码&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;sudo chmod 777 video.sh 
sudo ./video.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在pc上建立一个html文件，如下编辑&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;RPi&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
                button {
                        margin: 5px 5px 5px 5px;
                        width: 50px;
                        height: 50px;
                        font-size: 24pt;
                        font-weight: bold;
                        color: black;
                }
        &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;content&quot; align=&quot;center&quot;&amp;gt;
                &amp;lt;img width=&quot;500&quot; height=&quot;400&quot; src=&quot;http://&quot;你的raspberry pi ip地址”:8001/?action=stream&quot;&amp;gt;&amp;lt;br/&amp;gt;
                &amp;lt;div id=&quot;up&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div id=&quot;middle&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div id=&quot;down&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在pc上运行上面index.html”文件看到视频了，就说明摄像头工作正常了，到此摄像头的工作就结束了&lt;/p&gt;

&lt;p&gt;效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/raspberry-car/video.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在执行的过程中，如果显示摄像头关闭不成功，则要杀死进程&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;kill $(pgrep video.sh)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;控制代码&lt;/h4&gt;

&lt;p&gt;小车的控制可以用任何raspberry上能运行的语言编写，这里为方便，直接使用python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#wheel.py
import RPi.GPIO as GPIO
class wheel:
    pins = {&#39;left1&#39;:[13,15],&#39;left2&#39;:[16,18],&#39;right1&#39;:[19,21],&#39;right2&#39;:[22,24]}

    def __init__(self,name):
        self.name = name
        self.pin = wheel.pins[self.name]
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(self.pin[0],GPIO.OUT)
        GPIO.setup(self.pin[1],GPIO.OUT)
        self.stop()

    def forward(self):
        GPIO.output(self.pin[0],GPIO.HIGH)
        GPIO.output(self.pin[1],GPIO.LOW)

    def back(self):
        GPIO.output(self.pin[0],GPIO.LOW)
        GPIO.output(self.pin[1],GPIO.HIGH)

    def stop(self):
        GPIO.output(self.pin[0],GPIO.LOW)
        GPIO.output(self.pin[1],GPIO.LOW)

    def __del__(self):
        pass
        #GPIO.cleanup()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#car.py
from wheel import *
import RPi.GPIO as GPIO
class car:
    wheels=[wheel(&#39;left1&#39;),wheel(&#39;left2&#39;),wheel(&#39;right1&#39;),wheel(&#39;right2&#39;)]

    def __init__(self):
        GPIO.setmode(GPIO.BOARD)

    def forward(self):
        for wheel in car.wheels:
            wheel.forward()

    def back(self):
        for wheel in car.wheels:
            wheel.back()

    def left(self):
        car.wheels[2].forward()
        car.wheels[3].forward()
        car.wheels[0].back()
        car.wheels[1].back()

    def right(self):
        car.wheels[0].forward()
        car.wheels[1].forward()
        car.wheels[2].back()
        car.wheels[3].back()

    def stop(self):
        for wheel in car.wheels:
            wheel.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#action.py

from car import *
import clean


def action(com):

    #when control the car
    if com==&quot;forward&quot;:
        a = car()
        a.forward()
    elif com==&quot;back&quot;:
        a = car()
        a.back()
    elif com==&quot;left&quot;:
        a = car()
        a.left()
    elif com==&quot;right&quot;:
        a = car()
        a.right()
    elif com==&quot;stop&quot;:
        a = car()
        a.stop()
    #clean all
    elif com==&quot;clean&quot;:
        clean.clean()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#server.py

from actions import *
from socket import *
import sys
import time
import RPi.GPIO as GPIO

host = &quot;192.168.1.10&quot;
port = 8888
s = socket()

s.bind((host,port))
s.listen(5)
print &quot;listen on port 8888&quot;

while 1:
    conn, addr = s.accept()
    print &quot;connected by:&quot;,addr

    while 1:
    #if 1:
        command = conn.recv(1024).replace(&#39;\n&#39;,&#39;&#39;)
        #print command
        if not command: break
        #this command to test the distance 
        elif command==&quot;distance&quot;:
            dis=action(command)
            conn.send(dis)
        else:
            action(command)
    conn.close()
    #action(&quot;clean&quot;)
    #GPIO.cleanup()
    #conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dreamcolor.net/archives/rpio-document-pwm-py.html&quot;&gt;raspberry GPIO编程指导&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;PC客户端代码：&lt;/p&gt;

&lt;p&gt;注意：请先安装wxpython&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#coding:utf-8
import time
import wx
import socket
#import sys
import threading
import struct

#Receive message
class Receiver(threading.Thread):
    def __init__(self,threadName,window):
        threading.Thread.__init__(self)
        self.threadName = threadName
        self.window = window
        self.timeToQuit = threading.Event()
        self.timeToQuit.clear()
        #连接服务器
        # Create a socket (SOCK_STREAM means a TCP socket)
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            # Connect to server and send data
            self.sock.connect((self.window.host, self.window.port))
            self.window.LogMessage(&quot;连接服务器成功...\n&quot;)
            self.runT = True
        except Exception:
            self.window.LogMessage(&quot;连接服务器失败...\n&quot;)
            self.sock.close()

    def stop(self):
        self.window.LogMessage(&quot;关闭Socket连接...\n&quot;)
        self.sock.close()
        self.runT = False
        self.timeToQuit.set()

    def sendMsg(self,msg):
        logMsg = (u&quot;发送：%s\n&quot; % (msg))
        self.window.LogMessage(logMsg)
        self.sock.sendall(msg)

    def run(self):
        try:
            while self.runT:
                data = self.sock.recv(4)
                if data:
                    dataLen, = struct.unpack_from(&quot;i&quot;,data)
                    wx.CallAfter(self.window.LogMessage,(u&quot;返回数据长度:%s\n&quot; % (dataLen)))
                    wx.CallAfter(self.window.LogMessage,(u&quot;返回数据:%s\n&quot; % (self.sock.recv(dataLen))))
        except Exception:
            pass
class InsertFrame(wx.Frame):

    def __init__(self, parent, id):

        #创建父框
        wx.Frame.__init__(self, parent, id, &#39;Socket Client&#39;, size=(1140, 450))
        #创建画板
        self.panel = wx.Panel(self,-1)
        self.panel.SetBackgroundColour(&quot;White&quot;)
        #创建按钮
        self.createButtonBar(self.panel)
        #创建静态文本
        self.createTextFields(self.panel)
        #创建文本框
        self.creatTextInput(self.panel)

        #Socket 地址
        self.host, self.port = &quot;localhost&quot;, 12340
        self.runT = True
###############################
    #创建文本
    def createTextFields(self, panel):
        for eachLabel, eachPos in self.textFieldData():
            self.createCaptionedText(panel, eachLabel, eachPos)

    def createCaptionedText(self, panel, label, pos):
        static = wx.StaticText(panel, wx.NewId(), label, pos)
        static.SetBackgroundColour(&quot;White&quot;)
#########################
    #创建按钮
    def createButtonBar(self, panel):
        for eachLabel,eachSize,eachPos, eachHandler in self.buttonData():
            self.buildOneButton(panel, eachLabel,eachSize,eachHandler,eachPos)
    def buildOneButton(self, parent, label,buttonsize,handler, pos=(0,0)):
        button = wx.Button(parent, -1, label, pos,buttonsize)
        #绑定按钮的单击事件
        self.Bind(wx.EVT_BUTTON, handler, button)
#########################
    #按钮栏数据
    def buttonData(self):#(按钮名称，按钮大小，按钮坐标，按钮事件）
        return ((&quot;forward&quot;,(60,60 ),(875, 100),self.forward),
                (&quot;back&quot;,(60, 60),(875, 300),self.back),
                (&quot;left&quot;,(60, 60),(750, 200),self.left),
                (&quot;right&quot;,(60, 60),(975, 200),self.right),
                (&quot;stop&quot;,(60, 60),(875, 200),self.stop),
                (&quot;连 接&quot;,(50, 25),(310, 30),self.OnConnection),
                (&quot;断 开&quot;, (50, 25),(370, 30),self.OnCloseSocket),
                (&quot;清 空&quot;, (50, 25),(430, 30),self.OnClearLog),
                (&quot;发 送&quot;, (50, 25),(540, 400),self.OnSend))
    #文本内容
    def textFieldData(self):
        return ((&quot;Please Input socket address AND port：&quot;, (10, 10)),
                (&quot;输入消息：&quot;, (10, 380)))
########################
    #创建文本框
    def creatTextInput(self,panel):
        #服务器地址输入框
        self.socketHostText = wx.TextCtrl(self.panel, wx.NewId(), &quot;&quot;, size=(230, 25),pos=(10, 30))
        #服务器端口输入框
        self.socketPortText = wx.TextCtrl(self.panel, wx.NewId(), &quot;&quot;, size=(50, 25),pos=(250, 30))
        #信息显示
        self.log = wx.TextCtrl(self.panel, -1, &quot;&quot;,size=(620, 310),pos=(10, 60),style=wx.TE_RICH|wx.TE_MULTILINE|wx.TE_READONLY)
        #信息输入
        self.inputMessage = wx.TextCtrl(self.panel, wx.NewId(), size=(520, 25),style=wx.TE_PROCESS_ENTER,pos=(10, 400))
        self.Bind(wx.EVT_TEXT_ENTER, self.OnSend, self.inputMessage)
########################

    #事件处理器(关闭窗口）
    def OnCloseWindow(self, event):
        self.thread.stop()
        self.Destroy()

    #事件处理器(关闭Socket）
    def OnCloseSocket(self, event):
        self.thread.stop()

    #事件处理器(连接到SOCKET）
    def OnConnection(self,event):
        if self.socketHostText.GetValue()!=&#39;&#39; and self.socketPortText.GetValue()!=&#39;&#39;:
            self.host, self.port = str(self.socketHostText.GetValue()),int(self.socketPortText.GetValue())
        threadName = &quot;socketclient&quot;
        self.thread = Receiver(threadName, self)#创建一个线程
        self.thread.setDaemon(True)
        self.thread.start()#启动线程

    #事件处理器(显示LOG）
    def LogMessage(self, msg):#注册一个消息
        self.log.AppendText(msg)

    #事件处理器(清空LOG）
    def OnClearLog(self,event):#注册一个消息
        self.log.Clear()

    #事件处理器(给SOCKET发送消息,并清空输入框）
    def OnSend(self, event):
        self.thread.sendMsg(self.inputMessage.GetValue())
        self.inputMessage.Clear()

    ##############################################
    ##movement button##

    def forward(self,event):
        self.thread.sendMsg(&quot;forward&quot;)

    def back(self,event):
        self.thread.sendMsg(&quot;back&quot;)

    def left(self,event):
        self.thread.sendMsg(&quot;left&quot;)

    def right(self,event):
        self.thread.sendMsg(&quot;right&quot;)

    def stop(self,event):
        self.thread.sendMsg(&quot;stop&quot;)


if __name__ == &#39;__main__&#39;:
    app = wx.PySimpleApp()
    frame = InsertFrame(parent=None, id=-1)
    frame.Show()
    app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/raspberry-car/pc_client.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;为方便，可以直接使用git下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/dantangfan/tank.git tank
git clone https://github.com/dantangfan/clientTank clientTank
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;管理和应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/NeonHorizon/berryio&quot;&gt;berryio&lt;/a&gt;,[项目介绍](http://www.geekfan.net/3251/）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://code.google.com/p/webiopi/&quot;&gt;webiopi&lt;/a&gt;,[项目介绍](http://www.2fz1.com/?tag=webiopi）&lt;/p&gt;

&lt;h4&gt;相关文档&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://ishare.iask.sina.com.cn/f/61335036.html&quot;&gt;GY-26电子指南针资料（串口+IIC+温度）&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://share.eepw.com.cn/share/download/id/165040&quot;&gt;黑白 红外壁障模块 资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/8f46c2d1b9f3f90f76c61b4f.html&quot;&gt;DHT22_温湿度传感器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/272b0c69a98271fe910ef926.html&quot;&gt;GY-26电子指南针使用手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/ce9e5e48767f5acfa1c7cd8a.html&quot;&gt;HC-SR04超声波测距模块说明书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://forum.stmlabs.com/showthread.php?tid=5549&quot;&gt;人体红外感应器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://raspberrytank.ianrenton.com/&quot;&gt;raspberrytank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.apinglai.com/category/arm/&quot;&gt;传感器的简单应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;联系人&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;联系：dantangfan@gmail.com，316977394@qq.com&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Thu, 12 Dec 2013 00:00:00 +0800</pubDate>
				<link>/2013/12/12/raspberry-car.html</link>
				<guid isPermaLink="true">/2013/12/12/raspberry-car.html</guid>
			</item>
		
			<item>
				<title>颓废</title>
        <description>&lt;p&gt;“幺弟，还没起来哇？我都吉上班了，今天你生哒！记到吉吃点好的哈！”
“哦！今天我生阿！那我起来了。恩恩，要的。你还是帮我多吃点嘎嘎哈。”
一大早眼睛的都还没增开就遭哥的电话喊起来了。恩，好勒，起个大早吉食堂吃个煮鸡蛋麻，在咋个也是过生麻，意思意思一哈也是应该的。于是我到食堂吉了。洗洗刷刷的泡吉食堂。哦哟！小笼包都还没的几个人排队得！那我就吃两笼蒸饺麻。三五分钟喝完了一瓶维他奶过后，我又滚会宿舍吉了。“耶？我还有课的麻！”然后又稀里糊涂的去上课了。哦，原来我起来的时候都要到十点了，虽然还是比较早。
“老二阿，今天过生麻，祝你生日快乐哈。没得啥子事得，就浪子麻，你吉上你的课麻。”
“恩，阿，哦。。”
还没反映过来是咋个回事，老汉儿就把电话挂了。一看刚好５９秒，哦哟！老汉儿还的行耶，随便一挂都把时间卡的刚刚好。又一想，好像不对。不久前才看过移动是满５５秒就按两分钟收费的，亏了！！我继续愤愤不平地滚去实验室了。到了Ｂ幢楼下，好像有点口干了。遭了，忘带硬笔了！我拿钱包里面那张崭新的５元大钞在自动售货机塞了半天它都没鸟我。不过也好，上次那玩意儿收了我一张05年的古董级别的１０元大洋，然后在每个水下面画了个小叉叉，然后就不鸟我了。
居然要到四楼去上课，真是想不通教务处的人咋个安排的课程，全班就二三十个人都要爬浪高。到教室一看，真凉快，就跟上学期上常大爷的课一样稀松。然后我到朱子旭旁边找个位置座了下来，嗯，这里比较暖和，果然树大遮阳也遮风。
“黄晋，你怎么又没去实验室阿！你快点做你的东西阿！你跟那个谁商量好阿！老师在催了阿！”
傻逼方拉扯他略显沙哑的声音跟我说话。噫？小方今天咋个笑的那么萌呢？老师的声音怎么听起来那么熟悉呢？
“这个老师的声音好像我们上学期实验课老师的哦。”我说。
“就是，都是广东的口音。不过不知道有没有那么严格。”子旭果然是负责人学霸。
仔细的看看。哎，我的左眼是什么时候变得这么模糊的呢？还是用右眼看吧。终于看清楚了，这不就是以前上网络安全公选课的老师麻！恩，挺喜欢他，他没挂我。恩，不喜欢邓革，老是想挂我，还好我命大。
“果然是第一节课，真该在宿舍睡觉。”
“就是，白来了。”
诶？培君呢？所噶，肯定是跟那两个交换生妹子在一起。啧啧啧，他招架的住么？孝树有去帮忙么？应该没有麻，孝树应该还忙着泡师妹麻。噫？这关我什么事呢？“同学之间要相互友爱”，恩，我这是在关心同学。往旁边看看，卧槽！太特么有志向了，鹏志居然把ＣＣＡＶ放过的某种片子全部下下来了，还在课堂上搞。我瞬间觉得他是多么的高大威猛，虽然我比他长很多。
哎呦喂，这个位置不好，看不清也听不到。逼我玩儿电脑。“玩儿什么呢？”想了半天，4399......很抱歉，我在实验室只想到这个能在线跑的比较快了，我当程序员还有希望么？？？？转身看看旁边的子旭和林郁，高端大气上档次的人就是不跟我等屌丝一样。他们正在看东京大学招生网的题目，是破解01编码。“000110100101001111000111011101001.....”不过我觉得真心该关注的是编码后面的那个妹子吧。。哎，看我多低俗。。。继续游戏吧。
嗯？手机怎么响了？原来是娘亲。我才突然又想起原来今天是我生日的麻。“过生的人就是牛逼，能一天接三个电话！而且还不包括10086！”但是在上课，我没接。。
ＹＹ了一会儿，然后老师突然走了。哦！原来是他提前下课了。这个也太不靠谱了吧！一节课45分钟居然提前了二十分钟。。恩，正好给娘亲回个电话。
不过还是没话说，还好不是59秒，这次只收了一分钟的钱。果然还是女人更持家呀～
去食堂吃了个套餐，一荤一素，不过天气太热了，没吃完。
回到宿舍直接躺到床上，好吧，我承认我有点忧伤，但一定不是大姨爹！想一想，我是有多久在家过我的生日了呢？5年还是8年呢？老爹有多久没跟任何一个家人一起过过生日了呢？10年还是更久？不想了，不想了，在外漂泊，多想无益。哦！还有一件重要的事情不能忘了。我是什么时候开始每年过生日都买张彩票的呢？应该是从我知道有彩票这个玩意儿的时候麻！这次我花下血本儿，买了三十块的，因为我从来没有中过，哪怕是５块钱。为国家福利事业做贡献总是好的，我只能这么想，因为这次我还是的都没中。我打算下次买快乐三，4-18都买一边，就可以中一次了。
晚上了，我从来没有把我的生日当成什么特殊的日子过。但是我知道有人会，而且一定会。我不说，你知道我是说你，而且大家都知道我是说的你。被爱的感觉原来如此美好，怪不得你一直都在追求。我不爱宣扬，但是我不得不说你是我的所有。此处留白，等待未来填满。。&lt;/p&gt;

&lt;p&gt;但是我为什么要突然写日志呢？除了论文，我是有两年没有写过东西了！！！像这样的全身都是钉子柴子是不可能被磨光滑了的。今天一大早就起来，小东东感冒滚回家了，小静静去看老豆了。恩，我还是该去找点事情做。我是应该去实验室了！“特么的今天这床上是贴了502么！怎么也爬不起来。”一瞬间突然惊醒！！然后一脸蛋定“卧槽，又是传说中的鬼压床。下次争取梦到个女鬼，看老子的厉害！”意淫了一会儿，然后百无聊赖的起来到阳台。“擦，又忘了买牙膏了，昨天晚上还是洗的素澡呢！”然后打开电脑。等待开机的时候，看了看手机，“所噶！今天是中秋节了的麻！法定假日了，不用工作。”于是心安理得的不去实验室了，也不知道今天是什么日子，ＣＣＴＶ５+一直都在重播比赛。看的起劲，嘉毛居然告诉我这时因为今天放假，工作人员都放假了，然后就随便给几个比赛让我们这种没地方去的人在这里过过干瘾。
过节！今天中午吃什么呢？从寝室一直走到食堂我都没想好吃什么，果然是吾日三省吾身阿！早中晚都不知道吃什么。早中晚？我不是没吃早饭么？恩，又少了点思想上的负担。每次不知道吃什么的时候就去一饭吃套餐，这次也不例外。
我看阿看，看阿看，巴萨太变态了，梅西又是帽子戏法；西班牙太变态了，又是小加独吃篮下。恩，等等应该还有法国队的比赛。但是等了半天都没有。我才突然想到该跟爷爷打电话了！
“二娃呀！哎呀，你生我都没给你打电话！扎扎实实的搞忘记了！今天才想起。”
“你今天吃的啥子耶？胃子没有痛了麻？长点嘎嘎没有？哎呀，听到你打电话回来我就欢喜了。”
......
一口气摆了好久。心情就舒畅了好多。然后爬着就睡着了。。。。
睡着睡着就起来了。
恩？我在码字？这是真的么？恩，我没发烧。
刷刷微博。
“中秋节快乐，也祝我生日快乐”　+1 , 点赞。
“苹果公司发布正式版iOS7升级，此次升级......”　关我毛事，老子是穷屌丝。
......
果然ｑｑ空间才是四川人民的爱。我又在这里找归属感。
看到大刀的“我想回家，一接到家里的电话眼泪就止不住的流。”
哎呦，女生就是性感，哦不，感性。
噫，玩意儿在我脸上？咸咸的，滑滑的。
卧槽！！！我特么居然湿润了！！！这不科学！！！&lt;/p&gt;

&lt;p&gt;赶紧听首歌，我很忙，牛仔很忙，我不是牛仔也很忙！&lt;/p&gt;

&lt;p&gt;忙么？？？？？&lt;/p&gt;

&lt;p&gt;呜啦啦啦火车笛
随着奔腾的马蹄
小妹妹吹着口琴
夕阳下美了剪影
我用子弹写日记
介绍完了风景
接下来换介绍我自己&lt;/p&gt;

&lt;p&gt;我虽然是个牛仔
在酒吧只点牛奶
为什么不喝啤酒
因为啤酒伤身体
很多人不长眼睛
嚣张都靠武器
赤手空拳就缩成蚂蚁
Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的&lt;/p&gt;

&lt;p&gt;牛仔很忙是我和黄俊郎阿郎
所共同创造的美国乡村民谣新曲风
也是我之前所有专辑里面没有过的曲风哦
不要再说我没有改变
但是呢 我还是坚持自己的风格
咬字不清 哈哈~
虽然俺 在乎透明
为了爱 隆嘛跨不里&lt;/p&gt;

&lt;p&gt;我啦啦啦骑毛驴
因为马跨不上去
洗澡都洗泡泡浴
因为可以玩玩具
我有颗善良的心
都只穿假牛皮
喔跌倒时尽量不压草皮
Wu~
枪口它没长眼睛
我曾经答应上帝
除非是万不得已
我尽量射橡皮筋
老板先来杯奶昔
要逃命前请你
顺便喂喂我那只小毛驴
Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的
Wu~&lt;/p&gt;

&lt;p&gt;Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的&lt;/p&gt;
</description>
				<pubDate>Thu, 19 Sep 2013 00:00:00 +0800</pubDate>
				<link>/2013/09/19/Mybirthday.html</link>
				<guid isPermaLink="true">/2013/09/19/Mybirthday.html</guid>
			</item>
		
			<item>
				<title>c语言学习-内存</title>
        <description>&lt;h2&gt;运行时的数据结构&lt;/h2&gt;

&lt;h3&gt;分段&lt;/h3&gt;

&lt;p&gt;在*nix中，我们使用gcc不用任何参数的时候，输出的二进制可执行文件总是a.out。他是&#39;assembler output&#39;的缩写，由链接器输出。目标文件和可执行文件一般都有特定的格式，常用的linux往往是使用ELF(Extensible and Linking Format)格式，可以通过&lt;code&gt;man a.out&lt;/code&gt;查看它的详细信息。这些不同的格式都具有同一个概念，那就是断(segments/section)。它是ELF文件的最小组成单位，但是我们要跟x86里面的分段（内存管理方式）区分开来。linux中可以用一个size命令来查看一个可执行文件的分段大小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hj@dantangfan:~/code/c_code$ size test
   text    data     bss     dec     hex filename
   1259     576       8    1843     733 test
hj@dantangfan:~/code/c_code$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;众所周知的是编译后的a.out从高地址到低地址分别有&lt;code&gt;其他内容--&amp;gt;BSS段所需大小--&amp;gt;数据段--&amp;gt;文本段&lt;/code&gt;。值得注意的是BSS段只保存没有值的变量，所以他事实上是不需要保存这些变量的映像的。运行时所需要的BSS段的大小记录在目标文件中，但BSS并不占目标文件任何空间（除了记录大小所需要的空间）。&lt;/p&gt;

&lt;p&gt;段可以方便的映射到链接器在运行时可以直接载入的对象中，段在正在执行的程序中是一块内存区域，每个区域都有特定的目的。文本段包含程序的指令，连接器把指令直接从文本拷贝到内存中，在典型的情况下，程序的文本无论是内容还是大小都不会改变。&lt;/p&gt;

&lt;h3&gt;进程空间&lt;/h3&gt;

&lt;p&gt;又一个中所周知的事实是程序在内存中运行交进程，进程的地址空间从高到低可以简单概括成&lt;code&gt;堆栈--&amp;gt;空洞--&amp;gt;BSS（未经初始化的数据）--&amp;gt;数据段（经过初始化的数据）--&amp;gt;文本段（指令）--&amp;gt;未映射地区&lt;/code&gt;。数据段包含了全局变量和静态变量以及他们的值，BSS段的大小可以直接从可执行文件中得到，然后链接器得到这个大小的内存块跟在数据段后，堆栈段主要保存局部变量、临时变量、传递的参数等等。值得注意的是虚拟地址空间的最低部分是没有被映射的，也就是说啊位于进程的地址空间，但并没有赋予物理地址，所以任何对其引用都是非法的，他通常从地址的起始（0地址）到数k字节，用于捕捉使用空指针和小整型的指针使用内存的ingrain。&lt;/p&gt;

&lt;h3&gt;运行时数据结构&lt;/h3&gt;

&lt;p&gt;有很多中数据结构存在：堆栈、活动记录、数据、堆等&lt;/p&gt;

&lt;h4&gt;堆栈段&lt;/h4&gt;

&lt;p&gt;主要有三个用途，两个跟函数有关，一个跟表达式计算有关。指针sp通常指向堆栈当前的顶部位置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆栈位函数内部声明的局部变量（自动变量）提供存储空间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进行函数调用的时候，堆栈存储与此有关的一些维护信息（活动记录），这些信息包含函数调用地址（即当所有调用函数结束之后应该跳回的地址）、任何不适合装入寄存器的参数、寄存器值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;堆栈也可以用来当成暂时存储区（表达式计算）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;过程活动记录&lt;/h4&gt;

&lt;p&gt;我们需要知道的是过程活动记录是一种数据结构，用于支持过程调用，并记录调用结束霍返回调用点所需要的全部信息。运行时系统维护一个指针fp，用于提示活动堆栈结构，他的值是最靠井堆栈顶部的过程活动记录的地址。&lt;/p&gt;

&lt;h2&gt;内存问题&lt;/h2&gt;

&lt;h3&gt;80x86内存模型&lt;/h3&gt;

&lt;p&gt;在Intel80x86内存模型中，分段是很重要的设计，各个处理器的地址空间不同，但他们都被分割成64KB为单位的区域，这样每一个区域的简称就叫段。&lt;/p&gt;

&lt;p&gt;作为80x86内存模型最基本的形式，8086中的段是一块64KB的内存区域，由一个段寄存器指向。内存地址的行程经过是：取得段寄存器值左移四位，然后再加上偏移地址，就形成了一个20位的寻址空间（1M）。8086中常见的寄存器是CS（代码寄存器）、DS（数据寄存器）、SS（堆栈寄存器）和ES（附加段）。&lt;/p&gt;

&lt;h3&gt;虚拟内存&lt;/h3&gt;

&lt;p&gt;让程序受安装在机器上的物理内存限制是很不方便的，于是就有了虚拟内存————在任意给定时刻，程序实际需要使用的虚拟内存区段的内容就被载入物理内存中，当物理内存中的数据有一段时间未被使用，它就可能被注意到硬盘中，节省下来的物理内存空间用于载入需要使用的其他数据。虚拟内存是对多成存储进程扩充，使用磁盘而不是贮存来保存运行进程的映像。&lt;/p&gt;

&lt;p&gt;虚拟内存通过‘分页’的实行组织。页就是操作系统在磁盘和内存之间移动的单位，一般为几K字节。当内存的映像在磁盘和物理内存间来回移动时，成他们是page in（移入页）/page out（移出页）。&lt;/p&gt;

&lt;p&gt;与进程有关的所有内存都将被系统使用，如果进程不马上运行，操作系统可以暂时取回所有分配给他的内存资源，将该进程所有的信息都备份到磁盘上，这个进程就被‘换出’。在磁盘中有一个特殊的‘交换区’，用于保存从内存中换出的进程。一台及其中，交换区的大小一般是物理内存的几倍，而不是网上常说的和内存一样大就行。&lt;/p&gt;

&lt;p&gt;进程只能操作位于物理内存中的页面，当进程引用一个不在物理内存中的页面的时候，MMU（内存管理单元）就会产生一个页错误。&lt;/p&gt;

&lt;h3&gt;Cache&lt;/h3&gt;

&lt;p&gt;Cache是位于内存和CPU之间的一种极快的存储缓冲区。Cache 操作的速度与系统周期时间相同，他包含一个地址表以及他们的内容。随着处理器不断引用新的内处地址，Cache的地址列表也一直出于变化中。所有对内存的读取和写入操作都要经过Cache。当处理器需要从一个特定地址提取数据时，这个请求先递交给Cache，如果数据已经存在在Cache中，他就可以直接被提取。否则，Cache像内存传递这个请求，于是就需要进程缓慢的访问内存的操作。内存读取数据以行为单位，读取的同时也装入到Cache中。&lt;/p&gt;

&lt;p&gt;如果你的程序很怪异，以至于每次都没办法命中Cache，那么你的程序的性能比不使用Cache 还要差。&lt;/p&gt;

&lt;p&gt;常用的Cache是写回法(write back cache)：当第一次写入时，只需要对Cache写入。如果已经写过的Cache再次写，就将Cache先写回内存。&lt;/p&gt;

&lt;h3&gt;堆&lt;/h3&gt;

&lt;p&gt;堆用于动态分配内存（**lloc），堆中的所有数据都是匿名的，必须通过指针才能访问。被动态分配的内存总是通过&lt;code&gt;对齐&lt;/code&gt;的，以适合及其上最大尺寸的原子访问，一个malloc请求申请的内存个大小位方便一般都被圆整位2的次方。free回收的内存可以重新使用，但是这个时候是没有返回给操作系统的。&lt;/p&gt;

&lt;h2&gt;常见错误&lt;/h2&gt;

&lt;h3&gt;内存泄漏&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;释放或者改写仍在使用的内存叫内存损坏&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;未释放不再使用的内存交内存泄漏&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;内存泄漏需要我们十分谨慎的使用malloc和free&lt;/p&gt;

&lt;h3&gt;总线错误(bus error)&lt;/h3&gt;

&lt;p&gt;总线错误几乎都是由未对齐的内存的读写引起。之所以称之为总线错误，是因为在出现未对齐的内存访问请求时，被阻塞的组件就是地址总线，对齐的意思是数据像只能存储在地址是数据像大小的整数倍的内存位置上。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;union{
    char a[10];
    int i;
}u;
int *p = (int *)&amp;amp;(u.a[1]);
*p = 17;//总线错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里尽管*p的值是一个ASCII的数字，但是它实际是指的一个字符，存储位置是一个字节，所以现在修改的时候直接改成17,这是一个int类型整数，占据4个字节，于是就出现了总线错误。&lt;/p&gt;

&lt;h3&gt;段错误(segmentation fault)&lt;/h3&gt;

&lt;p&gt;段错误更常见，可以导致段错误的原因往往有以下几种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解除引用一个包含非法值的指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解除引用一个空指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在未得到正确的权限时进行访问&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用完了堆栈或者堆空间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;长用的解决方法是在free(P)之后再补充P=NULL。&lt;/p&gt;
</description>
				<pubDate>Mon, 15 Jul 2013 00:00:00 +0800</pubDate>
				<link>/2013/07/15/c-memory.html</link>
				<guid isPermaLink="true">/2013/07/15/c-memory.html</guid>
			</item>
		
			<item>
				<title>C 语言编码风格和标准</title>
        <description>&lt;h2&gt;0.摘要&lt;/h2&gt;

&lt;p&gt;本文根据&lt;a href=&quot;http://code.google.com/p/recommended-c-style-and-coding-standards-cn/&quot;&gt;google code&lt;/a&gt;翻译自&lt;a href=&quot;https://www.doc.ic.ac.uk/lab/cplus/cstyle.html&quot;&gt;《Recommended C Style and Coding Standards》&lt;/a&gt;整理&lt;/p&gt;

&lt;h3&gt;作者信息:&lt;/h3&gt;

&lt;p&gt;L.W. Cannon (Bell Labs)&lt;br&gt;
R.A. Elliott (Bell Labs)&lt;br&gt;
L.W. Kirchhoff (Bell Labs)&lt;br&gt;
J.H. Miller (Bell Labs)&lt;br&gt;
J.M. Milner (Bell Labs)&lt;br&gt;
R.W. Mitze (Bell Labs)&lt;br&gt;
E.P. Schan (Bell Labs)&lt;br&gt;
N.O. Whittington (Bell Labs)&lt;br&gt;
Henry Spencer (Zoology Computer Systems, University of Toronto)&lt;br&gt;
David Keppel (EECS, UC Berkeley, CS&amp;amp;E, University of Washington)&lt;br&gt;
Mark Brader (SoftQuad? Incorporated, Toronto)&lt;/p&gt;

&lt;p&gt;本文是《Indian Hill C Style and Coding Standards》的更新版本,上面提到的最后三位作者对其进行了修改。本文主要介绍了一种C程序的推荐编码标准,内容着重于讲述编码风格,而不是功能组织(Functional Organization)。&lt;/p&gt;

&lt;h2&gt;1.简介&lt;/h2&gt;

&lt;p&gt;本文档修改于 AT&amp;amp;T Indian Hill 实验室内部成立的一个委员会的一份文档,旨在于建立一套通用的编码标准并推荐给 Indian Hill 社区。&lt;/p&gt;

&lt;p&gt;本文主要讲述编码风格。良好的风格能够鼓励大家形成一致的代码布局,提高代码可移植性并且减少错误数量。&lt;/p&gt;

&lt;p&gt;本文不关注功能组织,或是一些诸如如何使用 goto 的一般话题。我们尝试将之前的有关C代码风格的文档整合到一套统一的标准中,这套标准将适合于任何使用C语言的工程,当然还是会有部分内容是针对一些特定系统的。另外不可避免地是这些标准仍然无法覆盖到所有情况.经验以及广泛的评价十分重要,遇到特殊情况时,大家应该咨询有经验的C程序员,或者查看那些经验丰富的C程序员们的代码(最好遵循这些规则)。&lt;/p&gt;

&lt;p&gt;本文中的标准本身并不是必需的,但个别机构或团体可能部分或全部采用该标准作为程序验收的一部分。因此,在你的机构中其他人很可能以一种相似的风格编码。最终,这些标准的目的是提高可移植性,减少维护工作,尤其是提高代码的清晰度。这里很多风格的选择都有些许武断。混合的编码风格比糟糕的编码风格更难于维护,所以当变更现有代码时,最好是保持与现有代码风格一致,而不是盲目地遵循本文档中的规则。&lt;/p&gt;

&lt;p&gt;&quot;清晰的是专业的;不清晰的则是外行的&quot; — Sir Ernest Gowers&lt;/p&gt;

&lt;h2&gt;2.文件组织&lt;/h2&gt;

&lt;p&gt;一个文件包含的各个部分应该用若干个空行分隔。虽然对源文件没有最大长度限制,但超过1000行的文件处理起来非常不方便。编辑器很可能没有足够 的临时空间来编辑这个文件,编译过程也会因此变得十分缓慢。与回滚到前面所花费的时间相比,那些仅仅呈现了极少量信息的多行星号是不值得的,我们 不鼓励使用。超过79列的行无法被所有的终端都很好地处理,应该尽可能的避免使用。过长的行会导致过深的缩进,这常常是一种代码组织不善的症状。&lt;/p&gt;

&lt;h3&gt;2.1文件命名惯例&lt;/h3&gt;

&lt;p&gt;文件名由一个基础名、一个可选的句号以及后缀组成。名字的第一个字符应该是一个字母,并且所有字符(除了句号)都应该是小写的字母和数字。基础名 应该由八个或更少的字符组成,后缀应该由三个或更少的字符组成(四个,如果你包含句号的话)。这些规则对程序文件以及程序使用和产生的默认文件都 适用(例如,&quot;rogue.sav&quot;)。&lt;/p&gt;

&lt;p&gt;一些编译器和工具要求文件名符合特定的后缀命名约定。下面是后缀命名要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C 源文件的名字必须以.c 结尾&lt;/li&gt;
&lt;li&gt;汇编源文件的名字必须以.s 结尾&lt;/li&gt;
&lt;li&gt;我们普遍遵循以下命名约定:&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;可重定位目标文件名以.o 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;头文件名以.h 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;在多语言环境中一个可供选择的更好的约定是用语言类型和.h 共同作为后缀(例如,&quot;foo.c.h&quot; 或 &quot;foo.ch&quot;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;Yacc 源文件名以.y 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;Lex 源文件名以.l 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;C++使用编译器相关的后缀约定,包括.c,..c,.cc,.c.c 以及.C。由于大多 C 代码也是 C++代码,因此这里并没有一个明确的方案。&lt;/p&gt;

&lt;p&gt;此外,我们一般约定使用&quot;Makefile&quot;(而不是&quot;makefile&quot;)作为 make(对于那些支持 make 的系统)工具的控制文件,并且使 用&quot;README&quot;作为简要描述目录内容或目录树的文件。&lt;/p&gt;

&lt;h3&gt;2.2 程序文件&lt;/h3&gt;

&lt;p&gt;下面是一个程序文件各个组成部分的推荐排列顺序:&lt;/p&gt;

&lt;p&gt;文件的第一部分是一个序,用于说明该文件中的内容是什么。对文件中的对象(无论它们是函数,外部数据声明或定义,或是其他一些东西)用途的描述比 一个对象名字列表更加有用。这个序可选择地包含作者信息、修订控制信息以及参考资料等。&lt;/p&gt;

&lt;p&gt;接下来是所有被包含的头文件。如果某个头文件被包含的理由不是那么显而易见,我们需要通过增加注释说明原因。大多数情况下,类似 stdio.h 这 样的系统头文件应该被放在用户自定义头文件的前面。&lt;/p&gt;

&lt;p&gt;接下来是那些用于该文件的 defines 和 typedefs。一个常规的顺序是先写常量宏、再写函数宏,最后是 typedefs 和枚举 (enums)定义。&lt;/p&gt;

&lt;p&gt;接下来是全局(外部)数据声明,通常的顺序如下:外部变量,非静态(non-static)全局变量,静态全局变量。如果一组定义被用于部分特定 全局数据(如一个标志字),那么这些定义应该被放在对应数据声明后或嵌入到结构体声明中,并将这些定义缩进到其应用的声明的第一个关键字的下一个 层次(译注:实在没有搞懂后面这句的含义)。&lt;/p&gt;

&lt;p&gt;最后是函数,函数应该以一种有意义的顺序排列。相似的函数应该放在一起。与深度优先(函数定义尽可能在他们的调用者前后)相比,我们应该首选广度 优先方法(抽象层次相似的函数放在一起)。这里需要相当多的判断。如果定义大量本质上无关的工具函数,可考虑按字母表顺序排列。&lt;/p&gt;

&lt;h3&gt;2.3 头文件&lt;/h3&gt;

&lt;p&gt;头文件是那些在编译之前由 C 预处理器包含在其他文件中的文件。诸如 stdio.h 的一些头文件被定义在系统级别,所有使用标准 I/O 库的程序必须 包含它们。头文件还用来包含数据声明和定义,这些数据不止一个程序需要。头文件应该按照功能组织,例如,独立子系统的声明应该放到独立的头文件中。如果一组声明在代码从一种机器移植到另外一种机器时变动的可能性很大,那么这些声明也应该被放在独立的头文件中。&lt;/p&gt;

&lt;p&gt;避免私有头文件的名字与标准库头文件的名字一样。下面语句:&lt;/p&gt;

&lt;p&gt;*#include &quot;math.h&quot;&lt;/p&gt;

&lt;p&gt;当预期的头文件在当前目录下没有找到时,它将会包含标准库中的 math 头文件。如果这的确是你所期望发生的,那么请加上注释。包含头文件时不要使 用绝对路径。当从标准位置获取头文件时,请使用&lt;name&gt;包含头文件;或相对于当前路径定义它们。C 编译器的&quot;include- path&quot;选项(在许多系统中为-l)是处理扩展私有库头文件的最好方法,它允许在不改变源码文件的情况下重新组织目录结构。&lt;/p&gt;

&lt;p&gt;声明了函数或外部变量的头文件应该被那些定义了这些函数和变量的文件所包含。这样一来,编译器就可以做类型检查了,并且外部声明将总是与定义保持 一致。&lt;/p&gt;

&lt;p&gt;在头文件中定义变量往往是个糟糕的想法,它经常是一个在文件间对代码进行低劣划分的症状。此外,在一次编译中,像 typedef 和经过初始化的数 据定义无法被编译器看到两次。在一些系统中,重复的没有使用 extern 关键字修饰的未初始化定义也会导致问题。当头文件嵌套时,会出现重复的声 明,这将导致编译失败。&lt;/p&gt;

&lt;p&gt;头文件不应该嵌套。一个头文件的序应该描述其使用的其他被包含的头文件的实用特性。在极特殊情况下,当大量头文件需要被包含在多个不同的源文件中 时,可以被接受的做法是将公共的头文件包含在一个单独的头文件中。&lt;/p&gt;

&lt;p&gt;一个通用的做法是将下面这段代码加入到每个头文件中以防止头文件被意外多次包含。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifndef EXAMPLE_H
#define EXAMPLE_H
...
/* body of example.h file */
#endif /* EXAMPLE_H */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们不应该对这种避免多次包含的机制产生依赖,特别是不应该因此而嵌套包含头文件。&lt;/p&gt;

&lt;h3&gt;2.4 其他文件&lt;/h3&gt;

&lt;p&gt;还有一个惯例就是编写一个名为&quot;README&quot;的文件,用于描述程序的整体情况以及问题。例如,我们经常在 README 包含程序所使用的条件编译 选项列表以及相关说明,还可以包含机器无关的文件列表等。&lt;/p&gt;

&lt;h2&gt;3. 声明&lt;/h2&gt;

&lt;p&gt;全局声明应该从第一列开始。在所有外部数据声明的前面都应该放置 extern 关键字。如果一个外部变量是一个在定义时大小确定的数组,那么这个数 组界限必须在 extern 声明时显示指出,除非数组的大小与数组本身编码在一起了(例如,一个总是以0结尾的只读字符数组)。重复声明数组大小对 于一些使用他人编写的代码的人特别有益。&lt;/p&gt;

&lt;p&gt;指针修饰符*应该与变量名在一起,而不是与类型在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *s, *t, *u;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char* s, t, u;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后者是错误的,因为实际上 t 和 u 并未如预期那样被声明为指针。不相关的声明,即使是相同类型的,也应该独立占据一行。我们应该对声明对象的角色进行注释,不过当常量名本身足以说明角色时,使用#define 定义的常量列表则不需要注释。通常多行变量名、值与注释使用相同缩进,使得他们在一列直线上。尽量使用 Tab 字符而不是空格。结构体和联合体的声明时,每个元素应该单独占据一行,并附带一条注释。{应该与结构体的 tag 名放在同一行,}应该放在声明结尾的第一列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct boat {
int
 wllength; /* water line length in meters */
int type; /* see below */
long sailarea; /* sail area in square mm */
};
/* defines for boat.type */
#define KETCH (1)
#define YAWL (2)
#define SLOOP (3)
#define SQRIG (4)
#define MOTOR (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些 defines 有时放在结构体内 type 声明的后面,并使用足够的 tab 缩进到结构体成员成员的下一级。如果这些实际值不那么重要的话,使用 enum 会更好。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;enum bt { KETCH=1, YAWL, SLOOP, SQRIG, MOTOR };
struct boat {
int wllength; /* water line length in meters */
enum bt type;
long sailarea;
};
/* what kind of boat */
/* sail area in square mm */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何初值重要的变量都应该被显式地初始化,或者至少应该添加注释,说明依赖 C 的默认初始值0。空初始化&quot;{}&quot;应该永远不被使用。结构体初始化应 该用大括号完全括起来。用于初始化长整型(long)的常量应该使用显式长度。使用大写字母,例如2l 看起来更像21,数字二十一。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int x = 1;
char *msg = &quot;message&quot;;
struct boat winner[] = {
    { 40, YAWL, 6000000L },
    { 28, MOTOR, 0L },
    { 0 },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个文件不是独立程序,而是某个工程整体的一部分,那么我们应该最大化的利用 static 关键字,使得函数和变量对于单个文件来说是局部范畴 的。只有在有清晰需求且无法通过其他方式实现的特殊情况时,我们才允许变量被其他文件访问。这种情况下应该使用注释明确告知使用了其他文件中的变 量;注释应该说明其他文件的名字。如果你的调试器遮蔽了你需要在调试阶段查看的静态对象,那么可以将这些变量声明为 STATIC,并根据需要决定 是否#define STATIC。&lt;/p&gt;

&lt;p&gt;最重要的类型应该被 typedef,即使他们只是整型,因为独立的名字使得程序更加易读(如果只有很少的几个 integer 的 typedef)。 结构体在声明时应该被 typedef。保持结构体标志的名字与 typedef 后的名字相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef struct splodge_t {
int sp_count;
char *sp_name, *sp_alias;
} splodge_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总是声明函数的返回类型。如果函数原型可用,那就使用它。一个常见的错误就是忽略那些返回 double的外部数学函数声明。那样的话,编译器就会 假定这些函数的返回值为一个整型数,并且将 bit 位逐一尽职尽责的注意转换为一个浮点数(无意义)。&lt;/p&gt;

&lt;p&gt;&quot;C 语言的观点之一是程序员永远是对的&quot; — Michael DeCorte&lt;/p&gt;

&lt;h2&gt;4. 函数声明&lt;/h2&gt;

&lt;p&gt;每个函数前面应该放置一段块注释,概要描述该函数做什么以及(如果不是很清晰)如何使用该函数。重要的设计决策讨论以及副作用说明也适合放在注释 中。避免提供那些代码本身可以清晰提供的信息。&lt;/p&gt;

&lt;p&gt;函数的返回类型应该单独占据一行,(可选的)缩进一个级别。不用使用默认返回类型 int;如果函数没有返回值,那么将返回类型声明为 void。如 果返回值需要大段详细的说明,可以在函数之前的注释中描述;否则可以在同一行中对返回类型进行注释。函数名(以及形式参数列表)应该被单独放在一 行,从第一列开始。目的(返回值)参数一般放在第一个参数位置(从左面开始)。所有形式参数声明、局部声明以及函数体中的代码都应该缩进一级。函 数体的开始括号应该单独一行,放在开始处的第一列。&lt;/p&gt;

&lt;p&gt;每个参数都应该被声明(不要使用默认类型 int)。通常函数中每个变量的角色都应该被描述清楚,我们可以在函数注释中描述,或如果每个声明单独一 行,我们可以将注释放在同一行上。像循环计数器&quot;i&quot;,字符串指针&quot;s&quot;以及用于标识字符的整数类型&quot;c&quot;这些简单变量都无需注释。如果一组函数 都拥有一个相似的参数或局部变量,那么在所有函数中使用同一个名字来标识这个变量是很有益处的(相反,避免在相关函数中使用一个名字标识用途不同 的变量)。不同函数中的相似参数还应该放在各个参数列表中的相同位置。&lt;/p&gt;

&lt;p&gt;参数和局部变量的注释应该统一缩进以排成一列。局部变量声明应用一个空行与函数语句分隔开来。当你使用或声明变长参数的函数时要小心。目前在 C 中尚没有真正可移植的方式处理变长参数。最好设计一个使用固定个数参数的接口。如果一定要使用变 长参数,请使用标准库中的宏来声明具有变长参数的函数。&lt;/p&gt;

&lt;p&gt;如果函数使用了在文件中没有进行全局声明的外部变量(或函数),我们应该在函数体内部使用 extern关键字单独对这些变量进行声明。&lt;/p&gt;

&lt;p&gt;避免局部声明覆盖高级别的声明。尤其是,局部变量不应该在嵌套代码块中被重声明。虽然这在 C中是合法的,但是当使用-h 选项时,潜在的冲突可能性 足以让 lint 工具发出抱怨之声。&lt;/p&gt;

&lt;h2&gt;5. 空白&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int i;main(){for(;i[&quot;]
o, world!\n&quot;,&#39;/&#39;/&#39;/&#39;));}read(j,i,p){write(j/p+p,i—j,i/i);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- 不光彩的事情,模糊 C 代码大赛,1984 年。作者要求匿名。&lt;/p&gt;

&lt;p&gt;通常情况下,请使用纵向和横向的空白。缩进和空格应该反映代码的块结构。例如,在一个函数定义与下一个函数的注释之间,至少应该有两行空白。&lt;/p&gt;

&lt;p&gt;如果一个条件分支语句过长,那就应该将它拆分成若干单独的行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (foo-&amp;gt;next==NULL &amp;amp;&amp;amp; totalcount&amp;lt;needed &amp;amp;&amp;amp; needed&amp;lt;=MAX_ALLOT
&amp;amp;&amp;amp; server_active(current_input)) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许下面这样更好&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (foo-&amp;gt;next == NULL
&amp;amp;&amp;amp; totalcount &amp;lt; needed &amp;amp;&amp;amp; needed &amp;lt;= MAX_ALLOT
&amp;amp;&amp;amp; server_active(current_input))
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地,复杂的循环条件也应该被拆分为不同行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (curr = *listp, trail = listp;
curr != NULL;
trail = &amp;amp;(curr-&amp;gt;next), curr = curr-&amp;gt;next )
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他复杂的表达式,尤其是那些使用了?:操作符的表达式,最好也能拆分成多行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;c = (a == b)
? d + f(a)
: f(b) – d;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当关键字后面有放在括号内的表达式时,应该使用空格将关键字与左括号分隔(sizeof 操作符是个例外)。在参数列表中,我们也应该使用空格显式 的将各个参数隔开。然而,带有参数的宏定义一定不能在名字与左括号间插入空格,否则 C 预编译器将无法识别后面的参数列表。&lt;/p&gt;

&lt;h2&gt;6. 例子&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/*
* Determine if the sky is blue by checking that it isn&#39;t night.
* CAVEAT: Only sometimes right.
 May return TRUE when the answer
* is FALSE.
 Consider clouds, eclipses, short days.
* NOTE: Uses &#39;hour&#39; from &#39;hightime.c&#39;.
 Returns &#39;int&#39; for
* compatibility with the old version.
*/
int
 /* true or false */
skyblue()
{
extern int hour;
 /* current hour of the day */
return (hour &amp;gt;= MORNING &amp;amp;&amp;amp; hour &amp;lt;= EVENING);
}
/*
* Find the last element in the linked list
* pointed to by nodep and return a pointer to it.
* Return NULL if there is no last element.
*/
node_t *
tail(nodep)
node_t
 *nodep;
 /* pointer to head of list */
{
register node_t *np; /* advances to NULL */
register node_t *lp; /* follows one behind np */
if (nodep == NULL)
return (NULL);
for (np = lp = nodep; np != NULL; lp = np, np = np-&amp;gt;next)
;
 /* VOID */
return (lp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;7. 简单语句&lt;/h2&gt;

&lt;p&gt;每行只应该有一条语句,除非多条语句关联特别紧密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;case FOO:
 oogle (zork);
 boogle (zork);
 break;
case BAR:
 oogle (bork);
 boogle (zork);
 break;
case BAZ:
 oogle (gork);
 boogle (bork);
 break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for 或 while 循环语句的空体应该单独放在一行并加上注释,这样可以清晰的看出空体是有意而为,并非遗漏代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while (*dest++ = *src++)
;
 /* VOID */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要对非零表达式进行默认测试,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (f() != FAIL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比下面的代码更好&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (f())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使 FAIL 的值可能为0(在 C 中0被认为是假)。当后续有人决定使用-1替代0作为失败返回值时,一个显式的测试将解决你的问题。即使比较的值 永远不会改变,我们也应该使用显式的比较;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (!(bufsize % sizeof(int)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该被写成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if ((bufsize % sizeof(int)) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以反映这个测试的数值(非布尔)本质。一个常见的错误点是使用 strcmp 测试字符串是否相同,这个测试的结果永远不应该被放弃。比较好的 方法是定义一个宏 STREQ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define STREQ(a, b) (strcmp((a), (b)) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对谓词或满足下面约束的表达式,非零测试经常被放弃:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0表示假,其他都为真。&lt;/li&gt;
&lt;li&gt;通过其命名可以看出返回真是显而易见的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;用 isvalid 或 valid 称呼一个谓词,不要用 checkvalid。&lt;/p&gt;

&lt;p&gt;一个非常常见的实践就是在一个全局头文件中声明一个布尔类型&quot;bool&quot;。这个特殊的名字可以极大地提高代码可读性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef int bool;
#define FALSE 0
#define TRUE 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef enum { NO=0, YES } bool;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即便有了这些声明,也不要检查一个布尔值与1(TRUE,YES 等)的相当性;可用测试与0(FALSE,NO 等)的不等性替代。绝大多数函数都 可以保证为假的时候返回0,但为真的时候只返回非零。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (func() == TRUE) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必须被写成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (func() != FALSE) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果可能的话,最好为函数/变量重命名或者重写这个表达式,这样就可以显而易见的知道其含义,而无需再与 true 或 false 比较了(例如,重命 名为 isvalid())。&lt;/p&gt;

&lt;p&gt;嵌入赋值语句也有用武之地。在一些结构中,在没有降低代码可读性的前提下,没有比这更好的方式来实现这个结果了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while ((c = getchar()) != EOF) {
    process the character
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;++和–操作符可算作是赋值语句。这样,为了某些意图,实现带有副作用的功能。使用嵌入赋值语句也可能提高运行时的性能。不过,大家应该在提高 的性能与下降的可维护性之间做好权衡。当在一些人为的地方使用嵌入赋值语句时,这种情况会发生,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;a = b + c;
d = a + r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不应该被下面代码替代:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;d = (a = b + c) + r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使后者可能节省一个计算周期。在长期运行时,由于优化器渐获成熟,两者的运行时间差距将下降,而两者在维护性方面的差异将提高,因为人类的记忆 会随着时间的流逝而衰退。&lt;/p&gt;

&lt;p&gt;在任何结构良好的代码中, goto 语句都应该保守地使用。使用 goto 带来好处最大的地方是从 switch、for 和 while 多层嵌套中跳出, 但这样做的需求也暗示了代码的内层结构应该被抽取出来放到一个单独的返回值为成功或失败的函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (...) {
    while (...) {
        ...
    if (disaster)
        goto error;
    }
}
...
error:
    clean up the mess
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要 goto 时候,其对应的标签应该被放在单独一行,并且后续的代码缩进一级。使用 goto 语句时应该增加注释(可能放在代码块的头)以说明它 的功用和目的。 continue 应该保守地使用,并且尽可能靠近循环的顶部。Break 的麻烦比较少。&lt;/p&gt;

&lt;p&gt;非原型函数的参数有时需要被显式做类型提升。例如,如果函数期望一个32bit 的长整型,但却被传入一个16bit 的整型数,可能会导致函数栈不 对齐。指针,整型和浮点值都会发生此问题。&lt;/p&gt;

&lt;h2&gt;8. 复合语句&lt;/h2&gt;

&lt;p&gt;复合语句是一个由括号括起来的语句列表。有许多种常见的括号格式化方式。如果你有一个本地标准,那请你与本地标准保持一致,或选择一个标准,并持 续地使用它。在编辑别人的代码时,始终使用那些代码中使用的样式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;control {
    statement;
    statement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的风格被称为&quot;K&amp;amp;R 风格&quot;,如果你还没有找到一个自己喜欢的风格,那么可以优先考虑这个风格。在 K&amp;amp;R 风格中, if- else 语句中的 else 部分以及 do-while 语句中的 while 部分应该与结尾大括号在同一行中。而其他大部分风格中,大括号都是单独占据 一行的。&lt;/p&gt;

&lt;p&gt;当一个代码块拥有多个标签时,每个标签应该单独放在一行上。必须为 C 语言的 switch 语句的fall-through 特性(即在代码段与下一个 case 语句之前间没有 break)增加注释以利于后期更好的维护。最好是 lint 风格的注释/指示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;switch (expr) {
    case ABC:
    case DEF:
    statement;
    break;
    case UVW:
    statement;
    /*FALLTHROUGH*/
    case XYZ:
    statement;
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里,最后那个 break 是不必要的,但却是必须的,因为如果后续另外一个 case 添加到最后一个 case的后面时,它将阻止 fall- through 错误的发生。如果使用 default case,那么应该该 default case 放在最后,且不需要 break,如果它是最后一个 case。&lt;/p&gt;

&lt;p&gt;一旦一个 if-else 语句在 if 或 else 段中包含一个复合语句,if 和 else 两个段都应该用括号括上(称为全括号(fully bracketed)语法)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (expr) {
    statement;
} else {
    statement;
    statement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在如下面那样的没有第二个 else 的 if-if-else 语句序列里,括号也是不必可少的。如果 ex1后面的括号被省略,编译器解析将出错:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (ex1) {
    if (ex2) {
    funca();
    }
} else {
    funcb();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个带 else if 的 if-else 语句在书写上应该让 else 条件左对齐。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (STREQ (reply, &quot;yes&quot;)) {
    statements for yes
    ...
} else if (STREQ (reply, &quot;no&quot;)) {
    ...
} else if (STREQ (reply, &quot;maybe&quot;)) {
    ...
} else {
    statements for default
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种格式看起来像一个通用的 switch 语句,并且缩进反映了在这些候选语句间的精确切换,而不是嵌套的语句。&lt;/p&gt;

&lt;p&gt;Do-while 循环总是使用括号将循环体括上。&lt;/p&gt;

&lt;p&gt;下面的代码非常危险:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifdef CIRCUIT
#define CLOSE_CIRCUIT(circno) { close_circ(circno); }
#else
#define CLOSE_CIRCUIT(circno)
#endif
...
if (expr)
    statement;
else
    CLOSE_CIRCUIT(x)
++i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意,在 CIRCUIT 没有定义的系统上,语句++i 仅仅在 expr 是假的时候获得执行。这个例子指出宏用大写命名的价值,以及让代码完全括号化 的价值。&lt;/p&gt;

&lt;p&gt;有些时候,通过 break,continue,goto 或 return,if 可以无条件地进行控制转移。else 应该是隐式的,并且代码不应该缩 进。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (level &amp;gt; limit)
    return (OVERFLOW)
normal();
return (level);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;平坦的缩进告诉读者布尔测试在密封块的其他部分是保持不变的。&lt;/p&gt;

&lt;h2&gt;9. 操作符&lt;/h2&gt;

&lt;p&gt;一元操作符不应该与其唯一的操作数分开。通常,所有其他二元操作符都应该使用空白与其操作树分隔开,但&#39;.&#39;和&#39;-&gt;&#39;例外。当遇到复杂表 达式的时候我们需要做出一些判断。如果内层操作符没有使用空白分隔而外层使用了,那么表达式也许会更清晰些。&lt;/p&gt;

&lt;p&gt;如果你认为一个表达式很难于阅读,可以考虑将这个表达式拆分为多行。在接近中断点的最低优先级操作符处拆分是最好的选择。由于 C 具有一些想不到的 优先级规则,混合使用操作符的表达式应该使用括号括上。但是过多的括号也会使得代码可读性变差,因为人类不擅长做括号匹配。&lt;/p&gt;

&lt;p&gt;二元逗号操作符也会被使用到,但通常我们应该避免使用它。逗号操作符的最大用途是提供多元初始化或操作,比如在 for 循环语句中。复杂表达式,例 如那些使用了嵌套三元?:操作符的表达式,可能引起困惑,并且应该尽可能的避免使用。三元操作符和逗号操作符在一些使用宏的地方很有用,诸如getchar。在三元操作符?:前的逻辑表达式的操作数应该被括起来,并且两个子表达式的返回值应该是相同类型。&lt;/p&gt;

&lt;h2&gt;10. 命名约定&lt;/h2&gt;

&lt;p&gt;毫无疑问,每个独立的工程都有一套自己的命名约定,不过仍然有一些通用的规则值得参考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为系统用途保留以下划线开头或下划线结尾的名字,并且这些名字不应该被用在任何用户自定义的名字中。大多数系统使用这些名字用于用户不应 该也不需知道的名字中。如果你一定要使用你自己私有的标识符,可以用标识它们归属的包的字母作为开头。&lt;/li&gt;
&lt;li&gt;&lt;h1&gt;define 定义的常量名字应该全部大写。&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;Enum 常量应该大写或全部大写。&lt;/li&gt;
&lt;li&gt;函数名、typedef 名,变量名以及结构体、联合体与枚举标志的名字应该用小写字母。&lt;/li&gt;
&lt;li&gt;很多&quot;宏函数&quot;都是全部大写的。一些宏(诸如 getchar 和 putchar)使用小写字母命名,这事因为&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;他们可能被当成函数使用。只有在宏的行为类似一 个函数调用时才允许小写命名的宏,也就是说它们只对其参数进行一次求值,并且不会给具名形式参数赋值。有些时候我们无法编写出一个具有函数行为的 宏,即使其参数也只是求值一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免在同一情形下使用不同命名方式,比如 foo 和 Foo。同样避免 foobar 和 foo_bar 这种方式。需要考虑这样所带来的困惑。&lt;/li&gt;
&lt;li&gt;同样,避免使用看起来相似的名字。在很多终端以及打印设备上,&#39;I&#39;、&#39;1&#39;和&#39;l&#39;非常相似。给变量命名为 l 特别糟糕,因为它看起来十分像常量&#39;1&#39;。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通常,全局名字(包括 enum)应该具有一个统一的前缀,通过该前缀名我们可以识别出这个名字归属于哪个模块。全局变量可以选择汇集在一个全局结 构中。typedef 的名字通常在结尾加一个&#39;t&#39;。&lt;/p&gt;

&lt;p&gt;避免名字与各种标准库中的名字冲突。一些系统可能包含一些你所不需要的库。另外你的程序将来某天很可能也要扩展。&lt;/p&gt;

&lt;h2&gt;11. 常量&lt;/h2&gt;

&lt;p&gt;数值型常量不应该被硬编码到源文件中。应该使用 C 预处理器的#define 特性为常量赋予一个有意义的名字。符号化的常量可以让代码具有更好的可 读性。在一处地方统一定义这些值也便于进行大型程序的管理,这样常量值可以在一个地方进行统一修改,只需修改 define 的值即可。枚举数据类型 更适合声明一组具有离散值的变量,并且编译器还可以对其进行额外的类型检查。至少,任何硬编码的值常量必须具有一段注释,以说明该值的来历。&lt;/p&gt;

&lt;p&gt;常量的定义应该与其使用是一致的;例如使用540.0作为一个浮点数,而不是使用540外加一个隐式的float 类型转换。有些时候常量0和1被 直接使用而没有用 define 进行定义。例如,一个 for 循环语句中用于标识数组下标的常量,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (i = 0; i &amp;lt; ARYBOUND; i++)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码是合理的,但下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;door_t *front_door = opens(door[i], 7);
if (front_door == 0)
    error(&quot;can&#39;t open %s\\\\n&quot;, door[i]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不合理的。在最后的那个例子中, front_door 是一个指针。当一个值是指针的时候,它应该与 NULL比较而不是与0比较。NULL 被定义 在标准 I/O 库头文件 stdio.h 中,在一些新系统中它在 stdlib.h 中定义。即使像1或0这样的简单值,我们最好也用 define 定义成 TRUE 和 FALSE 定义后再使用(有些时候,使用 YES 和 NO 可读性更好)。&lt;/p&gt;

&lt;p&gt;简单字符常量应该被定义成字面值,不应该使用数字。不鼓励使用非可见文本字符,因为它们是不可移植的。如果非可见文本字符十分必要,尤其是当它们 在字符串中使用时,它们应该定义成三个八进制数字的转义字符(例如: &#39;\007‘)而非一个字符。即使这样,这种用法也应该考虑其机器相关性,并按这里的方法处理。&lt;/p&gt;

&lt;h2&gt;12. 宏&lt;/h2&gt;

&lt;p&gt;复杂表达式可能会被用作宏参数,这可能会因操作符优先级顺序而引发问题,除非宏定义中所有参数出现的位置都用括号括上了。对这种因参数内副作用而 引发的问题,我们似乎也无能为例,除了在编写表达式时杜绝副作用(无论如何,这都是一个很好的主意)。如果可能的话,尽量在宏定义中对宏参数只进 行一次求值。有很多时候我们无法写出一个可像函数一样使用的宏。&lt;/p&gt;

&lt;p&gt;一些宏也当成函数使用(例如,getc 和 fgetc)。这些宏会被用于实现其他函数,这样一旦宏自身发生变化,使用该宏的函数也会受到影响。在交 换宏和函数时务必要小心,因为函数参数是按值传递的,而宏参数则是通过名称替换。只有在宏定义时特别谨慎小心,才有可能减少使用宏时的担心。&lt;/p&gt;

&lt;p&gt;宏定义中应该避免使用全局变量,因为全局变量的名字很可能被局部声明遮盖。对于那些对具名参数进行修改(不是这些参数所指向的存储区域)或被用作 赋值语句左值的宏,我们应该添加相应的注释以给予提醒。那些不带参数但引用变量,或过长或作为函数别名的宏应该使用空参数列表,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define OFF_A() (a_global+OFFSET)
#define BORK() (zork())
#define SP3() if (b) { int x; av = f (&amp;amp;x); bv += x; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;宏节省了函数调用和返回的额外开销,但当一个宏过长时,函数调用和返回的额外开销就变得微不足道了,这种情况下我们应该使用函数。&lt;/p&gt;

&lt;p&gt;在一些情况下,让编译器确保宏在使用时应该以分号结尾是很有必要的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (x==3)
    SP3();
else
    BORK();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果省略 SP3调用后面的分号,后面的 else 将会匹配到 SP3宏中的那个 if。有了分号,else 分支就不会与任何 if 匹配。SP3宏可以这样 安全地实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define SP3() \\\\
    do { if (b) { int x; av = f (&amp;amp;x); bv += x; }} while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手工给宏定以加上 do-while 包围看起来很别扭,而且很多编译器和工具会抱怨在 while 条件是一个常量值。一个用来声明语句的宏可以使得编 码更加容易:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifdef lint
    static int ZERO;
#else
#define ZERO 0
#endif
#define STMT( stuff ) do { stuff } while (ZERO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用下面代码来声明 SP3宏:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define SP3() \\\\
    STMT( if (b) { int x; av = f (&amp;amp;x); bv += x; } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 STMT 宏可以有效阻止一些可以潜在改变程序行为的打印排版错误。除了类型转换、sizeof 以及上面那些技巧和手法,只有当整个宏用括号括上时才应该包含关键字。&lt;/p&gt;

&lt;h2&gt;13. 条件编译&lt;/h2&gt;

&lt;p&gt;条件编译在处理机器依赖、调试以及编译阶段设定特定选项时十分有用。不过要小心条件编译。各种控制很容易以一种无法预料的方式结合在一起。如果使 用#ifdef 判断机器依赖,请确保当没有机器类型适配时,返回一个错误,而不是使用默认机器类型(使用#error 并缩进一级,这样它可以一些老旧的编 译器下工作)。如果你#ifdef 优化选项,默认情况下应该是一个未经优化的代码,而不是一个不兼容的程序。确保测试的是未经优化的代码。&lt;/p&gt;

&lt;p&gt;注意在#ifdef 区域内的文本可能会被编译器扫描(处理),即使#ifdef 求值的结果为假。但即使文件的#ifdef 部分永远不能被编译到(例如,#ifdef COMMENT),这部分也不该随意的放置文本。&lt;/p&gt;

&lt;p&gt;尽可能地将#ifdefs 放在头文件中,而不是源文件中。使用#ifdef 定义可以在源码中统一使用的宏。例如,一个用于检查内存分配的头文件可能这样实现:(省略了 REALLOC 和 FREE):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifdef DEBUG
extern void *mm_malloc();
#define MALLOC(size) (mm_malloc(size))
#else
    extern void *malloc();
#define MALLOC(size) (malloc(size))
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件编译通常应该基于一个接一个的特性的。多数情况下,都应该避免使用机器或操作系统依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifdef BSD4
long t = time ((long *)NULL);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码之所以糟糕有两个原因:很可能在某个4BSD 系统上有更好的选择,并且也可能存在在某个非4BSD 系统中上述代码是最佳代码。我们可以通过定义诸 如 TIME_LONG 和 TIME_STRUCTD 等宏作为替代,并且在诸如 config.h 的配置文件中定义一个合适的宏。&lt;/p&gt;

&lt;h2&gt;14. 可移植性&lt;/h2&gt;

&lt;p&gt;&quot;C语言结合了汇编的强大功能和可移植性&quot; — 无名氏,暗指比尔.萨克。&lt;/p&gt;

&lt;p&gt;可移植代码的好处是有目共睹的。这一节将阐述一些编写可移植代码的指导原则。这里&quot;可移植的&quot;是指一个源码文件能够在不同机器上被编译和执行,其 前提仅仅是在不同平台上可能包含不同的头文件,使用不同的编译器开关选项罢了。头文件包含的#define 和 typedef 可能因机器而异。一般 来说,一个新&quot;机器&quot;是指一种不同的硬件,一种不同的操作系统,一个不同的编译器,或者是这些的任意组合。参考1包含了很多关于风格和可移植 性方面的有用信息。下面是一个隐患列表,当你设计可移植代码时应该考虑避免这些隐患:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写可移植的代码。只有当被证明是必要的情况下才考虑优化的细节。优化后的代码往往是模糊不清、难以理解的。在一台机器上经过优化后的代码,在其他机器上 可能变得更加糟糕。将采用的性能优化手段记录下来并尽可能多地本地化。文档应该解释这些手段的工作原理以及引入它们的原因(例如:&quot;循环执行了无 数次&quot;)&lt;/li&gt;
&lt;li&gt;要意识到很多东西天生就是不可移植的。比如处理类似程序状态字这样的特定硬件寄存器的代码,以及被设计用于支持某特定硬件部件的代码,诸如汇编器以及 I/O 驱动。即使在这种情况下,许多例程和数据仍然可以被设计成机器无关的。&lt;/li&gt;
&lt;li&gt;组织源文件时将机器无关与机器相关的代码分别放在不同文件中。之后如果这个程序需要被移植到一个新机器上时,我们就可以很容易判断出来哪些需要被改变。为 一些文件的头文件中机器依赖相关的代码添加注释。&lt;/li&gt;
&lt;li&gt;任何&quot;实现相关&quot;的行为都应该作为机器(编译器)依赖对待。假设编译器或硬件以一种十分古怪的方式实现它。&lt;/li&gt;
&lt;li&gt;注意机器字长。对象的大小可能不直观,指针大小也不总是与整型大小相同,也不总是彼此大小相同,或者可相互自由转换。下面的表中列举了 C 语言基本类型在不 同机器和编译器下的大小(以bit 为单位)。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/c-stander/table1.jpg&quot; alt=&quot;table1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有些机器针对某一类型可能有不止一个大小。其类型大小取决于编译器和不同的编译期标志。下面表展示了大多数系统的&quot;安全&quot;类型大小。无符号与带符 号数具有相同的大小(单位:bit)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/c-stander/table2.jpg&quot; alt=&quot;table2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;void 类型可以保证有足够位精度来表示一个指向任意数据对象的指针。void()()类型可以保证表示一个指向任意函数的指针。当你需要通用指针时 可以使用这些类型(在一些旧的编译器里,分别用char 和 char()()表示)。确保在使用这些指针类型之前将其转换回正确的类型。&lt;/li&gt;
&lt;li&gt;即使说一个 int 和一个 char 类型大小相同,它们仍可能具有不同的格式。例如,下面例子在一些 sizeof(int)等于 sizeof(char)的机器上可能失败。其原因在与 free 函数期望一个 char,但却传入了一个 int。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *p = (int *) malloc (sizeof(int));
free (p);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意,一个对象的大小不能保证这个对象的精度。Cray-2可能使用64位来存储一个整型,但一个长整型转换为一个整型并且再转换回长整型后可能会被截断 为32位。&lt;/li&gt;
&lt;li&gt;整型常量0可以强制转型为任何指针类型。转换后的指针称为对应那个类型的空指针,并且与那个类型的其他指针不同。空指针比较总是与常量0相当。空指针不应 该与一个值为0的变量比较。空指针不总是使用全0的位模式表示。两个不同类型的空指针有些时候可能不同。某个类型的空指针被强制转换为另外一个类 型的指针,其结果是该指针转换为第二个类型的空指针。&lt;/li&gt;
&lt;li&gt;对于 ANSI 编译器,当两个类型相同的指针访问同一块存储区时,则它们比较是相等的。当一个非0整型常量被转换为指针类型时,它们可能与其他指针相等。对 于非 ANSI 编译器,访问同一块存储区的两个指针比较可能并不相同。例如,下面两个指针比较可能相等或不相等,并且他们可能或可能没有访问同一块 存储区域。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;((int *) 2 )
((int *) 3 )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要&#39;magic&#39;指针而不是 NULL,要么分配一些内存,要么将指针视为机器相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;extern int x_int_dummy;
 /* in x.c */
#define X_FAIL (NULL)
#define X_BUSY (&amp;amp;x_int_dummy)
#define X_FAIL (NULL)
#define X_BUSY MD_PTR1
 /* MD_PTR1 from &quot;machdep.h&quot; */
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;浮点数字既包含精度也包含范围。这些都是数据对象大小无关的。但是,一个32位浮点数在不同机器上溢出时的值有所不同。同时,4.9乘以5.1在不同的机 器上可能产生两个不同的数字。在圆整(rounding)和截断方面的差异将给出特别不同的答案。&lt;/li&gt;
&lt;li&gt;在一些机器上,一个双精度浮点数在精度或范围方面可能比一个单精度浮点数还要低。&lt;/li&gt;
&lt;li&gt;在一些机器上,double 值的前半部分可能是一个具有相同值的 float 类型。千万不要依赖于此。&lt;/li&gt;
&lt;li&gt;提防带符号字符。例如,在某些 VAX 系统上,用在表达式中的字符是符号扩展的,但在其他一些机器上并非如此。对有符号和无符号有依赖的代码是不可移植的。 例如,如果假设 c 是正值,arrayc 在 c 为有符号且为负值时将无法正常工作。如果你一定要假设 signed 或 unsigned 字符的话,请 用 SIGNED 或 UNSIGNED 为其加上注释。无符号字符的行为可由 unsigned char 保证。&lt;/li&gt;
&lt;li&gt;避免对 ASCII 做假设。如果你必须假设,那么请将其记录下来并本地化。请记住字符很可能用不止8位表示。&lt;/li&gt;
&lt;li&gt;大多数机器采用2的补码表示数,但我们在代码中不应该利用这一特点。使用等价移位操作替代算术运算的优化尤其值得怀疑。如果必须这么做,那么机器相关的代 码应该用#ifdef 定义,或者操作应该在#ifdef 宏判定下执行。你应该衡量一下使用这种难以理解的代码所节省的时间与做代码移植时找 bug 所花费的时间相比孰多孰少。&lt;/li&gt;
&lt;li&gt;一般情况下,如果字长或值范围非常重要,应该使用 typedef 定义具有特定大小的类型。大型程序应该具有一个统一的头文件用于提供通用的、大小 (size)敏感的类型的 typedef 定义,这样更加便于修改以及在紧急修复时查找大小敏感的代码。无符号类型比有符号整型更加编译器无关。如 果既可以用16bit 也可以用32bit 标识一个简单 for 循环的计数器,我们应该使用 int。因为对于当前机器来说,通过整型可以获取更高效 (自然)的存储单元。&lt;/li&gt;
&lt;li&gt;数据对齐也很重要。例如,在不同的机器上,一个四字节的整型数的可能以任意地址作为起始地址,也可能只允许以偶数地址作为起始地址,或者只能以4的整数倍 的地址作为起始地址。因此,一个特定的结构体的各个元素在不同的机器上的偏移量有不同,即使给定的这些元素在所有机器上的大小相同。事实上,一个 包含一个32位指针和一个8位字符的结构提在三个不同的机器上可能有三个不同的大小。作为一个推论,对象指针可能无法自由互换;通过一个指向起始 地址为奇数地址长度为4个字节的指针保存一个整型数有时可以正常工作,但有时则会导致产生 core,有些时候静悄悄地失败了(在这个过程中会破坏 其他数据)。在那些不按字节寻址的机器上,字符指针更是&quot;事故高发地区&quot;。对齐考虑以及加载器的特殊性使得很容易轻率地认为两个连续声明的变量在 内存中也是连在一起的,或者某个类型的变量已经被适当对齐并可以用作其他类型变量使用了。&lt;/li&gt;
&lt;li&gt;在一些机器上,诸如 VAX(小端),一个字的字节随着地址的增加,其重要性提高;而另外一些机器上,诸如68000(大端),随着地址的增加,其重要性降 低。字或更大数据对象(诸如一个双精度字)的字节顺序可能并不相同。因此,任何依赖对象内从左到右方向位模式的代码都值得特别细致的审查。只有当 结构体中两个不同的位字段不被连接以及不被当作一个单元时,这些位字段才具备可移植性。事实上,连接任意两个变量都是不可移植的行为。&lt;/li&gt;
&lt;li&gt;结构体中有一些未使用的空洞。猜想联合体用于类型欺骗。尤其是,一个值不应该在存储时使用一个类型,而在读取时使用另外一种类型。对联合体来说,一个显式 的标签(tag)字段可能会很有用。&lt;/li&gt;
&lt;li&gt;不同的编译器在返回结构体时使用不同的约定。这就会导致代码在接受从不同编译器编译的库代码中返回的结构体值时会出现错误。结构体指针不是问题。&lt;/li&gt;
&lt;li&gt;不要假设参数传递机制。特别是指针大小以及参数求值顺序,大小等。例如,下面的代码就不具备可移植性。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    c = foo (getchar(), getchar());
char
foo (c1, c2, c3)
char c1, c2, c3;
{
    char bar = *(&amp;amp;c1 + 1);
    return (bar);
    /* often won&#39;t return c2 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上面的例子有诸多问题。栈可能向上增长,也可能向下增长(事实上,甚至都不需要一个栈)。参数在传入时可能被扩大,例如一个 char 可能以 int 型被传 入。参数可能以从左到右,从右到左,或以任意顺序压入栈,或直接放在寄存器中(根本无需压栈)。参数求值的顺序也可能与压栈的次序有所不同。一个 编译器可能使用多种(不兼容的)调用约定。&lt;/li&gt;
&lt;li&gt;在某些机器上,空字符指针((char *)0)常被当作指向空字符串的指针对待。不要依赖于此。&lt;/li&gt;
&lt;li&gt;不要修改字符串常量。下面就是一个臭名昭著的例子&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;s = &quot;/dev/tty??&quot;;
strcpy (&amp;amp;s[8], ttychars);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;地址空间可能有空洞。简单计算一个数组中未分配空间的元素(在数组实际存储区域之前或之后)的地址可能会导致程序崩溃。如果这个地址被用于比较,有时程序 可以运行,但会破坏数据,报错,或陷入死循环。在 ANSI C 中,指向一个对象数组的指针指向数组结尾后的第一个元素是合法的,这在一些老编译器上通常是安全的。不过这个&quot;在外边&quot;不可以被解引用。&lt;/li&gt;
&lt;li&gt;只有==和!=比较可用于某给定类型的所有指针。当两个指针指向同一个数组内的元素(或数组后第一个元素)时,使用&amp;lt;&amp;lt;、&amp;lt;=、&amp;amp; amp; gt;或&gt;=对两个指针进行比较是可移植的。同样,仅仅对指向同一个数组内的元素(或数组后第一个元素)的两个指针使用算术操作符才是可移 植的。&lt;/li&gt;
&lt;li&gt;字长(word size)也影响移位和掩码。下面代码在一些68000机器上只会将一个整型数的最右三个位清0,而在其他机器上它还会将高地址的两个字节清零。x &amp;amp;= 0177770 使用 x &amp;amp;= ~07可以在所有机器上正常工作。位字段(bitfield)没有这些问题。&lt;/li&gt;
&lt;li&gt;表达式内的副作用可能导致代码语义是编译器相关的,因为在大多数情况下 C 语言的求值顺序是没有显式定义的。下面是一个臭名昭著的例子:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;a[i] = b[i++];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们只知道 b 的下标值没有被增加。a 的下标 i 值可能是自增后的值也可能是自增前的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct bar_t { struct bar_t *next; } bar;
bar-&amp;gt;next = bar = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第二个例子中,bar-&gt;next 的地址很可能在 bar 被赋值之前被计算使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;bar = bar-&amp;gt;next = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三个例子中,bar 可能在 bar-&gt;next 之前被赋值。虽然这可能有悖于&quot;赋值从右到左处理&quot;的规则,但这确是一个合法的解析。考虑下 面的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;long i;
short a[N];
i = old
i = a[i] = new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋给 i 的值必须是一个按照从右到左的处理顺序进行赋值处理后的值。但是 i 可能在 ai 被赋值前而被赋值为&quot;(long) (short)new&quot;。不同编译器作法不同。
* 质疑代码中出现的数值(“魔数”)。
* 避免使用预处理器技巧。一些诸如使用/ /粘和字符串以及依赖参数字符串展开的宏会破坏代码可靠性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define FOO(string) (printf(&quot;string = %s&quot;,(string)))
...
FOO(filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只是在有些时候会扩展为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;(printf(&quot;filename = %s&quot;,(filename)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小心。诡异的预处理器在一些机器上可能导致宏异常中断。下面是一个宏的两种不同实现版本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define LOOKUP(chr) (a[&#39;c&#39;+(chr)]) /* Works as intended. */
#define LOOKUP(c) (a[&#39;c&#39;+(c)]) /* Sometimes breaks. */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个版本的 LOOKUP 可能以两种不同的方式扩展,并且会导致代码异常中断。
* 熟悉现有的库函数和定义(但不用太熟悉。与其外部接口相反,库基础设施的内部细节常会改变并且没有警告,这些细节常常也是不可移植的)。你不应该再自己重 新编写字符串比较例程、终端控制例程或为系统结构编写你自己的定义。自己动手实现既浪费你的时间,又使得你的代码可读性变差,因为另外一个读者需 要知道你是否在新的实现中做了什么特殊的事情,并尝试证实它们的存在。同时这样做会使得你无法充分利用一些辅助的微代码或其他有助于提高系统例程 性能的方法。更进一步,它将是一个 bug 的高产源头。如果可能的话,要知道公共库之间的差异(如 ANSI、POSIX 等等)。
* 如果 lint 可用,请使用 lint。这个工具对于查找代码中机器相关的构造、其他不一致性以及顺利通过编译器检查的程序 bug 时具有很高价值。如果你的编 译器具备打开警告的开关,请打开它。
* 质疑在代码块内部的与代码块外部 switch 或 goto 有关联的标签(Label)。无论类型在哪里,参数都应该被转换为适当的类型。当 NULL 用在没有原型的函数调用时,请对NULL 进行转换。不要让函数调用成为类型欺骗发生的地方。C 语言的类型提升规则很是让人费解,所以尽量小心。例如,如果一个函数接受一个32位长的长整型做为参数,但实际传入的却是一个16位长的整型数, 函数栈可能会无法对齐,这个值也可能会被错误提升。
* 在混用有符号和无符号值的算术计算时请使用显式类型转换
* 应该谨慎使用跨程序的 goto、longjmp。很多实现&quot;忘记&quot;恢复寄存器中的值了。尽可能将关键的值声明为 volatile,或将它们注释为 VOLATILE。
* 一些链接器将名字转换为小写,并且一些链接器只识别前六个字母作为唯一标识。在这些系统上程序可能会悄悄地中断运行。
* 当心编译器扩展。如果使用了编译器扩展,请将他们视为机器依赖并用文档记录下来。
* 通常程序无法在数据段执行代码或者无法将数据写入代码段。即使程序可以这么做,也无法保证这么做是可靠的。&lt;/p&gt;

&lt;h2&gt;15. 标准 C&lt;/h2&gt;

&lt;p&gt;现代 C 编译器支持一些或全部的 ANSI 提议的标准 C。无论何时可能的话,尽量用标准 C 编写和运行程序,并且使用诸如函数原型,常量存储以及 volatile(易失性)存储等特性。标准 C 通过给优化器提供有有效的信息以提升程序的性能。标准 C 通过保证所有编译器接受同样的输入语言以及提供相关 机制隐藏机器相关内容或对于那些机器相关代码提供警告的方式提升代码的可移植性。&lt;/p&gt;

&lt;h3&gt;15.1 兼容性&lt;/h3&gt;

&lt;p&gt;编写很容易移植到老编译器上的代码。例如,有条件地在 global.h 中定义一些新(标准中的)关键字,比如 const 和 volatile。标准编译器预 定义了预处理器符号 STDC(见脚注8)。void 类型很难简单地处理正确,因为很多老编译器只理解 void,但不认识 void。&lt;/p&gt;

&lt;p&gt;最简单的方法就是定义一 个新类型 VOIDP(与机器和编译器相关),通常在老编译器下该类型被定义为 char*。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#if __STDC__
typedef void *voidp;
#define COMPILER_SELECTED
#endif
#ifdef A_TARGET
#define const
#define volatile
#define void int
typedef char *voidp;
#define COMPILER_SELECTED
#endif
#ifdef ...
...
#endif
#ifdef COMPILER_SELECTED
#undef COMPILER_SELECTED
#else
{ NO TARGET SELECTED! }
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在 ANSI C 中,#必须是同一行中预处理器指示符的第一个非空白字符。在一些老编译器中,它必须是同一行中的第一个字符。&lt;/p&gt;

&lt;p&gt;当一个静态函数具有前置声明时,前置声明必须包含存储修饰符。在一些老编译器中,这个修饰符必须是&quot;extern&quot;。对于 ANSI 编译器,这个存储修饰符 必须为 static,但全局函数依然必须声明为 extern。因此,静态函数的前置声明应该使用一个#define,例如 FWD_STATIC,并通 过#ifdef 适当定义。&lt;/p&gt;

&lt;p&gt;一个&quot;#ifdef NAME&quot;应该要么以&quot;#endif&quot;结尾,要么以&quot;#endif / NAME /结尾,不应该用&quot;#endif NAME&quot;结尾。对于短小的#ifdef 不应该使用注释,因为通过代码我们可以明确其含义。&lt;/p&gt;

&lt;p&gt;ANSI 的三字符组可能导致内容包含??的字符串的程序神秘的中断。&lt;/p&gt;

&lt;h3&gt;15.2 格式化&lt;/h3&gt;

&lt;p&gt;ANSI C 的代码风格与常规 C 一样,但有两点意外:存储修饰符(storage qualifiers)和参数列表。&lt;/p&gt;

&lt;p&gt;由于 const 和 volatile 的绑定规则很奇怪,因此每个 const 或 volatile 对象都应该单独声明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int const *s; /* YES */
int const *s, *t; /* NO */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具备原型的函数将参数声明和定义归并在一个参数列表中了。应该在函数的注释中提供各个参数的注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;/*
* `bp&#39;: boat trying to get in.
* `stall&#39;: a list of stalls, never NULL.
* returns stall number, 0 =&amp;gt; no room.
*/
int
enter_pier (boat_t const *bp, stall_t *stall)
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;15.3 原型&lt;/h3&gt;

&lt;p&gt;应该使用函数原型使得代码更加健壮并且运行时性能更好。不幸地是原型的声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;extern void bork (char c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与定义不兼容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void bork (c)
char c;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原型中 c 应该以机器上最自然的类型传入,很可能是一个字节。而非原型化(向后兼容)的定义暗示 c总是以一个整型传入。如果一个函数具有可类型提升的参数, 那么调用者和被调用者必须以相等地方式编译。要么都必须使用函数原型,要么都不使用原型。如果在程序设计时参数就是可以提升类型的,那么问题就可以被避 免,例如 bork 可以定义成接受一个整型参数。&lt;/p&gt;

&lt;p&gt;如果定义也是原型化的,上面的声明将工作正常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void bork (char c)
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸地是,原型化的语法将导致非 ANSI 编译器拒绝这个程序。&lt;/p&gt;

&lt;p&gt;但我们可以很容易地通过编写外部声明来同时适应原型与老编译器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#if __STDC__
#define PROTO(x) x
#else
#define PROTO(x) ()
#endif
extern char **ncopies PROTO((char *s, short times));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 PROTO 必须使用双层括号。&lt;/p&gt;

&lt;p&gt;最后,最好只使用一种风格编写代码(例如,使用原型)。当需要非原型化的版本时,可使用一个自动转换工具生成。&lt;/p&gt;

&lt;h3&gt;15.4 Pragmas&lt;/h3&gt;

&lt;p&gt;Pragmas 用于以一种可控的方式引入机器相关的代码。很显然,pragma 应该被视为机器相关的。不幸地是,ANSI pragmas 的语法使得我们无法将其隔离到机器相关的头文件中了。&lt;/p&gt;

&lt;p&gt;Pragmas 分为两类。优化相关的可以被安全地忽略。而那些影响系统行为(需要 pragmas)的 Pragmas则不能忽略。需要的 pragmas 应该结合#ifdef 使用,这样如果一个 pragma 都没有选到,编译过程将退出。&lt;/p&gt;

&lt;p&gt;两个编译器可能通过两个不同的方式使用同一个给定的 pragma。例如,一个编译器可能使用 haggis发出一个优化信号。而另一个可能使用它暗示一个特 定语句,一旦执行到此,程序应该退出。不过,一旦使用了 pragma,它们必须总是被机器相关的#ifdef 包围。对于非 ANSI 编译器,Pragmas 必须总是被#ifdef。确保对#pragma 的#进行缩进,否则一些较老的预处理器处理它时会挂起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#if defined(__STDC__) &amp;amp;&amp;amp; defined(USE_HAGGIS_PRAGMA)
#pragma (HAGGIS)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&quot;ANSI 标准中描述的&#39;#pragma&#39;命令具有任意实现定义的影响。在 GNU C 预处理中,&#39;#pragma&#39;首先尝试运行游戏&#39;rogue&#39;;如果失败,它将尝试运行游戏&#39;hack&#39;;如果失败,它将尝试运行 GNU Emacs显示汉诺塔;如果失败,它将报告一个致命错误。无论如何,预处理将不再继续。&quot;
—-- GNU CC 1.34 C 预处理手册。&lt;/p&gt;

&lt;h2&gt;16. 特殊考虑&lt;/h2&gt;

&lt;p&gt;这节包含一些杂项:‘做&#39;与&#39;不做&#39;。
* 不要通过宏替换来改变语法。这将导致程序对于所有人都是难以理解的,除了那个肇事者。
* 不要在需要离散值的地方使用浮点变量。使用一个浮点数作为循环计数器无疑是搬起石头砸自己的脚。总是用&amp;lt;=或&gt;=测试浮点数,对它们永远不要 用精确比较(==或!=)。
* 编译器也有 bug。常见且高发的问题包括结构体赋值和位字段。你无法泛泛的预测一个编译器都有哪些 bug。但你可以在程序中避免使用那些已知的在所有编译 器上都存在问题的结构。你无法让你写的任何代码都是有用的,你可能仍然会遇到 bug,并且在这期间编译器很可能会被修复。因此,只有当你被强制使 用某个特定的充斥 bug 的编译器时,你才应该&quot;围绕&quot;着编译器 bug 写代码。
* 不要依赖自动代码美化工具。良好代码风格的主要受益者就是代码的编写者,并且尤其在手写算法或伪代码的早期设计阶段。自动代码美化工具只应该用在那些已经 完成、语法正确并且此后不能满足当空白和缩进被更为关注的要求时。伴随着对细致程序员的细节的关注,对于那些将函数或文件布局解释清楚的工作,程 序员们会做得更好(换句话说,一些视觉布局是由意图而不是语法决定的,美化工具无法了解到程序员的思想)。粗心的程序员应该学习成为一个细致的程 序员,而不是依赖美化工具让代码可读性更好。
* 意外地遗漏逻辑比较表达式中的第二个=是一个常犯的问题。使用显式测试。避免对赋值使用隐式测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;abool = bbool;
if (abool) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当嵌入的赋值表达式使用时,确保测试是显式的,这样后续它就无法被&quot;修复&quot;了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while ((abool = bbool) != FALSE) { ...
while (abool = bbool) { ... /* VALUSED */
while (abool = bbool, abool) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显式地注释那些在正常控制流之外被修改的变量,或其他可能在维护过程中中断的代码。&lt;/p&gt;

&lt;p&gt;现代编译器会自动将变量放到寄存器中。对于你认为最关键的变量慎用寄存器。在极端情况下,用寄存器标记2-4个最为关键的值,并且将剩余的标记为 REGISTER。后者在那些具有较多寄存器的机器上可以#define 为寄存器。&lt;/p&gt;

&lt;h2&gt;17. Lint&lt;/h2&gt;

&lt;p&gt;Lint 是一个 C 程序检查工具,用于检查 C 语言源码文件,探测和报告诸如类型不兼容、函数定义与调用不一致以及潜在的 bug 等情况。强烈建议在所 有程序上使用 lint 工具,并且期望大多数工程将lint 作为官方验收程序的一部分。&lt;/p&gt;

&lt;p&gt;应该注意的是使用 lint 的最好方法不是将 lint 作为官方验收之前的一道必须跨过的栅栏,而是作为一个在代码发生添加或变更之后使用的工具。 Lint 可以发现一些隐藏的 bug 并且可以在问题发生前保证程序的可移植性。lint 产生的许多信息确实暗示了一些事情是错误的。一个有意思的故 事是关于一个漏掉了 fprintf 的一个参数的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;fprintf (&quot;Usage: foo -bar &amp;lt;file&amp;gt;\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作者从未有过一个问题。但每当一个正常用户在命令行上犯错,这个程序就会产生一个 core。许多版本的 lint 工具都能发现这个问题。&lt;/p&gt;

&lt;p&gt;大多 lint 选项都值得我们学习。一些选项可能在合法的代码上给出警告,但它们也会捕捉到许多把事情搞遭的代码。注意&#39;–p&#39;只能为库的一个子 集检查函数调用和类型的一致性,因此程序为了最大化的覆盖检查,应该同时进行带–p 和不带–p 的 lint 检查。&lt;/p&gt;

&lt;p&gt;Lint 也可以识别代码里的一些特殊注释。这些注释可以强制让 lint 在发现问题时关闭警告输出,还可以作为一些特殊代码的文档。&lt;/p&gt;

&lt;h2&gt;18. Make&lt;/h2&gt;

&lt;p&gt;另外一个非常有用的工具是 make。在开发过程中,make 只会重新编译那些上次 make 后发生了改变的模块。它也可以用于自动化其他任务。一些 常见的约定包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;执行所有二进制文件的构建过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clean&lt;/code&gt;删除所有中间文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;debug&lt;/code&gt;构建一个测试用二进制文件 a.out 或 debug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depend&lt;/code&gt;制作可传递的依赖关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;install&lt;/code&gt;安装二进制文件,库等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deinstall&lt;/code&gt;取消安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkcat&lt;/code&gt;安装手册&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lint&lt;/code&gt;运行 lint 工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print/list&lt;/code&gt;制作一个所有源文件的拷贝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shar&lt;/code&gt;为所有源文件制作一个 shar 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spotless&lt;/code&gt;执行 make clean,并将源码存入版本控制工具。注意:不会删除 Makefile,即便它是一个源文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source&lt;/code&gt;撤销 spotless 所做的事情。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt;运行 ctags(建议使用-t 标志)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdist&lt;/code&gt;分发源码到其他主机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.c&lt;/code&gt;从版本控制系统中检出这个文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;除此之外,通过命令行也可以定义 Makefile 使用的值(如&quot;CFLAGS&quot;)或源码中使用的值(如&quot;DEBUG&quot;)。&lt;/p&gt;

&lt;h2&gt;19. 工程相关的标准&lt;/h2&gt;

&lt;p&gt;除了这里提到内容外,每个独立的工程都期望能建立附加标准。下面是每个工程程序管理组需要考虑的问题中的一部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;哪些额外的命名约定需要遵守?尤其是,那些用于全局数据的功能归类以及结构体或联合体成员名字的系统化的前缀约定非常有用。&lt;/li&gt;
&lt;li&gt;什么样的头文件组织适合于工程特定的数据体系结构?&lt;/li&gt;
&lt;li&gt;应该建立什么样的规程来审核 lint 警告?需要确立一个与 lint 选项一致的宽容度,保证 lint 不会针对一些不重要的问题给出警告,但同时保证真正的 bug 或不一致问题不被隐藏。&lt;/li&gt;
&lt;li&gt;如果一个工程建立了自己的档案库,它应该计划向系统管理员提供一个 lint 库文件。这个 lint库文件允许 lint 工具检查对库函数的兼容性使用。&lt;/li&gt;
&lt;li&gt;需要使用哪种版本控制工具?&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;20. 结论&lt;/h2&gt;

&lt;p&gt;这里描述了一套 C 语言编程风格的标准。其中最重要的几点是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;合理使用空白和注释,使得我们通过代码布局就可以清楚地看出程序的结构。使用简单表达式、语句和函数,使他们可以很容易地被理解。&lt;/li&gt;
&lt;li&gt;记住,在将来某个时候你或其他人很可能会被要求修改代码或让代码运行在一台不同的机器上。精心编写代码,使得其可以移植到尚不确定的机器上。局部化你的优化,因为这些优化经常让人困惑,并且对于该优化措施是否适合其他机器我们持悲观态度。&lt;/li&gt;
&lt;li&gt;许多风格选择是主观武断的。保持代码风格一致比遵循这些绝对的风格规则更重要(尤其是与组织内部标准保持一致)。混用风格比任何一种糟糕的风格都更加糟糕。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;无论采用哪种标准,如果认为该标准有用就必须遵循它。如果你觉得遵循某条标准时有困难,不要仅仅忽略它们,而是在和你当地的大师或组织内的有经验的程序员讨论后再做决定。&lt;/p&gt;

&lt;h2&gt;21. 参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;B.A. Tague, C Language Portability, Sept 22, 1977. This document issued by department 8234 contains three memos by R.C. Haight, A.L. Glasser, and T.L. Lyon dealing with style and portability.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;S.C. Johnson, Lint, a C Program Checker, Unix Supplementary Documents, November 1986.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.W. Mitze, The 3B/PDP-11 Swabbing Problem, Memorandum for File, 1273-770907.01MF, September 14, 1977.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.A. Elliott and D.C. Pfeffer, 3B Processor Common Diagnostic Standards- Version 1, Memorandum for File, 5514-780330.01MF, March 30, 1978.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.W. Mitze, An Overview of C Compilation of Unix User Processes on the 3B, Memorandum for File, 5521-780329.02MF, March 29, 1978.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;B.W. Kernighan and D.M. Ritchie, The C Programming Language, Prentice Hall 1978, Second Ed. 1988, ISBN 0-13-110362-8.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;S.I. Feldman, Make — A Program for Maintaining Computer Programs, UNIXSupplementary Documents, November 1986.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Ian Darwin and Geoff Collyer, Can&#39;t Happen or / NOTREACHED / or Real Programs Dump Core, USENIX Association Winter Conference, Dallas 1985 Proceedings.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Brian W. Kernighan and P. J. Plauger The Elements of Programming Style. McGraw-Hill, 1974, Second Ed. 1978, ISBN 0-07-034-207-5.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;Lapin Portable C and UNIX System Programming, Prentice Hall 1987, ISBN 0-13-686494-5.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Ian F. Darwin, Checking C Programs with lint, O&#39;Reilly &amp;amp; Associates, 1989. ISBN 0-937175-30-7.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Andrew R. Koenig, C Traps and Pitfalls, Addison-Wesley, 1989. ISBN 0-201-17928-8.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 20 Feb 2013 00:00:00 +0800</pubDate>
				<link>/2013/02/20/C-stander.html</link>
				<guid isPermaLink="true">/2013/02/20/C-stander.html</guid>
			</item>
		
			<item>
				<title>c语言学习-指针</title>
        <description>&lt;h2&gt;指针——保存变量地址的变量&lt;/h2&gt;

&lt;p&gt;第一步，我们来看应该怎么定义指针。指针包含两重意思：指针类型和指针指向的类型。指针类型就是我们平时说的int类型指针、double类型指针；对应的，指针指向的类型就是int、double。关于指针的声明个人只有一个建议，那就是把星号放在变量的旁边。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a,**b;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;定义中常见错误&lt;/h3&gt;

&lt;p&gt;当指针定义后不赋值，那么他会指向一个不确定的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a;
printf(&quot;%p\n&quot;,a);
printf(&quot;%c\n&quot;,*a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译的时候可以通过，但是往往会造成运行时错误，这就是我们俗称的野指针。解决的方案很简单，就是为她赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a = NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的说，一个xx类型的指针会指向一个xx类型的地址（赵岩老师的《c语言点滴》里面称这句话为“指针真理”）。理解这句话，基本就能正确的为指针赋值。得到xx类型地址方法有很多，这里给出几种赵岩老师的几个例子。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;amp;符号直接获得&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地址符号&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他xx类型指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xx类型数组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;malloc动态申请的地址&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何void类型指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NULL&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;void和NULL&lt;/h2&gt;

&lt;h3&gt;void&lt;/h3&gt;

&lt;p&gt;我们习惯了用void声明函数或者函数返回值，但是很少用void声明指针变量。实际上，用void声明的指针变量之保存了一个地址，但是不会设计任何类型，也就是说任何类型的指针都可以直接赋值给void类型的指针。需要注意的是要将void类型指针赋值给其他类型就要用强制类型转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *p;
int i;
int *ip = &amp;amp;i;
p = ip;//right
ip = (int *)p;//be careful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们经常使用的内存分配函数的返回值也是void类型的指针。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *malloc(size_t size);
void *memcop(void *dest,const void *src,size_t len);
void *memset(void *buffer,int c,size_t num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此我们平时在使用的时候加上的强制类型转换是必要的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *i = (int *)malloc(sizeof(int)*len);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;NULL&lt;/h3&gt;

&lt;p&gt;NULL是一个值，而不是类型。通常情况下他被定义成0。这就造成了NULL、EOF、/0三个表示终止字符的混淆。我的理解如下，只要区分开按照常规使用，一般就不会犯错&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NULL是指针，用于表示空地址&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EOF--End Of File 的缩写，常用于表示文件结束或者读取文件不成功&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;/0表是空字符，是判断一个字符串结束的标准&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;指针和数组&lt;/h2&gt;

&lt;p&gt;首先：指针和数组是不同的事物！他们仅仅能表达某些相似的意思。我们在使用指针的时候，尽量之使用地址解析&lt;code&gt;\*p&lt;/code&gt;的形式，使用数组的时候多使用下标&lt;code&gt;p[1]&lt;/code&gt;。一般情况下，指针和数组作为函数调用参数的时候是相同的。也就是说下面两种声明是一个意思&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int func(int *a);
int func(int a[]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上他们都会被转换成指针的模式，这个时候的a在函数中用任何形式操作都是对的。&lt;/p&gt;

&lt;h3&gt;二维数组&lt;/h3&gt;

&lt;p&gt;单维度的数组是简单的，但是把数组和指针混合在一起的时候就不那么简单了。用一个表格表示二维情况就可以把人弄晕&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/aptable.jpg&quot; alt=&quot;aptable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很多书上把这个解释的很复杂。其实，单单对这个问题来说，我们可以认为变量变量声明是右结合的就可以很轻松的把它们区分开来。比如说&lt;code&gt;int *pa[5]&lt;/code&gt;，可以认为首先他是一个a[5]的数组，然后才是一个指针，也就是&lt;code&gt;int *(a[5])&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;难点在于如何理解指针类型的数组跟数组类型的指针，我实在说不清楚他们两个怎么区分，只能截取网上的一幅图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/diffap.jpg&quot; alt=&quot;diffap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一旦理解了二维情况，多维情况也就以此类推了。&lt;/p&gt;

&lt;h2&gt;动态分配内存&lt;/h2&gt;

&lt;p&gt;内存也是老生常谈的内容了。这里截取一副图来解释程序在运行过程中的内存使用情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/mem.jpg&quot; alt=&quot;mem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯，有了这幅图其他也就没有什么好说的了。&lt;/p&gt;

&lt;h3&gt;为神马&lt;/h3&gt;

&lt;p&gt;动态分配内存的原因很简单，我们在初始化一个变量的时候并不知道他会有多大，比如说字符串长度。所以我们就需要根据实际需要来分配，以确保最大效率的利用好内存。&lt;/p&gt;

&lt;p&gt;接下来介绍一些内存操作函数&lt;/p&gt;

&lt;h3&gt;malloc 和 calloc&lt;/h3&gt;

&lt;p&gt;两个函数很相似，完成的任务也大体相似，简单的说calloc = malloc + memset&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *malloc(size_t size);
void *calloc(size_t size_of_one_element, size_t len_of_elements)；

int *p = calloc(sizeof(int),10);//等价于下两句

int *q = malloc(sizeof(int)*10);
memset(q,0,10)；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;realloc&lt;/h3&gt;

&lt;p&gt;realloc对于初学者并不长用，我们在学习数据结构用数组的方式书写栈的时候，如果遇到数组元素个数不够用了，往往都是从新遭一个更大的数组，然后把刚刚的元素放进去然后继续进行其他操作。calloc也又着相似的功能。&lt;/p&gt;

&lt;p&gt;realloc通常用在动态递增的分配内存上面，re的意思是重复，那么realloc之前，一定已经有过内存分配的操作,或者初始值为NULL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *oldbuf = malloc(sizeof(int)*len);
int *newbuf = NULL;
newbuf = realloc(oldbuf,len*2);
if(newbuf!=NULL)
    oldbuf = newbuf;
else{
    free(oldbuf);
    return NULL;
}
/*
不推荐使用oldbuf = realloc(oldbuf,len*2);
因为一旦内存分配失败的时候，
会直接返回NULL给oldbuf，
但是他刚刚指向的空间此时还没有被清空，
就造成了内存浪费
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的函数就可以把内存长度加倍了&lt;/p&gt;

&lt;h3&gt;memset、memcpy、memmove&lt;/h3&gt;

&lt;p&gt;内存操作函数使得动态内存的使用更加简洁。从他们的名字就可以知道他们的功能，给出他们的定义自然就知道他们怎么用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *memcpy(void *dest, void *src,size_t count);
void *memmove(void *dest, void *src ,size_t count);
void *memset(void *buffer,int c,size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;free&lt;/h3&gt;

&lt;p&gt;我们需要养成内存操作配对的好习惯，每次分配了内存，一定要记住使用结束后将它们free掉。free函数的定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void free(void *ptr)
{
    struct mem_control_block *free;
    free = ptr-sizeof(struct mem_control_block);
    free-&amp;gt;is_available = 1;
    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看出，free释放内存的时候，并没有将原来的数据擦出，只是简单的把内存可访问置1，而没有还给操作系统。当下一次遇到本部分内存被分配的时候，才重新对内存中的内容进行操作&lt;/p&gt;

&lt;p&gt;实际上，释放指针p之后，p依然是指向释放前的地址的，也就是说*p同样有值。所以释放内存的好习惯是每次释放内存之后，就将原来的指针指空&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if(p!=NULL){
    free(p);
    p = NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;动态数组&lt;/h2&gt;

&lt;p&gt;动态数组很简单，只要掌握了他的分配和释放方式就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int (*p)[3] = (int *[3])calloc(10,sizeof(int));
int **q = (int **)malloc(sizeof(int *)*10);
for(i=0;i&amp;lt;10;i++&amp;gt;)
    q[i] = (int *)malloc(sizeof(int)*10);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;数组指针可交换&lt;/h2&gt;

&lt;p&gt;最后简单总结几个数组和指针可以交换的原则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用a[i]这样的形式对数组进行访问总是被编译器改写成*(a+i)这样的指针，这就是为什么数组写成a[i]和i[a]意思其实是一样的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指针始终就是指针，它绝对不可以写成数组。你可以用下标的形式访问指针，一般都是指针作为参数传递的时候，而你实际知道传递给函数的是指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在参数传递的时候，数组可以被看成指针，此时的指针数组没区别。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在其他情况中，定义很声明都必须匹配。如果定义了一个数组，在其他文件中对它进行的声明也只能是数组，指针亦然。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;简单解释下位什么在参数传递的时候要把数组当成指针。之所以这样做，也是出于效率考虑的。c语言所有非数组形式的参数都以传值的形式（对参数作一份拷贝并传递给调用函数，函数只能修改这个拷贝后的值）。但是，如果要拷贝整个数组的话，无论是在时间还是空间上的开销都是非常大的，因此指针往往要方便很多。&lt;/p&gt;
</description>
				<pubDate>Thu, 20 Dec 2012 00:00:00 +0800</pubDate>
				<link>/2012/12/20/C-pointer.html</link>
				<guid isPermaLink="true">/2012/12/20/C-pointer.html</guid>
			</item>
		
			<item>
				<title>C语言学习-让人头疼的scanf</title>
        <description>&lt;h2&gt;stdin/stdout/stderr&lt;/h2&gt;

&lt;p&gt;提到输入数出，最先要说的就是字节流，它是一种线性的数据结构。流是有方向的，就向您在阅读这篇文章的时候肯定是从左往右读下去的。&lt;/p&gt;

&lt;p&gt;而任何流都是有源头，也有流向的，最长见的就是我们经常说到的I/O流。c语言为我们提供了三个流，一个是输入流stdin，默认指向的源头的键盘。还有两个流是stdout和stderr，默认情况下流向指向屏幕，也就是从屏幕输出。对任何一个输入输出函数，如果没有特殊的参数指明，默认都是从stdin读取字节，再从stdout输出。&lt;/p&gt;

&lt;p&gt;虽然说stdout和stderr都是输出到屏幕，但是他们是有很大区别的。输出到stdout的内容首先要保存到缓冲区中，而stderr直接输出到屏幕（因为我们总是希望尽快就看到错误提示）。如果希望马上就的到错误信息，常用如下语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fprintf(stderr,&quot;something wrong\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是stdin或者是stdout都是不可修改的，因为它们是常量。虽然c语言有提供重定向函数&lt;code&gt;freopen()&lt;/code&gt;，但是一般不建议使用。&lt;/p&gt;

&lt;h2&gt;字符输入输出函数&lt;/h2&gt;

&lt;p&gt;在介绍scanf之前，我们还是循序渐进的现介绍以下他的兄弟连——各种字符输入输出函数。&lt;/p&gt;

&lt;p&gt;首先是最简单的getchar(),putchar()，需要注意的是这两个函数都是读取一个字符，无论他是不是空白字符（这里的空白字符主要是指\n,\t,以及空格等）。虽然简单，但是还是可能出现一些小问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char a,b;
getchar(a);
putchar(&#39;a&#39;);putchar(a);putchar(&#39;\n&#39;);
getchar(b);
putchar(&#39;b&#39;);putchar(b);putchar(&#39;\n&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，当我们输出xy再回车的时候，出现的我们预期的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax
by
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当我们输入x回车的时候却出现了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax
b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是刚刚说的getchar(),putchar()会接收当下的任何字符，包括回车。&lt;/p&gt;

&lt;p&gt;然后是字符串输入输出函数gets()和puts()。需要了解的就是gets()总是以回车结束，所以不会带走回车，但是可以带走中间的/t,/b等等空白符。&lt;/p&gt;

&lt;h2&gt;scanf&lt;/h2&gt;

&lt;p&gt;下面是本文的主要内容scanf。我们需要清楚两个关键的概念：缓冲区和空白符。空白符前面已经说过了，什么是缓冲区呢？在使用scanf或者gets函数的时候，键盘的输入最先都被保存在缓冲区中，直到输入回车，相应的输入函数才会从缓冲区中读取数据。输入函数从缓冲区读取数据的时候，如果缓冲区为空，函数将等待用户输入，如果不为空，会直接从缓冲区中读取字符。这是一个比较关键的概念，有助于理解下面的问题。&lt;/p&gt;

&lt;p&gt;scanf的函数定义原型如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int scanf(&quot;格式&quot;,地参数);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，函数的返回值是int类型。实际上，scanf函数正确匹配了几个输入参数，返回值就是几。&lt;/p&gt;

&lt;p&gt;下面一个例子来说明scanf函数的主要方面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scanf(&quot;%c,%s %d&quot;,&amp;amp;ch,str,&amp;amp;a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要正确的输入该改函数，我们需要从键盘输入&lt;code&gt;字符,字符串 整数&lt;/code&gt;，如果如果成功的读入，返回值将是3（而不是5）。在输入过程中，一定要在正确的位置输入&lt;code&gt;,&lt;/code&gt;和&lt;code&gt;&lt;/code&gt;与格式匹配。如果不匹配，scanf会失败并且退出。值得注意的是，如果格式里面又空白字符，那么scanf会从stdin中读取空白字符匹配，直到遇到下一个非空白字符，也就是说输入两三个空白字符也是无所谓的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scanf(&quot;%c&quot;,&amp;amp;c)&lt;/code&gt;在读取单个字符的时候跟&lt;code&gt;getchar()&lt;/code&gt;完全一样，读取数字的时候只要类型匹配就对了，不必多说。最扰人的地方是读取字符串，而出事的关键就在于缓冲区！如果还不理解缓冲区，那就管会google一下&lt;/p&gt;

&lt;p&gt;下面看一个几乎所有初学者都遇到过的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i;
while(1){
    printf(&quot;*&quot;);
    scanf(&quot;%d&quot;,&amp;amp;i);
    if(i==1)
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面函数，只要任意输入一个非数字字符，函数就会陷入死循环不停的输出*，您最好亲自再试一试是不是这样的。&lt;/p&gt;

&lt;p&gt;造成无限循环的原因就是scanf按照格式读取的时候失败自动退出，但是他&lt;em&gt;不会清空缓冲区&lt;/em&gt;。于是，我们在输入错误一次后，比如说输入a，scanf发现不匹配，马斯就退出了，但是当下次循环时候，scanf发现缓冲区不空就不会等待输入，又继续匹配不成功，一直这样想去就死循环了。&lt;/p&gt;

&lt;p&gt;那么，这时候我们就需要在每次匹配过后清空缓冲区，我是这样写的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a;
char c;
while(1){
    printf(&quot;*&quot;);
    scanf(&quot;%d&quot;,&amp;amp;a);
    while((c=getchar)!=&#39;\n&#39; &amp;amp;&amp;amp; c!=EOF)
        ;
    if(a==1)
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些书上说fflush(stdin)可以清空缓冲区，但是我在使用gcc的时候并没有成功。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;除了缓冲区和格式匹配之外，scanf还可能引发其他很多奇奇怪怪的问题。很多时候我们知道它错了，但是却不知道它为什么错了。所以把scanf说成c函数库中最复杂的函数之一是没问题的。&lt;/p&gt;

&lt;p&gt;解决问题最好的方法就是不让他发生，所以在不熟悉的情况下，尽量使用其他函数来代替scanf，比如说先用fgets()来读取用户输入的整行，然后再用sscanf，strtol，atoi等函数来解析读取的行。这样的好处是，就算我们解析失败了，还可以用其他解析函数来重新解析fgets中的数据&lt;/p&gt;

&lt;p&gt;最长用的算是sscanf了，他从字符串中读取与指定格式匹配的数据。比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char buf[1024];
fgets(buf,sizeof(buf),stdin);
if(sscanf(buf,&quot;%d %c %d&quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c)==3)
    printf(&quot;OK\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面罗嗦的过程中，我们可以简单总结出几个要点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;scanf输入字符的时候，任何字符都不会被忽视&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scanf输入数字和字符串的时候，空白字符会被当成输入结束&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;键盘的输入都被保存到缓冲区，直到输入回车输入函数才会去读取缓冲区。输入函数读取缓冲区的时候，如果缓冲区为空，程序会等待输入；如果不为空，程序会直接读取缓冲区中字符&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scanf读取成功会清空缓冲区，读取不成功不会清空缓冲区&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Sat, 15 Dec 2012 00:00:00 +0800</pubDate>
				<link>/2012/12/15/C-scanf.html</link>
				<guid isPermaLink="true">/2012/12/15/C-scanf.html</guid>
			</item>
		
			<item>
				<title>使用Github Pages建独立博客</title>
        <description>&lt;h3&gt;转自&lt;a href=&quot;http://www.beiyuu.com&quot;&gt;www.beiyuu.com&lt;/a&gt;增删涂改个人信息，感谢分享&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;Github&quot;&gt;Github&lt;/a&gt;很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如&lt;a href=&quot;https://github.com/jquery/jquery&quot; title=&quot;jQuery@github&quot;&gt;jQuery&lt;/a&gt;、&lt;a href=&quot;https://github.com/twitter/bootstrap&quot; title=&quot;Twitter@github&quot;&gt;Twitter&lt;/a&gt;等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。&lt;/p&gt;

&lt;p&gt;Github Pages有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
    &lt;li&gt;使用标记语言，比如&lt;a href=&quot;http://markdown.tw&quot;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;无需自己搭建服务器&lt;/li&gt;
    &lt;li&gt;根据Github的限制，对应的每个站有300MB空间&lt;/li&gt;
    &lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然他也有缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;模板系统，相当于静态页发布，适合博客，文档介绍等。&lt;/li&gt;
&lt;li&gt;动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。&lt;/li&gt;
&lt;li&gt;基于Git，很多东西需要动手，不像Wordpress有强大的后台&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。&lt;/p&gt;

&lt;h2&gt;购买、绑定独立域名&lt;/h2&gt;

&lt;p&gt;虽说&lt;a href=&quot;http://www.godaddy.com/&quot; title=&quot;Godaddy&quot;&gt;Godaddy&lt;/a&gt;曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。&lt;/p&gt;

&lt;p&gt;域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。&lt;/p&gt;

&lt;p&gt;流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在[dantangfan][]也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。&lt;/p&gt;

&lt;p&gt;我们选择&lt;a href=&quot;https://www.dnspod.cn/&quot; title=&quot;DNSPod&quot;&gt;DNSPod&lt;/a&gt;的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;首先添加域名记录，可参考DNSPod的帮助文档：&lt;a href=&quot;https://www.dnspod.cn/Support&quot;&gt;https://www.dnspod.cn/Support&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;在DNSPod自己的域名下添加一条&lt;a href=&quot;http://baike.baidu.com/view/65575.htm&quot;&gt;A记录&lt;/a&gt;，地址就是Github Pages的服务IP地址：207.97.227.245&lt;/li&gt;
    &lt;li&gt;在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：&lt;a href=&quot;https://www.dnspod.cn/support/index/fid/119&quot;&gt;Godaddy注册的域名如何使用DNSPod&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;等待域名解析生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;域名的配置部分完成，跪谢方校长。&lt;/p&gt;

&lt;h2&gt;配置和使用Github&lt;/h2&gt;

&lt;p&gt;Git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本&lt;a href=&quot;http://progit.org/book/zh/&quot; title=&quot;Pro Git中文版&quot;&gt;Git中文教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/list&quot; title=&quot;Windows版Git客户端&quot;&gt;http://code.google.com/p/msysgit/downloads/list&lt;/a&gt;。其他系统的安装也可以参考官方的&lt;a href=&quot;http://help.github.com/mac-set-up-git/&quot; title=&quot;Mac下Git安装&quot;&gt;安装教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。&lt;/p&gt;

&lt;p&gt;在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）：
&lt;img src=&quot;/images/githubpages/bootcamp_1_win_gitbash.jpg&quot; alt=&quot;Git Bash&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1、检查SSH keys的设置&lt;/h3&gt;

&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示“No such file or directory”，跳到第三步，否则继续。&lt;/p&gt;

&lt;h3&gt;2、备份和移除原来的ssh key设置：&lt;/h3&gt;

&lt;p&gt;因为已经存在key文件，所以需要备份旧的数据并删除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
config  id_rsa  id_rsa.pub  known_hosts
$ mkdir key_backup
$ cp id_rsa* key_backup
$ rm id_rsa*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、生成新的SSH Key：&lt;/h3&gt;

&lt;p&gt;输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&amp;lt;回车就好&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后系统会要你输入加密串（&lt;a href=&quot;http://help.github.com/ssh-key-passphrases/&quot;&gt;Passphrase&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后看到这样的界面，就成功设置ssh key了：
&lt;img src=&quot;/images/githubpages/ssh-key-set.png&quot; alt=&quot;ssh key success&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4、添加SSH Key到GitHub：&lt;/h3&gt;

&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;在GitHub的主页上点击设置按钮：
&lt;img src=&quot;/images/githubpages/github-account-setting.png&quot; alt=&quot;github account setting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：
&lt;img src=&quot;/images/githubpages/bootcamp_1_ssh.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS：如果需要配置多个GitHub账号，可以参看这个&lt;a href=&quot;http://omiga.org/blog/archives/2269&quot;&gt;多个github帐号的SSH key切换&lt;/a&gt;，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令&lt;code&gt;git config --global --unset user.email&lt;/code&gt;删除用户账户设置，在每一个repo下面使用&lt;code&gt;git config --local user.email &#39;你的github邮箱@mail.com&#39;&lt;/code&gt; 命令单独设置用户账户信息&lt;/p&gt;

&lt;h3&gt;5、测试一下&lt;/h3&gt;

&lt;p&gt;可以输入下面的命令，看看设置是否成功，&lt;code&gt;git@github.com&lt;/code&gt;的部分不要修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是下面的反应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要紧张，输入&lt;code&gt;yes&lt;/code&gt;就好，然后会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi &amp;lt;em&amp;gt;username&amp;lt;/em&amp;gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6、设置你的账号信息&lt;/h3&gt;

&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.email &quot;your_email@youremail.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置GitHub的token&lt;/h4&gt;

&lt;p&gt;2012-4-28补充：新版的接口已经不需要配置token了，所以下面这段可以跳过了&lt;/p&gt;

&lt;p&gt;有些工具没有通过SSH来链接GitHub。如果要使用这类工具，你需要找到然后设置你的API Token。&lt;/p&gt;

&lt;p&gt;在GitHub上，你可以点击&lt;em&gt;Account Setting &gt; Account Admin&lt;/em&gt;：
&lt;img src=&quot;/images/githubpages/bootcamp_1_token.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的命令行中，输入下面的命令，把token添加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.token 0123456789your123456789token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你改了GitHub的密码，需要重新设置token。&lt;/p&gt;

&lt;h3&gt;成功了&lt;/h3&gt;

&lt;p&gt;好了，你已经可以成功连接GitHub了。&lt;/p&gt;

&lt;h2&gt;使用GitHub Pages建立博客&lt;/h2&gt;

&lt;p&gt;与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的&lt;code&gt;username.github.io&lt;/code&gt;这样的用户&amp;amp;组织页（站），另一种是依附项目的pages。&lt;/p&gt;

&lt;h3&gt;User &amp;amp; Organization Pages&lt;/h3&gt;

&lt;p&gt;想建立个人博客是用的第一种，形如&lt;code&gt;beiyuu.github.io&lt;/code&gt;这样的可访问的站，每个用户名下面只能建立一个，创建之后点击&lt;code&gt;Admin&lt;/code&gt;进入项目管理，可以看到是这样的：
&lt;img src=&quot;/images/githubpages/user-pages.png&quot; alt=&quot;user pages&quot; /&gt;
而普通的项目是这样的，即使你也是用的&lt;code&gt;othername.github.io&lt;/code&gt;：
&lt;img src=&quot;/images/githubpages/other-pages.png&quot; alt=&quot;other pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建好&lt;code&gt;username.github.io&lt;/code&gt;项目之后，提交一个&lt;code&gt;index.html&lt;/code&gt;文件，然后&lt;code&gt;push&lt;/code&gt;到GitHub的&lt;code&gt;master&lt;/code&gt;分支（也就是普通意义上的主干）。第一次页面生效需要一些时间，大概10分钟左右。&lt;/p&gt;

&lt;p&gt;生效之后，访问&lt;code&gt;username.github.io&lt;/code&gt;就可以看到你上传的页面了，&lt;a href=&quot;http://dantangfan.github.io&quot;&gt;dantangfan.github.io&lt;/a&gt;就是一个例子。&lt;/p&gt;

&lt;p&gt;关于第二种项目&lt;code&gt;pages&lt;/code&gt;，简单提一下，他和用户pages使用的后台程序是同一套，只不过它的目的是项目的帮助文档等跟项目绑定的内容，所以需要在项目的&lt;code&gt;gh-pages&lt;/code&gt;分支上去提交相应的文件，GitHub会自动帮你生成项目pages。具体的使用帮助可以参考&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的官方文档：&lt;/p&gt;

&lt;h3&gt;绑定域名&lt;/h3&gt;

&lt;p&gt;我们在第一部分就提到了在DNS部分的设置，再来看在GitHub的配置，要想让&lt;code&gt;username.github.io&lt;/code&gt;能通过你自己的域名来访问，需要在项目的根目录下新建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，文件内容形如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以绑定在二级域名上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blog.beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要提醒的一点是，如果你使用形如&lt;code&gt;beiyuu.com&lt;/code&gt;这样的一级域名的话，需要在DNS处设置A记录到&lt;code&gt;207.97.227.245&lt;/code&gt;（&lt;strong&gt;这个地址会有变动，&lt;a href=&quot;https://help.github.com/articles/my-custom-domain-isn-t-working&quot;&gt;这里&lt;/a&gt;查看&lt;/strong&gt;），而不是在DNS处设置为CNAME的形式，否则可能会对其他服务（比如email）造成影响。&lt;/p&gt;

&lt;p&gt;设置成功后，根据DNS的情况，最长可能需要一天才能生效，耐心等待吧。&lt;/p&gt;

&lt;h2&gt;Jekyll模板系统&lt;/h2&gt;

&lt;p&gt;GitHub Pages为了提供对HTML内容的支持，选择了&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看&lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/README.textile&quot;&gt;Jekyll官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;你可以直接fork&lt;a href=&quot;https://github.com/dantangfan/dantangfan.github.com&quot;&gt;我的项目&lt;/a&gt;，然后改名，就有了你自己的满足Jekyll要求的文档了，当然你也可以按照下面的介绍自己创建。&lt;/p&gt;

&lt;h3&gt;Jekyll基本结构&lt;/h3&gt;

&lt;p&gt;Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过&lt;code&gt;layout&lt;/code&gt;将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。&lt;/p&gt;

&lt;p&gt;基本的Jekyll结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单介绍一下他们的作用：&lt;/p&gt;

&lt;h4&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;配置文件，用来定义你想要的效果，设置之后就不用关心了。&lt;/p&gt;

&lt;h4&gt;_includes&lt;/h4&gt;

&lt;p&gt;可以用来存放一些小的可复用的模块，方便通过&lt;code&gt;{ % include file.ext %}&lt;/code&gt;（去掉前两个{中或者{与%中的空格，下同）灵活的调用。这条命令会调用_includes/file.ext文件。&lt;/p&gt;

&lt;h4&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这是模板文件存放的位置。模板需要通过&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML front matter&lt;/a&gt;来定义，后面会讲到，&lt;code&gt;{ { content }}&lt;/code&gt;标记用来将数据插入到这些模板中来。&lt;/p&gt;

&lt;h4&gt;_posts&lt;/h4&gt;

&lt;p&gt;你的动态内容，一般来说就是你的博客正文存放的文件夹。他的命名有严格的规定，必须是&lt;code&gt;2012-02-22-artical-title.MARKUP&lt;/code&gt;这样的形式，MARKUP是你所使用标记语言的文件后缀名，根据_config.yml中设定的链接规则，可以根据你的文件名灵活调整，文章的日期和标记语言后缀与文章的标题的独立的。&lt;/p&gt;

&lt;h4&gt;_site&lt;/h4&gt;

&lt;p&gt;这个是Jekyll生成的最终的文档，不用去关心。最好把他放在你的&lt;code&gt;.gitignore&lt;/code&gt;文件中忽略它。&lt;/p&gt;

&lt;h4&gt;其他文件夹&lt;/h4&gt;

&lt;p&gt;你可以创建任何的文件夹，在根目录下面也可以创建任何文件，假设你创建了&lt;code&gt;project&lt;/code&gt;文件夹，下面有一个&lt;code&gt;github-pages.md&lt;/code&gt;的文件，那么你就可以通过&lt;code&gt;yoursite.com/project/github-pages&lt;/code&gt;访问的到，如果你是使用一级域名的话。文件后缀可以是&lt;code&gt;.html&lt;/code&gt;或者&lt;code&gt;markdown&lt;/code&gt;或者&lt;code&gt;textile&lt;/code&gt;。这里还有很多的例子：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;https://github.com/mojombo/jekyll/wiki/Sites&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jekyll的配置&lt;/h3&gt;

&lt;p&gt;Jekyll的配置写在_config.yml文件中，可配置项有很多，我们不去一一追究了，很多配置虽有用但是一般不需要去关心，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/configuration&quot;&gt;官方配置文档&lt;/a&gt;有很详细的说明，确实需要了可以去这里查，我们主要说两个比较重要的东西，一个是&lt;code&gt;Permalink&lt;/code&gt;，还有就是自定义项。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Permalink&lt;/code&gt;项用来定义你最终的文章链接是什么形式，他有下面几个变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;year&lt;/code&gt; 文件名中的年份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;month&lt;/code&gt; 文件名中的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;day&lt;/code&gt; 文件名中的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt; 文件名中的文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories&lt;/code&gt; 文章的分类，如果文章没有分类，会忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-month&lt;/code&gt; 文件名中的除去前缀0的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-day&lt;/code&gt; 文件名中的除去前缀0的日期&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;看看最终的配置效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: pretty&lt;/code&gt; /2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /:month-:day-:year/:title.html&lt;/code&gt; /04-29-2009/slap-chop.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /blog/:year/:month/:day/:title&lt;/code&gt; /blog/2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我使用的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: /:title&lt;/code&gt; /github-pages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;自定义项的内容，例如我们定义了&lt;code&gt;title:BeiYuu的博客&lt;/code&gt;这样一项，那么你就可以在文章中使用&lt;code&gt;{ { site.title }}&lt;/code&gt;来引用这个变量了，非常方便定义些全局变量。&lt;/p&gt;

&lt;h3&gt;YAML Front Matter和模板变量&lt;/h3&gt;

&lt;p&gt;对于使用YAML定义格式的文章，Jekyll会特别对待，他的格式要求比较严格，必须是这样的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前后的&lt;code&gt;---&lt;/code&gt;不能省略，在这之间，你可以定一些你需要的变量，layout就是调用&lt;code&gt;_layouts&lt;/code&gt;下面的某一个模板，他还有一些其他的变量可以使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink&lt;/code&gt; 你可以对某一篇文章使用通用设置之外的永久链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;published&lt;/code&gt; 可以单独设置某一篇文章是否需要发布&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt; 设置文章的分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 设置文章的tag&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面的&lt;code&gt;title&lt;/code&gt;就是自定义的内容，你也可以设置其他的内容，在文章中可以通过&lt;code&gt;{ { page.title }}&lt;/code&gt;这样的形式调用。&lt;/p&gt;

&lt;p&gt;模板变量，我们之前也涉及了不少了，还有其他需要的变量，可以参考官方的文档：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/template-data&quot; title=&quot;Jekyll Template Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/template-data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;使用Disqus管理评论&lt;/h2&gt;

&lt;p&gt;模板部分到此就算是配置完毕了，但是Jekyll只是个静态页面的发布系统，想做到关爽场倒是很容易，如果想要评论呢？也很简单。&lt;/p&gt;

&lt;p&gt;现在专做评论模块的产品有很多，比如&lt;a href=&quot;http://disqus.com/&quot;&gt;Disqus&lt;/a&gt;，还有国产的&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说&lt;/a&gt;，Disqus对现在各种系统的支持都比较全面，到写博客为止，多说现在仅是WordPress的一个插件，所以我这里暂时也使用不了，多说与国内的社交网络紧密结合，还是有很多亮点的，值得期待一下。我先选择了Disqus。&lt;/p&gt;

&lt;p&gt;注册账号什么的就不提了，Disqus支持很多的博客平台，参见下图：
&lt;img src=&quot;/images/githubpages/disqus-site.jpg&quot; alt=&quot;Disqus sites&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们选择最下面的&lt;code&gt;Universal Code&lt;/code&gt;就好，然后会看到一个介绍页面，把下面这段代码复制到你的模板里面，可以只复制到显示文章的模板中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;disqus_thread&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = &#39;example&#39;; // required: replace example with your forum shortname 这个地方需要改成你配置的网站名

    /* * * DON&#39;T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement(&#39;script&#39;); dsq.type = &#39;text/javascript&#39;; dsq.async = true;
        dsq.src = &#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;
        (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);
    })();
&amp;lt;/script&amp;gt;
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&amp;gt;comments powered by Disqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&amp;gt;blog comments powered by &amp;lt;span class=&quot;logo-disqus&quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完之后，你也可以做一些异步加载的处理，提高性能，比如我就在最开始页面打开的时候不显示评论，当你想看评论的时候，点击“显示评论”再加载Disqus的模块。代码很简单，你可以参考我的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#disqus_container .comment&#39;).on(&#39;click&#39;,function(){
        $(this).html(&#39;加载中...&#39;);
        var disqus_shortname = &#39;beiyuu&#39;;
        var that = this;
        BYB.includeScript(&#39;http://&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;,function(){$(that).remove()}); //这是一个加载js的函数
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不喜欢Disqus的样式，你也可以根据他生成的HTML结构，自己改写样式覆盖它的，Disqus现在也提供每个页面的评论数接口，&lt;a href=&quot;http://docs.disqus.com/developers/universal/&quot;&gt;帮助文档&lt;/a&gt;在这里可以看到。&lt;/p&gt;

&lt;h2&gt;代码高亮插件&lt;/h2&gt;

&lt;p&gt;如果写技术博客，代码高亮少不了，有两个可选插件&lt;a href=&quot;http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine&quot;&gt;DlHightLight代码高亮组件&lt;/a&gt;和&lt;a href=&quot;http://code.google.com/p/google-code-prettify/&quot;&gt;Google Code Prettify&lt;/a&gt;。DLHightLight支持的语言相对较少一些，有js、css、xml和html，Google的高亮插件基本上任何语言都支持，也可以自定义语言，也支持自动识别，也有行号的特别支持。&lt;/p&gt;

&lt;p&gt;Google的高亮插件使用也比较方便，只需要在&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;的标签上加入&lt;code&gt;prettyprint&lt;/code&gt;即可。所以我选择了Google Code Prettify。&lt;/p&gt;

&lt;h2&gt;搭建本地jekyll环境&lt;/h2&gt;

&lt;p&gt;这里主要介绍一下在Mac OS X下面的安装过程，其他操作系统可以参考官方的&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Install&quot;&gt;jekyll安装&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作为生活在水深火热的墙内人民，有必要进行下面一步修改gem的源，方便我们更快的下载所需组建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem sources --remove http://rubygems.org/
sudo gem sources -a http://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用Gem安装jekyll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般如果有出错提示，你可能需要这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我到了这一步的时候总是提示错误&lt;code&gt;Failed to build gem native extension&lt;/code&gt;，很可能的一个原因是没有安装rvm，&lt;a href=&quot;https://rvm.io/rvm/install/&quot;&gt;rvm的安装&lt;/a&gt;可以参考这里，或者敲入下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://get.rvm.io | bash -s stable --ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要安装Markdown的解释器，这个需要在你的_config.yml里面设置&lt;code&gt;markdown:rdiscount&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，如果一切顺利的话，本地环境就基本搭建完成了，进入之前我们建立的博客目录，运行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，你就可以通过&lt;code&gt;localhost:4000&lt;/code&gt;来访问了。还有关于&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll bootstrap&lt;/a&gt;的资料，需要自己修改调试的，可以研究一下。&lt;/p&gt;

&lt;p&gt;我在这个过程中还遇到两个诡异的没有解决的问题，一个是我放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，可以通过&lt;code&gt;beiyuu.com/blog&lt;/code&gt;访问的到，但是在本地环境下，总是&lt;code&gt;not found&lt;/code&gt;，很是让人郁闷，看生成的&lt;code&gt;_site&lt;/code&gt;目录下面的文件，也是正常的&lt;code&gt;blog.html&lt;/code&gt;，但就是找不到，只有当我把URL改为&lt;code&gt;localhost:4000/blog.html&lt;/code&gt;的时候，才能访问的到，环境不同真糟糕。&lt;/p&gt;

&lt;p&gt;还有一个是关于&lt;code&gt;category&lt;/code&gt;的问题，根据&lt;code&gt;YAML&lt;/code&gt;的语法，我们在文章头部可以定义文章所属的类别，也可以定义为&lt;code&gt;category:[blog,rss]&lt;/code&gt;这样子的多类别，我在本地试一切正常，但是push到GitHub之后，就无法读取了，真让人着急，没有办法，只能采用别的办法满足我的需求了。这里还有一篇&lt;a href=&quot;http://chxt6896.github.com/blog/2012/02/13/blog-jekyll-native.html&quot;&gt;Jekyll 本地调试之若干问题&lt;/a&gt;，安装中如果有其他问题，也可以对照参考一下。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;如果你跟着这篇不那么详尽的教程，成功搭建了自己的博客，恭喜你！剩下的就是保持热情的去写自己的文章吧。&lt;/p&gt;
</description>
				<pubDate>Fri, 09 Nov 2012 00:00:00 +0800</pubDate>
				<link>/2012/11/09/learn-gitPage.html</link>
				<guid isPermaLink="true">/2012/11/09/learn-gitPage.html</guid>
			</item>
		
			<item>
				<title>从一个地方到另一个地方</title>
        <description>&lt;p&gt;好久没有远离自己了，从心里靠近自己，从日子的鞭笞中醒过来，让放纵的生活重新回到正轨。凝视这周围的一切，才发现，我变了。&lt;/p&gt;

&lt;p&gt;好像这就是事实一样，有些事情我们可以改变，我们就应该让它向最好的方向，有些事不可以改变，我们就应该学会接受，至少这样不至于心力交瘁。生活就是一出悲剧，一场戏，我们在等待自己戈多的时候至少不应该只是挖挖鼻屎，扣扣脚趾。如果死亡只是为了明白一些事，那么活着难道不就是用来反思的么？&lt;/p&gt;

&lt;p&gt;成长了，偶尔忍不住停下脚步思考人生，感觉好像这样我们就老了。反反复复的唱着同样的歌，好像好久没有接触过新的明星了，感觉没意思。还有那种冲动，希望一个人活着两个人背着乌龟壳去穷旅，想想过完大学就不会有那样的激情了吧。不久前，跟高中同学一起去ktv，一开口就是筷子兄弟的《老男孩》，狗狗不假思索的就感慨了一句“哎，你也是老男孩。”当时有一种不知道的滋味，难易言表的，突然想想身边好多的朋友都已经成家立业了，虽然好多都是典型的打工仔，大多数应该是已经误了下半生吧，真心希望每个人都能闯出自己的天空。自己还在大学纠结，我们选择的路就是一条大众的道路，就算是不成功，至少还是可以养家糊口，讨个老婆过日子。&lt;/p&gt;

&lt;p&gt;又想起农民说过的话“将来我不当警察就要当强盗！”现在还是在大学挣扎，挣扎就挣扎吧，我看我还是只有当强盗了，最可恨的值恐怕我们现在连当强盗的勇气都没有了。好像年轻的人都是有豪情壮志的，但是现在就老了么？20岁的我们好像都每有当年的激情了，只是在自己的专业上下功夫，但是又有几个是自己钟爱的专业呢？我们经常说，但是却很少人做了。花一些时间做自己喜欢做的事情，我们都用很能接受的理由拒绝了，太忙，太累，太不现实….那次舅舅要我事事要听他的安排的时候，虽然知道那样可以走很少的弯路，但是我还是义正言辞的拒绝了，要是20岁的时候都不敢做自己想做的事情，那么你30岁40岁还能干嘛！&lt;/p&gt;

&lt;p&gt;想想，要是这几年没有背上我的旅行包，兴许一辈子都没有机会了。&lt;/p&gt;

&lt;p&gt;好像还真的有人甘于平庸，在简单的幸福中度过，狼王就是那样的吧。好像很久没有见到了，大概是有两年了，最近过年本来就是要在喝酒的，但是寡人身体不适就没有干成，约好明年，又不知道明年我还回家么。有些事就是这样，错过了就没有机会了，虽然不带有任何伤感，但为免有些遗憾。多少还是三郎钦点的变异僵尸狼王嘛~&lt;/p&gt;

&lt;p&gt;已经忘了上高中时候回家坐车的那种激动了，只记得当时是多喜欢坐车啊！而且只能是那种很多人挤的公共汽车，上面坐满了学生，都是回家的。就是偶尔有一两个老人或者是带小孩的人上车还是没有人理，然后就自己默默地站起来让座，也不会受到答谢，好像从来就是这样的，我就应该让座。这就不得不想去起车窗外的世界了，每一次坐车都是间隔一两个月，窗外都会是另一番景象。油菜花应该开的像金色地毯了吧！上面零星的飘着几只快活的蜜蜂，一看就知道是家养的！短短的身体还有圆圆的屁股，怎么打也打不走。只知道车上偶尔会闯进一两只，惊慌的窜来窜去...还记得以前还写过一篇关于车上的杂记，被松哥表扬过的，内容大概就是说人们怎么花钱找罪受，就像要当奴隶一样，被人家给卖了还欢欢喜喜的帮人数钱。想起来还真是搞笑，咋现在就没有那文艺劲儿呢！现在看到两个男的就是好基友，两个女的就是好蕾丝，一男一女就是好奇怪….还好，我还属于好奇怪。&lt;/p&gt;

&lt;p&gt;生活就是这样，只要勇气跨出第一步，一切都会比先前想的好。&lt;/p&gt;

&lt;p&gt;有的人忍受不了生活的平淡而死去，却不知生命本来就是一个奇迹，因此受宫刑的人很多，而司马迁只有一个。人性本色，出生的时候都是原创，但渐渐地你就成了赝品，成了别人的翻版，你只能是xx第二。科比之所以要争第一，因为第二就是第一个失败者。过去再优美，我们不能住进去，未来在艰险，我们只能挺过去。那天又看到了那张退学申请书，忍不住还是笑了，很高兴当时可以那么大胆，可是当时是多么的无助啊！！做的最坏的打算就是泡不到妞而且成绩也不会比那一次好，可笑的是老天爷还真的老是忘坏处走，欲哭无泪。为什么就不让我才色兼收呢！嗯，想想还是没有什么不对，就像二胡说的，我总是在丑与美的边缘徘徊，两边都不进去..可恶的二胡已经进入了丑的包围圈了！我们不去想是否能成功，我们不去想身后会不会袭来寒风冷雨，既然目标是地平线，留给世间的就只能是背影。二胡还是如愿以偿的走向了自己漫画的世界，可能有一天我活着我的儿子看到的就是那样一位大师了，我还可以吹嘘我们的友情，额，前提是人家还记得我这个恶心的同桌。&lt;/p&gt;

&lt;p&gt;还好我不是孤独的，我还有几枚好基友，胖子包养了我几年，波仔又陪睡了几年，好基友的价值就是在你没有女人的时候第一时间变成你的女人。好吧，不得不承认现在有多了一个好女友，一个会吃男人的醋的女人…&lt;/p&gt;

&lt;p&gt;但是呢，我现在还是一个穷光蛋，算不得一个男人，当有一天能靠自己的双手让自己的家人过得幸福的时候就算是男人了。我并不奢侈情感的丰富多彩，本来我就是个无趣的人了，我说的是对自己没有兴趣。幸福是用来感觉的，感情是用来维系的，情人是用来疼爱的，要感谢的是你在我一无是处的时候选择了我。陈哥说男人对女人的誓言都是放屁，你说誓言就是别人不信而自己却深信不疑的情话。爱是人间最美好的情感，也是世间最迷人的渴望，爱与被爱都是一种幸福，希望你能一直吃着幸福的棉花糖，笑得像只猴子。&lt;/p&gt;

&lt;p&gt;但是呢，渐渐地还是西喜欢上了充实的感觉。忙碌是一种幸福，奔波是一种快乐，疲惫是一种享受。跟小东仔聊天他说起喜欢快节奏的生活，那是一种人生追求，永远不会疲惫，永远保持着兴奋。忙碌带走感性，奔波书写生活，疲惫祛除空虚。渐渐地从慢节奏的生活中醒悟过来，充满激情的过着三点一线的生活。&lt;/p&gt;

&lt;p&gt;突然才发发现，自己已经从一个地方到了另一个地方。可以毫无畏惧的做事，不用考虑任何阻力。心智成熟了，人才能成长，走出自己生活的罅隙才能看到新的希望。&lt;/p&gt;
</description>
				<pubDate>Fri, 24 Feb 2012 00:00:00 +0800</pubDate>
				<link>/2012/02/24/yearOf2011.html</link>
				<guid isPermaLink="true">/2012/02/24/yearOf2011.html</guid>
			</item>
		
	</channel>
</rss>
