<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>c语言学习-内存</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,300i,600">
  <link rel="stylesheet" href="/style.css">
  </head>
<body>
  <div class="container">
    <header class="masthead">
  <h1 class="masthead-title--small">
    <a href="/">Dantangfan</a>
  </h1>
</header>      
<div class="content post">
  <h1 class="post-title">c语言学习-内存</h1>
  <div class="post-date">
    <time>15 Jul 2013</time>
  </div>
  <h2>运行时的数据结构</h2>

<h3>分段</h3>

<p>在*nix中，我们使用gcc不用任何参数的时候，输出的二进制可执行文件总是a.out。他是'assembler output'的缩写，由链接器输出。目标文件和可执行文件一般都有特定的格式，常用的linux往往是使用ELF(Extensible and Linking Format)格式，可以通过<code>man a.out</code>查看它的详细信息。这些不同的格式都具有同一个概念，那就是断(segments/section)。它是ELF文件的最小组成单位，但是我们要跟x86里面的分段（内存管理方式）区分开来。linux中可以用一个size命令来查看一个可执行文件的分段大小</p>

<pre><code>hj@dantangfan:~/code/c_code$ size test
   text    data     bss     dec     hex filename
   1259     576       8    1843     733 test
hj@dantangfan:~/code/c_code$ 
</code></pre>

<p>众所周知的是编译后的a.out从高地址到低地址分别有<code>其他内容--&gt;BSS段所需大小--&gt;数据段--&gt;文本段</code>。值得注意的是BSS段只保存没有值的变量，所以他事实上是不需要保存这些变量的映像的。运行时所需要的BSS段的大小记录在目标文件中，但BSS并不占目标文件任何空间（除了记录大小所需要的空间）。</p>

<p>段可以方便的映射到链接器在运行时可以直接载入的对象中，段在正在执行的程序中是一块内存区域，每个区域都有特定的目的。文本段包含程序的指令，连接器把指令直接从文本拷贝到内存中，在典型的情况下，程序的文本无论是内容还是大小都不会改变。</p>

<h3>进程空间</h3>

<p>又一个中所周知的事实是程序在内存中运行交进程，进程的地址空间从高到低可以简单概括成<code>堆栈--&gt;空洞--&gt;BSS（未经初始化的数据）--&gt;数据段（经过初始化的数据）--&gt;文本段（指令）--&gt;未映射地区</code>。数据段包含了全局变量和静态变量以及他们的值，BSS段的大小可以直接从可执行文件中得到，然后链接器得到这个大小的内存块跟在数据段后，堆栈段主要保存局部变量、临时变量、传递的参数等等。值得注意的是虚拟地址空间的最低部分是没有被映射的，也就是说啊位于进程的地址空间，但并没有赋予物理地址，所以任何对其引用都是非法的，他通常从地址的起始（0地址）到数k字节，用于捕捉使用空指针和小整型的指针使用内存的ingrain。</p>

<h3>运行时数据结构</h3>

<p>有很多中数据结构存在：堆栈、活动记录、数据、堆等</p>

<h4>堆栈段</h4>

<p>主要有三个用途，两个跟函数有关，一个跟表达式计算有关。指针sp通常指向堆栈当前的顶部位置。</p>

<ul>
<li><p>堆栈位函数内部声明的局部变量（自动变量）提供存储空间。</p></li>
<li><p>进行函数调用的时候，堆栈存储与此有关的一些维护信息（活动记录），这些信息包含函数调用地址（即当所有调用函数结束之后应该跳回的地址）、任何不适合装入寄存器的参数、寄存器值。</p></li>
<li><p>堆栈也可以用来当成暂时存储区（表达式计算）。</p></li>
</ul>


<h4>过程活动记录</h4>

<p>我们需要知道的是过程活动记录是一种数据结构，用于支持过程调用，并记录调用结束霍返回调用点所需要的全部信息。运行时系统维护一个指针fp，用于提示活动堆栈结构，他的值是最靠井堆栈顶部的过程活动记录的地址。</p>

<h2>内存问题</h2>

<h3>80x86内存模型</h3>

<p>在Intel80x86内存模型中，分段是很重要的设计，各个处理器的地址空间不同，但他们都被分割成64KB为单位的区域，这样每一个区域的简称就叫段。</p>

<p>作为80x86内存模型最基本的形式，8086中的段是一块64KB的内存区域，由一个段寄存器指向。内存地址的行程经过是：取得段寄存器值左移四位，然后再加上偏移地址，就形成了一个20位的寻址空间（1M）。8086中常见的寄存器是CS（代码寄存器）、DS（数据寄存器）、SS（堆栈寄存器）和ES（附加段）。</p>

<h3>虚拟内存</h3>

<p>让程序受安装在机器上的物理内存限制是很不方便的，于是就有了虚拟内存————在任意给定时刻，程序实际需要使用的虚拟内存区段的内容就被载入物理内存中，当物理内存中的数据有一段时间未被使用，它就可能被注意到硬盘中，节省下来的物理内存空间用于载入需要使用的其他数据。虚拟内存是对多成存储进程扩充，使用磁盘而不是贮存来保存运行进程的映像。</p>

<p>虚拟内存通过‘分页’的实行组织。页就是操作系统在磁盘和内存之间移动的单位，一般为几K字节。当内存的映像在磁盘和物理内存间来回移动时，成他们是page in（移入页）/page out（移出页）。</p>

<p>与进程有关的所有内存都将被系统使用，如果进程不马上运行，操作系统可以暂时取回所有分配给他的内存资源，将该进程所有的信息都备份到磁盘上，这个进程就被‘换出’。在磁盘中有一个特殊的‘交换区’，用于保存从内存中换出的进程。一台及其中，交换区的大小一般是物理内存的几倍，而不是网上常说的和内存一样大就行。</p>

<p>进程只能操作位于物理内存中的页面，当进程引用一个不在物理内存中的页面的时候，MMU（内存管理单元）就会产生一个页错误。</p>

<h3>Cache</h3>

<p>Cache是位于内存和CPU之间的一种极快的存储缓冲区。Cache 操作的速度与系统周期时间相同，他包含一个地址表以及他们的内容。随着处理器不断引用新的内处地址，Cache的地址列表也一直出于变化中。所有对内存的读取和写入操作都要经过Cache。当处理器需要从一个特定地址提取数据时，这个请求先递交给Cache，如果数据已经存在在Cache中，他就可以直接被提取。否则，Cache像内存传递这个请求，于是就需要进程缓慢的访问内存的操作。内存读取数据以行为单位，读取的同时也装入到Cache中。</p>

<p>如果你的程序很怪异，以至于每次都没办法命中Cache，那么你的程序的性能比不使用Cache 还要差。</p>

<p>常用的Cache是写回法(write back cache)：当第一次写入时，只需要对Cache写入。如果已经写过的Cache再次写，就将Cache先写回内存。</p>

<h3>堆</h3>

<p>堆用于动态分配内存（**lloc），堆中的所有数据都是匿名的，必须通过指针才能访问。被动态分配的内存总是通过<code>对齐</code>的，以适合及其上最大尺寸的原子访问，一个malloc请求申请的内存个大小位方便一般都被圆整位2的次方。free回收的内存可以重新使用，但是这个时候是没有返回给操作系统的。</p>

<h2>常见错误</h2>

<h3>内存泄漏</h3>

<ul>
<li><p>释放或者改写仍在使用的内存叫内存损坏</p></li>
<li><p>未释放不再使用的内存交内存泄漏</p></li>
</ul>


<p>内存泄漏需要我们十分谨慎的使用malloc和free</p>

<h3>总线错误(bus error)</h3>

<p>总线错误几乎都是由未对齐的内存的读写引起。之所以称之为总线错误，是因为在出现未对齐的内存访问请求时，被阻塞的组件就是地址总线，对齐的意思是数据像只能存储在地址是数据像大小的整数倍的内存位置上。比如</p>

<pre><code class="c">union{
    char a[10];
    int i;
}u;
int *p = (int *)&amp;(u.a[1]);
*p = 17;//总线错误
</code></pre>

<p>这里尽管*p的值是一个ASCII的数字，但是它实际是指的一个字符，存储位置是一个字节，所以现在修改的时候直接改成17,这是一个int类型整数，占据4个字节，于是就出现了总线错误。</p>

<h3>段错误(segmentation fault)</h3>

<p>段错误更常见，可以导致段错误的原因往往有以下几种。</p>

<ul>
<li><p>解除引用一个包含非法值的指针</p></li>
<li><p>解除引用一个空指针</p></li>
<li><p>在未得到正确的权限时进行访问</p></li>
<li><p>用完了堆栈或者堆空间</p></li>
</ul>


<p>长用的解决方法是在free(P)之后再补充P=NULL。</p>

</div>

  </div>
</body>
</html>
