# 数据库相关

### 数据库的4个事务隔离级别是什么？它们之间的区别是什么？是如何实现的？MySQL的默认级别是什么？
 不清楚,没用过

### 谈谈mysql字符集和排序规则？
用 `show character set` 和 `show collation` 来查看支持的字符集,最常见的排序规则是利用大小写或字母的二进制编码进行排序。
不太懂

### varchar与char的区别是什么？大小限制？utf8字符集下varchar最多能存多少个字符
#### varchar 

    保存了可变长度的字符串，是使用较多的字符串类型。它比固定长度类型占用更少的存储空间，因为它只占用了实际需要空间，比较灵活。
    使用额外的1到2字节来存储值得长度。如果列的最大长度小于或等于255，则使用1字节，否则使用2字节。
    的灵活性能节约不少空间，对性能有一定的帮助。但因为是可变长度类型，所以在更新的时候通常长度会发生变化，引发多余的操作。如果行的长度增加并不再适合原始位置时，具体的行为则会和存储引擎相关。
    当长度大于平均长度，并且很少更改的时候，通常适合使用varchar。这样就不会轻易发生磁盘碎片问题。当然跟字符集的选择也有一定的关系，比如UTF8占的长度GBK就不一样，所以每个字符可能会占用不同的存储空间。

#### char
    
    char是固定长度类型，MySQL会为它分配足够的空间。当保存char值得时候，MySQL会自动把末尾空格清除。比较的时候也是同样清除。
    char最佳的使用方案就是存储很短的字符串或者长度近似相同的字符串的时候非常有用。如固定长度的MD5、定长值、短网址等等，不会容易产生碎片，对于很短的值效率高于varchar。char(1)字符串对于单字节字符来说只会占用1个字节，但是varchar(1)会占用2个字节，其中1个字节用来存储长度信息。

####  varchar 最大能放多少个 utf8
> varchar(n) 表示n个字符，无论汉字和英文，MySql都能存入 n 个字符，仅实际字节长度有所区别
mysql的记录行长度是有限制的，不是无限长的，这个长度是64K，即65535个字节，对所有的表都是一样的。
MySQL对于变长类型的字段会有1-2个字节来保存字符长度。
当字符数小于等于255时，MySQL只用1个字节来记录，因为2的8次方减1只能存到255。
当字符数多余255时，就得用2个字节来存长度了。
在utf-8状态下的varchar，最大只能到 (65535 - 2) / 3 = 21844 余 1。
在gbk状态下的varchar, 最大只能到 (65535 - 2) / 2 = 32766 余 1

### primary key和unique的区别？
- Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求
- 一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY
- 主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。

### 外键有什么用，是否该用外键？外键一定需要索引吗？
关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键
比如

```
学生表(学号，姓名，性别，班级) 
其中每个学生的学号是唯一的，学号就是一个主键 
课程表(课程编号,课程名,学分) 
其中课程编号是唯一的,课程编号就是一个主键 
成绩表(学号,课程号,成绩)
```

成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个`主键` 
  
成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的`外键`,同理 成绩表中的课程号是课程表的外键 
定义主键和外键主要是为了维护关系数据库的完整性;主键是能确定一条记录的唯一标识;外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。

1. 互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；
因为也没用过,所以不知道太多

### MySQL的存储引擎，InnoDB的索引的实现算法、具体在硬盘上怎么存的，索引B+Tree的叶子节点存储的具体数据是什么

### mysql索引原理及慢查询优化
http://tech.meituan.com/mysql-index.html
http://blog.codinglabs.org/articles/theory-of-mysql-index.html

### 怎么在mysql中储存树形结构数据（比如节点分支，知乎的话题节点）
https://www.zhihu.com/question/20417447/answer/15078011
http://blog.csdn.net/imagse/article/details/4240998

### 为什么SELECT * FROM table WHERE field = null不能匹配空的字段？

### 什么是ACID(原子性，一致性，隔离性，持久性)原则？

### 什么场景用redis，为什么mysql不适合？
[http://timyang.net/tag/redis/](http://timyang.net/tag/redis/)
Memcache当容量到达瓶颈会 截取LRU链以释放空间。

暂时还没用 redis 做过数据库

1. 缓存

2. 数据库

- 访问量大
- key value或者key list数据结构
- 容量小，可控，可以全部放入内存。由于Redis是单线程设计，因此大value会导致后续的请求一定的堵塞。另外hashset当hgetall时候由于存在遍历操作，也不适合集合太大。如果数据超过单机容量可以使用常规的sharding方法分布到多台机
- 需持久化的场景

 MySQL与Redis各自适合什么样的场景？
数据冷热？
数据大小？
数据量级？
数据增长速度？
是否持久化？
访问量(read/write)？
请求性能要求？

### redis内存满了会怎么样？
redis 相比 mysql 有几个缺点：

1. 内存占用巨大 
2. 持久化并不一定是实时的，此时掉电或者其他故障可能会有大量的数据丢失 

过期时间有两种机制

- 被动过期——client访问key时，判断过期时间选择是否过期
- 主动过期——默认使用valatile-lru

        volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
        volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
        volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
        allkeys-lru：从全部数据集中挑选最近最少使用的数据淘汰
        allkeys-random：从全部数据集中任意选择数据淘汰no-enviction（驱逐）：禁止驱逐数据

所以,内存满的时候,就看看我们的主动过期机制是什么,淘汰是直接删除,还是写回磁盘
maxmemory 参数设置:
设置redis能够使用的最大内存。当内存满了的时候，如果还接收到set命令，redis将先尝试剔除设置过expire信息的key，
而不管该key的过期时间还没有到达。在删除时，将按照过期时间进行删除，
最早将要被过期的key将最先被删除。如果带有expire信息的key都删光了，
那么将返回错误。这样，redis将不再接收写请求，只接收get请求。
maxmemory的设置比较适合于把redis当作于类似memcached的缓存来使用。

### Redis的事务是真事务么？同一时刻能执行多个事务么？
[http://redisdoc.com/topic/transaction.html](http://redisdoc.com/topic/transaction.html)
不是,事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行,并且没有回滚操作.
不能同时执行多个事务(有项关键的),被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。
`乐观锁`

### Redis Server的网络并发模型是什么？实现原理

### Redis 的持久化方式有哪些？实现原理
[http://redisdoc.com/topic/persistence.html](http://redisdoc.com/topic/persistence.html)
- RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照
- AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。
- Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。
- 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

#### RDB
pros

- RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。
- RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。
- RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
- RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

cons

- 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。
- 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。


#### AOF
...

### Redis的hash是如何实现的，rehash的策略

