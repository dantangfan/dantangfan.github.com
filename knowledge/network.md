# 网络

### 几层协议(TCP属于传输层，IP属于网络层)
tcp/udp ip

### tcp与udp的区别;
TCP: 

    面向连接
    可靠传输
    效率低
    全双工
    流量控制(滑动窗口)
    拥塞控制(慢启动,拥塞避免)

UDP:

    非连接
    不可靠
    效率高

### udp调用connect有什么作用？
1. 因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。

### 三次握手和四次挥手的理解
- 为什么要三次握手：避免过时的重复连接再次建立时造成的混乱。比如，客户在某个时刻向服务端发起了一个请求，即一个SYN包。该包由于某种原因未能在链接建立超时之前到达服务器，这个时候客户端就会主动放弃链接，并且释放与该链接有关的所有数据结构。需要注意的是，上面的那个SYN虽然没能准时到达，但是它并没有消失，并且能在其生存周期内到达服务器，这个时候服务器就发一个ACK到客户端，客户端收到这个ACK之后找不到相应的数据结构，于是就会发一个RESET给服务端，这个时候服务器就知道这是一个超时的链接。
- 为什么要有四次挥手：假设主动断开链接的客户端（TCP是全双工，服务器主动断开也适合下面讨论）。服务器收到客户端发来的FIN后，不能马上就断开链接，因为他可能还没有把之前收到的数据交给应用程序处理。因此服务器端就需要等一会儿再通知客户端断开链接，这一段等待时间就确保了之前的所有数据都交给应用程序处理了。也正是由于这段等待的时间，使得服务器端需要主动发一个FIN给客户端来告知链接可以断开了。由于在TCP中收到一个一个数据包（不带数据的ACK除外）都需要确认，所以服务器在收到客户端发送的FIN后需要马上发送一个ACK，不然客户端就会认为它发送的FIN丢失了，就会重发。因此，断开比建立多的一个数据包就是服务器为了保证收到的所有数据都已经交给应用程序处理而发出的那个FIN包。
- 在四次挥手的过程中，主动断开链接的一方在收到服务器端发来的FIN之后，要进入一个TIME_WAIT状态，时间为两倍数据在网络中传输的时间（2MSL），之后才会放开与链接相关的所有数据结果。原因有二：首先是主动断开方在收到服务器发送的FIN之后要发送ACK，但是这个ACK有可能会丢失，这个时候服务器就会重新发送一个FIN,如果这个之前已经把数据结构丢失了，自然就无法处理这个FIN。第二个原因是如果直接释放相关数据结构，那么就意味着该IP和端口可以复用来建立一个新的链接了。这个时候就可能有个问题，由于旧的数据包还在网络中传输并且能在生存周期中达到服务器，这个时候服务器就不知道数据包是旧的还是新的。

### tcp连接中时序图，状态图，必须非常非常熟练;

### tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免?
三次握手,time_wait 是断开连接方在最后一次接受发送 fin 的 ack 之后出现的,用于避免被断开方没能正常接收这个 ack 造成的 fin 重发

不能避免这个状态,只能避免他占用过多资源.
如果是客户端有这个状态,一般可以不用管.
如果是服务端出现这个状态,那么他会占用这个端口,限制这个端口的重新连接,不过我们可以通过socket的选项SO_REUSEADDR来强制进程立即使用处于time_wait状态的连接占用的端口。
通过socksetopt设置后，即使sock处于time_wait状态，与之绑定的socket地址也可以立即被重用。

### tcp头多少字节？哪些字段?(必问)
20字节
源端口\目的端口\序号\确认号\tcp头长度\窗口大小\校验和\可选项

### 什么是滑动窗口?（必问）
简单解释下，发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。

### connect会阻塞，怎么解决?
提示：设置非阻塞，返回之后用select检测状态

### keepalive 是什么东东？如何使用？
TCP是无感知的虚拟连接，中间断开两端不会立刻得到通知。一般在使用长连接的环境下，需要心跳保活机制可以勉强感知其存活。业务层面有心跳机制，TCP协议也提供了心跳保活机制。
一般在 mtqq 之类的协议下使用,默认关闭的

### 列举你所知道的tcp选项，并说明其作用。

### tcp粘包是怎么回事，如何处理？udp有粘包吗？
[http://blog.csdn.net/ce123/article/details/8976006](http://blog.csdn.net/ce123/article/details/8976006)
UDP 没有粘包,因为 UDP 数据包是有边界的

UDP:面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。

TCP:面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。

- 对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；

-  而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。

TCP无边界，造成对采用TCP协议发送的数据进行接收比较麻烦，在接收的时候易出现粘包，即发送方发送的若干包数据到接收方接收时粘成一包。由于TCP是流协议，对于一个socket的包，如发送 10AAAAABBBBB两次，由于网络原因第一次又分成两次发送， 10AAAAAB和BBBB，如果接包的时候先读取10(包长度)再读入后续数据，当接收得快，发送的慢时，就会出现先接收了 10AAAAAB,会解释错误 ,再接到BBBB10AAAAABBBBB，也解释错误的情况。这就是TCP的粘包。

处理粘包:

    在网络传输应用中，通常需要在网络协议之上再自定义一个协议封装一下，简单做法就是在要发送的数据前面再加一个自定义的包头，包头中可以包含数据长度和其它一些信息，接收的时候先收包头，再根据包头中描述的数据长度来接收后面的数据。
    详细做法是：先接收包头，在包头里指定包体长度来接收。设置包头包尾的检查位（ 比如以0xAA开头，0xCC结束来检查一个包是否完整）

避免粘包:

    一、对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
    二对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
    三、由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

### time_wait是什么情况？出现过多的close_wait可能是什么原因？

### 简单说说https的过程？

1. 浏览器 https 发出请求,包含了自己支持的加密算法
2. 服务器接受请求,并选取一个加密算法和 hash 算法,并将自己的证书发给浏览器
3. 浏览器获得证书,验证其正确性,如果正确,浏览器生成一个随机的密码,并用服务器的公钥加密
    使用约定好的 hash 计算握手信息,并使用生成的随机数对消息进行加密,然后将之前生成的所有信息发送给服务器
4. 服务器接收浏览器发过来的数据,用私钥计算出随机密码,然后用这个随机密码和 hash 算法计算握手信息,并跟浏览器发送过来的对比,查看正确性,然后生成一个随机加密一段握手信息,并发送给浏览器
5. 浏览器用刚刚自己产生的随机密码解密出新的随机密码,并计算握手信息hash,如果跟服务器发过来的一致,那么握手结束.
6. 之后所有的通信都由之前服务器生成的的随机密码用对称加密算法加密

或者这样说

1. c端请求，s端响应并提供证书；
2. c端检查接收后生成pre-master-securet使用s端发过来的公钥加密；
3. s端接收到后使用私钥解密，并最终通过某种算法生成master-securet；
4. 后续的通信中s和c端均使用这个master-securet生成的密钥。

这样c端和s端都可以进行加密解密，所以叫对称加密。
之前c端和s端是非对称加密，即私钥可以解密公钥加密的信息，公钥可以解密私钥加密的信息，但是不能自己解密自己加密的信息。

而两个master-securet的作用是由于不信任机器随机数的随机性，所以使用pre-master-securet，这个东西是c端生成的，而由s端加密生成master-securet，两个机器的随机性会大大增强，不容易被猜出来。

