<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>dantangfan.github.io</title>
   <link href="http://dantangfan.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://dantangfan.github.io" rel="alternate" type="text/html" />
   <updated>2014-04-03T22:34:43+08:00</updated>
   <id>http://dantangfan.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>半天简单总结python</title>
     <link href="http://dantangfan.github.io/learn-python"/>
     <updated>2013-12-25T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/learn-python</id>
     <content type="html">&lt;p&gt;help(func)随便什么函数都可以查到&lt;/p&gt;

&lt;h2&gt;数据类型&lt;/h2&gt;

&lt;p&gt;整数定义跟c语言一样,type(ver)返回变量类型&lt;/p&gt;

&lt;p&gt;&quot;&quot;&quot;三引号表示注释,三引号表示格式化输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;mail = &quot;&quot;&quot; Hi
    I am 
    Jim
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列切片--&gt;str[x:y],str[x,step,y]&lt;/p&gt;

&lt;p&gt;序列都有的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;len()
+
*    str=str1*5
in   's' in str
max()
min()
cmp(tuple1,tuple2)
id(str)查看内存空间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内存存储的是值，不是元素，每当变量值改变的时候，内存都会变化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;str = &quot;ssg&quot;
id(str)
str = &quot;ss&quot;
id(str)#两次结果是不一样的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;元组：元组不可以单独元素变化，&lt;/h3&gt;

&lt;p&gt;创建元祖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;myempty = ()
singleone = (2,)
many = (1,3,4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;列表：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;list.append(msg)
list.remove('msg')选第一次出现的msg删除
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;字典：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;key不可变，value可变
keys()返回键列表
values()返回键值列表
items()返回字典中的元组
fdict = dict(['x',1],['y',2])生成字典
dict.pop(key,val=msg)删除,不存在的时候返回msg（可选）
del(dict[key])删除
dict.clear()删除所有元素
del dict删除字典
dict.git(key,'msg')取值不存在返回msg，msg可选
dict.fromkeys(seq,val=None)以seq中的元素为键创建一个字典，键值为空
dict.has_key(key) 判断是否存在key，常用in或者not in 代替
dict.update(temp_dict)把temp中的元素添加到dict，不存在则建立，存在则覆盖
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分支语句：if,if-else,if-elif-else&lt;/p&gt;

&lt;h2&gt;函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def f(x,*args.**kwarg):
    print x
    if(args):
        print args
    if(kwarg):
        print kwarg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传入任意数量参数，f('x',1,2,y=9)&lt;/p&gt;

&lt;p&gt;lambda x,y:x&lt;em&gt;y 直接返回x&lt;/em&gt;y&lt;/p&gt;

&lt;p&gt;比如阶乘 reduce (lambda x,y:x*y , range(1,100))&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在目录下创建&lt;strong&gt;init&lt;/strong&gt;.py 就可以把文件变成一个包，使用import xxx.xxx导入包内文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;文件操作：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;fileptr = file(filename)
fileptr = open(filename,mode)默认模式是r.
fileptr.read()读取整个文件
fileptr.close()关闭
fileptr.write('msg')只有当关闭文件或者缓冲区的时候才会写入
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;::r+读写，w+先删除再读写，没有则创建
r+直接从指针开头写入，如果要追加就需要先read()到文件尾部然后再来write
a在文件末尾追加新内容，a+读写
b打开二进制文件&lt;/p&gt;

&lt;h3&gt;文件方法：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;string = f.readline(size)size可选，小于一行
List = f.readlines(size)...
string = f.read(size)...
file.next()读取一行，指向下一行
for i in open(filename):
    print i#每次读取一行打印出来

f.write(msg)写一行
f.writelines(List)写多行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f.seek(偏移量,选项)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;0：表示将文件指针指到从文件0开始到偏移量处&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1：将指针从当前位置开始到偏移量处，&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2：从文件末尾倒数偏移量处&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;偏移方向用正负控制&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;eg&lt;/code&gt;f.seek(0,0)回到文件开始&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f.flush()提交更新&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;OS模块：常见函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import os
os.mkdir('/home/hj/test')
os.mkdir(path[,mode=0777])
makedirs(name,mode=511)创建多级目录
rmdir(path)
removedirs(path)删除多级目录
listdir(path)
getcwd()==&amp;gt;pwd
chdir(path)
walk(top,topdown=true,onerror=None)
os.isdir(name)判断是否为目录
os.path.join(path)#会把当前路进跟path连接起来
os.walk(path)返回一个元祖，有三个元素，分别为每次遍历的路径名，目录列表，文件列表
g = os.walk('.')
g.next()每次遍历一个目录下
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是就有了这样的办法来遍历目录打印全路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;for path,d,filelist in os.walk('.'):
    for filename in filelist:
        os.path.join(path,filename)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;面向对象：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;class hj:
    first = 1
    second = 2
    name = 'd'
    __var = &quot;私有属性&quot;
    def __init__(self,n='dd'):
        self.name = n
        pirnt &quot;初始化&quot;
    def stati():
        print = &quot;静态&quot;
    def __se(self):
        print &quot;私有方法&quot;
    def f(self):
        print 'hj'
    def __str__(self):
        return &quot;类被调用、运行的时候就自动出现&quot;
    def __del__():
        pass
if __name__=='__main__':
    me = hj('hj')


class parent:
    def f(self):
        print &quot;father&quot;

class son(father):
    def func(self):
        print 'I am son'

test = son()
test.f()
test.func()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;正则表达式：&lt;/h2&gt;

&lt;p&gt;import re&lt;/p&gt;

&lt;h3&gt;常用元字符： &lt;code&gt;. ^ $ * + ? {} () \ | []&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;s = r'abx'&lt;/code&gt;字符串前面加r，内部元字符就需要转义后才能匹配&lt;/p&gt;

&lt;p&gt;re.findall(s,'avxxaagadfgdfg')返回一个列表&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\d 匹配任何十进制数字&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\D 匹配任何非数字&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\s 匹配任何空白字符&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\S 匹配任何非空白&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\w 匹配任何数字字母&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\W 匹配任何非数字字母&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;{8}重复8次&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;常用函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;r = r'\d{3,4}-?\d{8}'
p_tel = re.compile(r)
p_tel.findall('010-12345678')效果和re.findall(r,'101-12345678')一样，但是速度更快
match()决定re是否在字符串刚开始的位置匹配
x = p_tel.match() x是一个迭代器，只判断是否有值
x.group()返回x指向的对象

search()扫描字符串，找到re匹配的位置
findall()返回所有匹配的列表
finditer()找到re匹配的所有字符串，并把他们作为一个迭代器返回
x = p_tel.finditer(msg)
x.group() 返回所有匹配
x.start() 返回第一个匹配
x.end() 返回最后一个匹配
x.span() 返回一个元组，包含(开始，结束)的位置

s.replace(str,str1)字符串替换
使用正则形式如下
rs = r'c..t'
re.sub(rs,'python', 'fsfhglskuegjceet')用rs替换后者中的位置为中间的

s.split(brk)字符串切割
使用正则形式如下
re.split(r'sfs*',str)
dir(re)查看re的内置属性和方法，任何包都可以使用

属性
S匹配任何字符，包括换行等re.findall(r,str,re.S)
M多行匹配 re.findall(r,file,re.M)
I大小写不敏感re.I
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;爬虫下载图片&lt;/h2&gt;

&lt;h3&gt;简单爬虫&lt;/h3&gt;

&lt;p&gt;首先查看网页代码，图片代码的特征。正则提取图片地址，开始下载&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/bin/env python

import re
import urllib#从地址获取源代码
#获取指定地址源代码
def getHtml(url):
    page = urllib.urlopen(url)
    html = page.read()
    return html

#获得图片
def getImage(html):
    reg = r'src=&quot;(.*\.jpg)&quot; width'
    imgre = re.compile(reg)
    imglist = re.findall(reg,html)
    x = 1
    for i in imglist:
        urllib.urlretrieve(i,'%s.jpg' % x)
        x = x+1

if __name__=='__main__':
    getImage(getHtml('www.baidu.com'))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;GUI--wxpython:&lt;/h2&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;导入wxpython包&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类化wxpython应用程序类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义一个应用程序的初始化方法&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个应用程序类的实例&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入这个应用程序的主实践循环&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建应用程序对象：app = wx.app()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建窗口：win = wx.Frame(None)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;显示窗口：win.Show()&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入应用程序管理循环:app.MainLoop()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;一个简单的记事本，通过像素管理尺寸（特别是文本框）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title='hj',size = (410,335))
win.Show()#显示
loadButton = wx.Button(win,lable='load',pos = (225,5), size = (80,25))#按钮
saveButton = wx.Button(win,lable='save',pos = (315,5), size = (80,25))

filename = wx.TextCtrl(win,pos = (5,5),size = (210,25))#文本框
content = wx.TextCtrl(win, pos = (5,35), size = (390,260), style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;记事本，用尺寸器管理大小&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title='hj',size = (410,335))

bkg = wx.Panel(win)#尺寸管理,背景画板

loadButton = wx.Button(bkg,lable='load')#按钮
saveButton = wx.Button(bkg,lable='save')
filename = wx.TextCtrl(bkg)#文本框
content = wx.TextCtrl(bkg, style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条

#划分组建位置
hbox = wx.BoxSizer()#不加参数，默认左右管理（上面一个文本框两个按钮，上部份）
hbox.add(filename，proportion=1,flag = wx.EXPAND)#proportion表示占位置大小,1为最大空间，flag表示是否拉伸
hbox.add(loadButton, proportion=0,flag = wx.LEFT,boder = 5)#表示在左边有边界，像素5
hbox.add(saveButton, proportion=0,flag = wx.LEFT,boder = 5)

bbox = wx.BoxSizer(wx.VERTICAL)#上下划分页面管理
bbox.add(hbox,proportion = 0,flag = wx.EXPAND | wx.ALL,border=5)
bbox.add(content,proportion = 1,flag = wx.EXPAND | wx.LEFT | wx.BOTTOM | wx.RIGHT,border = 5)

bkg.SetSize(bbox)#让布局管理器生效

win.Show()#显示
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;按钮事件处理，事件绑定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import wx
app = wx.App()
win = wx.Frame(None,title='hj',size = (410,335))

bkg = wx.Panel(win)#尺寸管理,背景画板

#定义load按钮
def openfile(evt):
    filepath = filename.GetValue()#获取输入
    fopen = open(filepath,'a+')#打开文件
    content.SetValue(fopen.read())#把文件放在content
    fopen.close()

def savefile(evt):
    filepath = filename.GetValue()
    fopen = open(filepath,'a+')
    fopen.write(content.GetValue())
    fopen.close()

loadButton = wx.Button(bkg,lable='load')#按钮
saveButton = wx.Button(bkg,lable='save')
filename = wx.TextCtrl(bkg)#文本框
content = wx.TextCtrl(bkg, style = wx.TE_MULTILINE | wx.HSCROLL)#style分别有竖着的下拉跳和横着的下拉条

loadButton.Bind(wx.EVT_BUTTON,openfile)#load键绑定了button类型的openfile事件
saveBUtton.Bind(wx.EVT_BUTTON,savefile)
#划分组建位置
hbox = wx.BoxSizer()#不加参数，默认左右管理（上面一个文本框两个按钮，上部份）
hbox.add(filename，proportion=1,flag = wx.EXPAND)#proportion表示占位置大小,1为最大空间，flag表示是否拉伸
hbox.add(loadButton, proportion=0,flag = wx.LEFT,boder = 5)#表示在左边有边界，像素5
hbox.add(saveButton, proportion=0,flag = wx.LEFT,boder = 5)

bbox = wx.BoxSizer(wx.VERTICAL)#上下划分页面管理
bbox.add(hbox,proportion = 0,flag = wx.EXPAND | wx.ALL,border=5)
bbox.add(content,proportion = 1,flag = wx.EXPAND | wx.LEFT | wx.BOTTOM | wx.RIGHT,border = 5)

bkg.SetSize(bbox)#让布局管理器生效

win.Show()#显示
app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;多线程：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import thread
import time
def go(name,n):
    for i in xrange(3)
        print name,i
        time.sleep(1)

thread.start_new_thread(go,('baby',3))
thread.start_new_thread(go,('gay', 3))
time.sleep(6)#线程工作需要时间，如果不sleep，进程就会直接瞬间结束，这个时候线程也就自动结束了，不会相互等待
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;线程锁:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import thread
import time
def go(name,n,l):
    for i in xrange(3)
        print name,i
        time.sleep(1)
    l.release()
locket = thread.allocate_lock()#申明锁对象
locket.acquire()#把锁锁上
print locket.locked()#查看状态

thread.start_new_thread(go,('baby',3),locket)

#locket.release()#解锁

while locket.locked():
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Json格式储存文件：&lt;/h2&gt;

&lt;p&gt;Json必须是unicode类型的（utf-32,utf-16,utf-8默认）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import json
d = {'n':,'tag':89,'id':('sdf',234),'pk':[12,'sfs']}#元组会自动转化成列表
with open('test.txt','w') as f:
    json.dump(d,f)#顺序储存
    json.dump(d,f,indent = 0)#每个数据存一行
    json.dump(d,f,indent = 2)#每个数据的内部数据缩进为2
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>树莓派制作wifi控制小车</title>
     <link href="http://dantangfan.github.io/raspberry-car"/>
     <updated>2013-12-12T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/raspberry-car</id>
     <content type="html">&lt;h2&gt;树莓派小车&lt;/h2&gt;

&lt;h3&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://trade.taobao.com/trade/detail/tradeSnap.htm?spm=a1z09.2.9.8.M4n9cw&amp;amp;tradeID=567688753132954&quot;&gt;树莓派&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=19142619516&quot;&gt;SD卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;拓展板(可选)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=19995371946&quot;&gt;电源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36909029780&quot;&gt;电机和电机驱动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36850212461&amp;amp;ali_trackid=2:mm_10062864_0_0,0:1395925709_3k2_39373907&amp;amp;spm=a230z.1.5634029.7.0Be1hk&quot;&gt;摄像头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?spm=a230r.1.14.41.LfxL1r&amp;amp;id=22921464431&amp;amp;_u=rq4fe15dd67&quot;&gt;无线网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://item.taobao.com/item.htm?id=36903458968&quot;&gt;底盘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;raspberry基本系统搭建&lt;/h3&gt;

&lt;h4&gt;系统刷写&lt;/h4&gt;

&lt;p&gt;可以选择的系统非常多，有Raspbian，Archlinuxarm，Pidora等等，按需选择。&lt;/p&gt;

&lt;p&gt;刷系统，主要是往SD卡中写入系统，Linux下可以使用dd命令，windows下可以使用Win32DiskImager。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;可以先刷写一个SD卡，然后进行常规配置和自定义配置，提取镜像，再刷人其他SD卡。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raspberrypi.org/downloads&quot;&gt;官方系统下载&lt;/a&gt;,&lt;a href=&quot;http://mirrors.ustc.edu.cn/raspberrypi/images/&quot;&gt;中科大加速镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raspberrypi.org/quick-start-guide&quot;&gt;Quick start guid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mall.egoman.com.cn/index.php?option=com_content&amp;amp;view=article&amp;amp;id=99:-lab1raspberrywindows-&amp;amp;catid=47:shiyongfangan-&amp;amp;Itemid=222&quot;&gt;浙大课程： Lab1:初见树莓派(Raspberry)(windows平台)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangshenjia.com/it/raspberry_pi/mac-raspbian/&quot;&gt;mac下给树莓派安装raspbian系统(DD命令)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;小车底板组装&lt;/h3&gt;

&lt;p&gt;根据实际情况或者买家提供的教程组装&lt;/p&gt;

&lt;h3&gt;配置静态ip&lt;/h3&gt;

&lt;p&gt;无线控制希望每次登录都可以使用同一个ip，省去了查找ip的麻烦。&lt;/p&gt;

&lt;p&gt;配置固定IP，不管是有线还是无线都配置静态ip&lt;/p&gt;

&lt;p&gt;以Raspbian（debain系）为例：（本配置是在实验室环境下路由器提供的ip，请根据实际情况修改）&lt;/p&gt;

&lt;p&gt;编辑 /etc/network/interfaces&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet static
address 192.168.1.10
netmask 255.255.255.0
gateway 192.168.1.1

auto wlan0
iface wlan0 inet static
address 192.168.1.88
netmask 255.255.255.0
gateway 192.168.1.1
wpa-ssid 要连接的wlan ssid
wpa-passphrase wlan密码
wireless-channel 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启网络服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#root用户，或者加sudo
/etc/init.d/networking restart 
OR
service networking restart 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;wifi控制小车&lt;/h3&gt;

&lt;h4&gt;摄像头&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将USB摄像头插上，查看是否找到设备，输入：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;root@raspberrypi:/# lsusb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Logitech就是摄像头，说明找到usb设备了，然后再看看设备驱动是否正常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@raspberrypi:/# ls /dev/vid*
/dev/video0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到video0说明成功。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装必要的软件集：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;sudo apt-get install subversion
sudo apt-get install libv4l-dev
sudo apt-get install libjpeg8-dev
sudo apt-get install imagemagick
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;下载mipg-steamer软件，编译并安装：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;svn co https://mjpg-streamer.svn.sourceforge.net/svnroot/mjpg-streamer mjpg-streamer
cd mjpg-streamer/mjpg-streamer
make USE_LIBV4L2=true clean all
make DESTDIR=/usr install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：如果这个svn的地址可能已经失效，请使用下面源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://sourceforge.net/code-snapshots/svn/m/mj/mjpg-streamer/code/mjpg-streamer-code-182.zip
unzip mjpg-streamer-code-182.zip
cd mjpg-streamer-code-182/mjpg-streamer
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建一个文件video.sh并编辑如下代码&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;#!/bin/sh

STREAMER=mjpg_streamer
DEVICE=/dev/video0
RESOLUTION=320x240
FRAMERATE=25
HTTP_PORT=8001

PLUGINPATH=/usr/lib

$STREAMER -i &quot;$PLUGINPATH/input_uvc.so -n -d $DEVICE -r $RESOLUTION -f $FRAMERATE -y YUYV&quot; -o        &quot;$PLUGINPATH/output_http.so -n -p $HTTP_PORT &quot; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;执行代码&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;sudo chmod 777 video.sh 
sudo ./video.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在pc上建立一个html文件，如下编辑&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;RPi&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
                button {
                        margin: 5px 5px 5px 5px;
                        width: 50px;
                        height: 50px;
                        font-size: 24pt;
                        font-weight: bold;
                        color: black;
                }
        &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;content&quot; align=&quot;center&quot;&amp;gt;
                &amp;lt;img width=&quot;500&quot; height=&quot;400&quot; src=&quot;http://&quot;你的raspberry pi ip地址”:8001/?action=stream&quot;&amp;gt;&amp;lt;br/&amp;gt;
                &amp;lt;div id=&quot;up&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div id=&quot;middle&quot;&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div id=&quot;down&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在pc上运行上面index.html”文件看到视频了，就说明摄像头工作正常了，到此摄像头的工作就结束了&lt;/p&gt;

&lt;p&gt;效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/raspberry-car/video.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在执行的过程中，如果显示摄像头关闭不成功，则要杀死进程&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;kill $(pgrep video.sh)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;控制代码&lt;/h4&gt;

&lt;p&gt;小车的控制可以用任何raspberry上能运行的语言编写，这里为方便，直接使用python&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#wheel.py
import RPi.GPIO as GPIO
class wheel:
    pins = {'left1':[13,15],'left2':[16,18],'right1':[19,21],'right2':[22,24]}

    def __init__(self,name):
        self.name = name
        self.pin = wheel.pins[self.name]
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(self.pin[0],GPIO.OUT)
        GPIO.setup(self.pin[1],GPIO.OUT)
        self.stop()

    def forward(self):
        GPIO.output(self.pin[0],GPIO.HIGH)
        GPIO.output(self.pin[1],GPIO.LOW)

    def back(self):
        GPIO.output(self.pin[0],GPIO.LOW)
        GPIO.output(self.pin[1],GPIO.HIGH)

    def stop(self):
        GPIO.output(self.pin[0],GPIO.LOW)
        GPIO.output(self.pin[1],GPIO.LOW)

    def __del__(self):
        pass
        #GPIO.cleanup()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#car.py
from wheel import *
import RPi.GPIO as GPIO
class car:
    wheels=[wheel('left1'),wheel('left2'),wheel('right1'),wheel('right2')]

    def __init__(self):
        GPIO.setmode(GPIO.BOARD)

    def forward(self):
        for wheel in car.wheels:
            wheel.forward()

    def back(self):
        for wheel in car.wheels:
            wheel.back()

    def left(self):
        car.wheels[2].forward()
        car.wheels[3].forward()
        car.wheels[0].back()
        car.wheels[1].back()

    def right(self):
        car.wheels[0].forward()
        car.wheels[1].forward()
        car.wheels[2].back()
        car.wheels[3].back()

    def stop(self):
        for wheel in car.wheels:
            wheel.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#action.py

from car import *
import clean


def action(com):

    #when control the car
    if com==&quot;forward&quot;:
        a = car()
        a.forward()
    elif com==&quot;back&quot;:
        a = car()
        a.back()
    elif com==&quot;left&quot;:
        a = car()
        a.left()
    elif com==&quot;right&quot;:
        a = car()
        a.right()
    elif com==&quot;stop&quot;:
        a = car()
        a.stop()
    #clean all
    elif com==&quot;clean&quot;:
        clean.clean()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#server.py

from actions import *
from socket import *
import sys
import time
import RPi.GPIO as GPIO

host = &quot;192.168.1.10&quot;
port = 8888
s = socket()

s.bind((host,port))
s.listen(5)
print &quot;listen on port 8888&quot;

while 1:
    conn, addr = s.accept()
    print &quot;connected by:&quot;,addr

    while 1:
    #if 1:
        command = conn.recv(1024).replace('\n','')
        #print command
        if not command: break
        #this command to test the distance 
        elif command==&quot;distance&quot;:
            dis=action(command)
            conn.send(dis)
        else:
            action(command)
    conn.close()
    #action(&quot;clean&quot;)
    #GPIO.cleanup()
    #conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dreamcolor.net/archives/rpio-document-pwm-py.html&quot;&gt;raspberry GPIO编程指导&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;PC客户端代码：&lt;/p&gt;

&lt;p&gt;注意：请先安装wxpython&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python
#coding:utf-8
import time
import wx
import socket
#import sys
import threading
import struct

#Receive message
class Receiver(threading.Thread):
    def __init__(self,threadName,window):
        threading.Thread.__init__(self)
        self.threadName = threadName
        self.window = window
        self.timeToQuit = threading.Event()
        self.timeToQuit.clear()
        #连接服务器
        # Create a socket (SOCK_STREAM means a TCP socket)
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            # Connect to server and send data
            self.sock.connect((self.window.host, self.window.port))
            self.window.LogMessage(&quot;连接服务器成功...\n&quot;)
            self.runT = True
        except Exception:
            self.window.LogMessage(&quot;连接服务器失败...\n&quot;)
            self.sock.close()

    def stop(self):
        self.window.LogMessage(&quot;关闭Socket连接...\n&quot;)
        self.sock.close()
        self.runT = False
        self.timeToQuit.set()

    def sendMsg(self,msg):
        logMsg = (u&quot;发送：%s\n&quot; % (msg))
        self.window.LogMessage(logMsg)
        self.sock.sendall(msg)

    def run(self):
        try:
            while self.runT:
                data = self.sock.recv(4)
                if data:
                    dataLen, = struct.unpack_from(&quot;i&quot;,data)
                    wx.CallAfter(self.window.LogMessage,(u&quot;返回数据长度:%s\n&quot; % (dataLen)))
                    wx.CallAfter(self.window.LogMessage,(u&quot;返回数据:%s\n&quot; % (self.sock.recv(dataLen))))
        except Exception:
            pass
class InsertFrame(wx.Frame):

    def __init__(self, parent, id):

        #创建父框
        wx.Frame.__init__(self, parent, id, 'Socket Client', size=(1140, 450))
        #创建画板
        self.panel = wx.Panel(self,-1)
        self.panel.SetBackgroundColour(&quot;White&quot;)
        #创建按钮
        self.createButtonBar(self.panel)
        #创建静态文本
        self.createTextFields(self.panel)
        #创建文本框
        self.creatTextInput(self.panel)

        #Socket 地址
        self.host, self.port = &quot;localhost&quot;, 12340
        self.runT = True
###############################
    #创建文本
    def createTextFields(self, panel):
        for eachLabel, eachPos in self.textFieldData():
            self.createCaptionedText(panel, eachLabel, eachPos)

    def createCaptionedText(self, panel, label, pos):
        static = wx.StaticText(panel, wx.NewId(), label, pos)
        static.SetBackgroundColour(&quot;White&quot;)
#########################
    #创建按钮
    def createButtonBar(self, panel):
        for eachLabel,eachSize,eachPos, eachHandler in self.buttonData():
            self.buildOneButton(panel, eachLabel,eachSize,eachHandler,eachPos)
    def buildOneButton(self, parent, label,buttonsize,handler, pos=(0,0)):
        button = wx.Button(parent, -1, label, pos,buttonsize)
        #绑定按钮的单击事件
        self.Bind(wx.EVT_BUTTON, handler, button)
#########################
    #按钮栏数据
    def buttonData(self):#(按钮名称，按钮大小，按钮坐标，按钮事件）
        return ((&quot;forward&quot;,(60,60 ),(875, 100),self.forward),
                (&quot;back&quot;,(60, 60),(875, 300),self.back),
                (&quot;left&quot;,(60, 60),(750, 200),self.left),
                (&quot;right&quot;,(60, 60),(975, 200),self.right),
                (&quot;stop&quot;,(60, 60),(875, 200),self.stop),
                (&quot;连 接&quot;,(50, 25),(310, 30),self.OnConnection),
                (&quot;断 开&quot;, (50, 25),(370, 30),self.OnCloseSocket),
                (&quot;清 空&quot;, (50, 25),(430, 30),self.OnClearLog),
                (&quot;发 送&quot;, (50, 25),(540, 400),self.OnSend))
    #文本内容
    def textFieldData(self):
        return ((&quot;Please Input socket address AND port：&quot;, (10, 10)),
                (&quot;输入消息：&quot;, (10, 380)))
########################
    #创建文本框
    def creatTextInput(self,panel):
        #服务器地址输入框
        self.socketHostText = wx.TextCtrl(self.panel, wx.NewId(), &quot;&quot;, size=(230, 25),pos=(10, 30))
        #服务器端口输入框
        self.socketPortText = wx.TextCtrl(self.panel, wx.NewId(), &quot;&quot;, size=(50, 25),pos=(250, 30))
        #信息显示
        self.log = wx.TextCtrl(self.panel, -1, &quot;&quot;,size=(620, 310),pos=(10, 60),style=wx.TE_RICH|wx.TE_MULTILINE|wx.TE_READONLY)
        #信息输入
        self.inputMessage = wx.TextCtrl(self.panel, wx.NewId(), size=(520, 25),style=wx.TE_PROCESS_ENTER,pos=(10, 400))
        self.Bind(wx.EVT_TEXT_ENTER, self.OnSend, self.inputMessage)
########################

    #事件处理器(关闭窗口）
    def OnCloseWindow(self, event):
        self.thread.stop()
        self.Destroy()

    #事件处理器(关闭Socket）
    def OnCloseSocket(self, event):
        self.thread.stop()

    #事件处理器(连接到SOCKET）
    def OnConnection(self,event):
        if self.socketHostText.GetValue()!='' and self.socketPortText.GetValue()!='':
            self.host, self.port = str(self.socketHostText.GetValue()),int(self.socketPortText.GetValue())
        threadName = &quot;socketclient&quot;
        self.thread = Receiver(threadName, self)#创建一个线程
        self.thread.setDaemon(True)
        self.thread.start()#启动线程

    #事件处理器(显示LOG）
    def LogMessage(self, msg):#注册一个消息
        self.log.AppendText(msg)

    #事件处理器(清空LOG）
    def OnClearLog(self,event):#注册一个消息
        self.log.Clear()

    #事件处理器(给SOCKET发送消息,并清空输入框）
    def OnSend(self, event):
        self.thread.sendMsg(self.inputMessage.GetValue())
        self.inputMessage.Clear()

    ##############################################
    ##movement button##

    def forward(self,event):
        self.thread.sendMsg(&quot;forward&quot;)

    def back(self,event):
        self.thread.sendMsg(&quot;back&quot;)

    def left(self,event):
        self.thread.sendMsg(&quot;left&quot;)

    def right(self,event):
        self.thread.sendMsg(&quot;right&quot;)

    def stop(self,event):
        self.thread.sendMsg(&quot;stop&quot;)


if __name__ == '__main__':
    app = wx.PySimpleApp()
    frame = InsertFrame(parent=None, id=-1)
    frame.Show()
    app.MainLoop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/raspberry-car/pc_client.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;为方便，可以直接使用git下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/dantangfan/tank.git tank
git clone https://github.com/dantangfan/clientTank clientTank
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;管理和应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/NeonHorizon/berryio&quot;&gt;berryio&lt;/a&gt;,[项目介绍](http://www.geekfan.net/3251/）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://code.google.com/p/webiopi/&quot;&gt;webiopi&lt;/a&gt;,[项目介绍](http://www.2fz1.com/?tag=webiopi）&lt;/p&gt;

&lt;h4&gt;相关文档&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://ishare.iask.sina.com.cn/f/61335036.html&quot;&gt;GY-26电子指南针资料（串口+IIC+温度）&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://share.eepw.com.cn/share/download/id/165040&quot;&gt;黑白 红外壁障模块 资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/8f46c2d1b9f3f90f76c61b4f.html&quot;&gt;DHT22_温湿度传感器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/272b0c69a98271fe910ef926.html&quot;&gt;GY-26电子指南针使用手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/ce9e5e48767f5acfa1c7cd8a.html&quot;&gt;HC-SR04超声波测距模块说明书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://forum.stmlabs.com/showthread.php?tid=5549&quot;&gt;人体红外感应器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;其他&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://raspberrytank.ianrenton.com/&quot;&gt;raspberrytank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.apinglai.com/category/arm/&quot;&gt;传感器的简单应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;联系人&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;联系：dantangfan@gmail.com，316977394@qq.com&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>颓废</title>
     <link href="http://dantangfan.github.io/Mybirthday"/>
     <updated>2013-09-19T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/Mybirthday</id>
     <content type="html">&lt;p&gt;“幺弟，还没起来哇？我都吉上班了，今天你生哒！记到吉吃点好的哈！”
“哦！今天我生阿！那我起来了。恩恩，要的。你还是帮我多吃点嘎嘎哈。”
一大早眼睛的都还没增开就遭哥的电话喊起来了。恩，好勒，起个大早吉食堂吃个煮鸡蛋麻，在咋个也是过生麻，意思意思一哈也是应该的。于是我到食堂吉了。洗洗刷刷的泡吉食堂。哦哟！小笼包都还没的几个人排队得！那我就吃两笼蒸饺麻。三五分钟喝完了一瓶维他奶过后，我又滚会宿舍吉了。“耶？我还有课的麻！”然后又稀里糊涂的去上课了。哦，原来我起来的时候都要到十点了，虽然还是比较早。
“老二阿，今天过生麻，祝你生日快乐哈。没得啥子事得，就浪子麻，你吉上你的课麻。”
“恩，阿，哦。。”
还没反映过来是咋个回事，老汉儿就把电话挂了。一看刚好５９秒，哦哟！老汉儿还的行耶，随便一挂都把时间卡的刚刚好。又一想，好像不对。不久前才看过移动是满５５秒就按两分钟收费的，亏了！！我继续愤愤不平地滚去实验室了。到了Ｂ幢楼下，好像有点口干了。遭了，忘带硬笔了！我拿钱包里面那张崭新的５元大钞在自动售货机塞了半天它都没鸟我。不过也好，上次那玩意儿收了我一张05年的古董级别的１０元大洋，然后在每个水下面画了个小叉叉，然后就不鸟我了。
居然要到四楼去上课，真是想不通教务处的人咋个安排的课程，全班就二三十个人都要爬浪高。到教室一看，真凉快，就跟上学期上常大爷的课一样稀松。然后我到朱子旭旁边找个位置座了下来，嗯，这里比较暖和，果然树大遮阳也遮风。
“黄晋，你怎么又没去实验室阿！你快点做你的东西阿！你跟那个谁商量好阿！老师在催了阿！”
傻逼方拉扯他略显沙哑的声音跟我说话。噫？小方今天咋个笑的那么萌呢？老师的声音怎么听起来那么熟悉呢？
“这个老师的声音好像我们上学期实验课老师的哦。”我说。
“就是，都是广东的口音。不过不知道有没有那么严格。”子旭果然是负责人学霸。
仔细的看看。哎，我的左眼是什么时候变得这么模糊的呢？还是用右眼看吧。终于看清楚了，这不就是以前上网络安全公选课的老师麻！恩，挺喜欢他，他没挂我。恩，不喜欢邓革，老是想挂我，还好我命大。
“果然是第一节课，真该在宿舍睡觉。”
“就是，白来了。”
诶？培君呢？所噶，肯定是跟那两个交换生妹子在一起。啧啧啧，他招架的住么？孝树有去帮忙么？应该没有麻，孝树应该还忙着泡师妹麻。噫？这关我什么事呢？“同学之间要相互友爱”，恩，我这是在关心同学。往旁边看看，卧槽！太特么有志向了，鹏志居然把ＣＣＡＶ放过的某种片子全部下下来了，还在课堂上搞。我瞬间觉得他是多么的高大威猛，虽然我比他长很多。
哎呦喂，这个位置不好，看不清也听不到。逼我玩儿电脑。“玩儿什么呢？”想了半天，4399......很抱歉，我在实验室只想到这个能在线跑的比较快了，我当程序员还有希望么？？？？转身看看旁边的子旭和林郁，高端大气上档次的人就是不跟我等屌丝一样。他们正在看东京大学招生网的题目，是破解01编码。“000110100101001111000111011101001.....”不过我觉得真心该关注的是编码后面的那个妹子吧。。哎，看我多低俗。。。继续游戏吧。
嗯？手机怎么响了？原来是娘亲。我才突然又想起原来今天是我生日的麻。“过生的人就是牛逼，能一天接三个电话！而且还不包括10086！”但是在上课，我没接。。
ＹＹ了一会儿，然后老师突然走了。哦！原来是他提前下课了。这个也太不靠谱了吧！一节课45分钟居然提前了二十分钟。。恩，正好给娘亲回个电话。
不过还是没话说，还好不是59秒，这次只收了一分钟的钱。果然还是女人更持家呀～
去食堂吃了个套餐，一荤一素，不过天气太热了，没吃完。
回到宿舍直接躺到床上，好吧，我承认我有点忧伤，但一定不是大姨爹！想一想，我是有多久在家过我的生日了呢？5年还是8年呢？老爹有多久没跟任何一个家人一起过过生日了呢？10年还是更久？不想了，不想了，在外漂泊，多想无益。哦！还有一件重要的事情不能忘了。我是什么时候开始每年过生日都买张彩票的呢？应该是从我知道有彩票这个玩意儿的时候麻！这次我花下血本儿，买了三十块的，因为我从来没有中过，哪怕是５块钱。为国家福利事业做贡献总是好的，我只能这么想，因为这次我还是的都没中。我打算下次买快乐三，4-18都买一边，就可以中一次了。
晚上了，我从来没有把我的生日当成什么特殊的日子过。但是我知道有人会，而且一定会。我不说，你知道我是说你，而且大家都知道我是说的你。被爱的感觉原来如此美好，怪不得你一直都在追求。我不爱宣扬，但是我不得不说你是我的所有。此处留白，等待未来填满。。&lt;/p&gt;

&lt;p&gt;但是我为什么要突然写日志呢？除了论文，我是有两年没有写过东西了！！！像这样的全身都是钉子柴子是不可能被磨光滑了的。今天一大早就起来，小东东感冒滚回家了，小静静去看老豆了。恩，我还是该去找点事情做。我是应该去实验室了！“特么的今天这床上是贴了502么！怎么也爬不起来。”一瞬间突然惊醒！！然后一脸蛋定“卧槽，又是传说中的鬼压床。下次争取梦到个女鬼，看老子的厉害！”意淫了一会儿，然后百无聊赖的起来到阳台。“擦，又忘了买牙膏了，昨天晚上还是洗的素澡呢！”然后打开电脑。等待开机的时候，看了看手机，“所噶！今天是中秋节了的麻！法定假日了，不用工作。”于是心安理得的不去实验室了，也不知道今天是什么日子，ＣＣＴＶ５+一直都在重播比赛。看的起劲，嘉毛居然告诉我这时因为今天放假，工作人员都放假了，然后就随便给几个比赛让我们这种没地方去的人在这里过过干瘾。
过节！今天中午吃什么呢？从寝室一直走到食堂我都没想好吃什么，果然是吾日三省吾身阿！早中晚都不知道吃什么。早中晚？我不是没吃早饭么？恩，又少了点思想上的负担。每次不知道吃什么的时候就去一饭吃套餐，这次也不例外。
我看阿看，看阿看，巴萨太变态了，梅西又是帽子戏法；西班牙太变态了，又是小加独吃篮下。恩，等等应该还有法国队的比赛。但是等了半天都没有。我才突然想到该跟爷爷打电话了！
“二娃呀！哎呀，你生我都没给你打电话！扎扎实实的搞忘记了！今天才想起。”
“你今天吃的啥子耶？胃子没有痛了麻？长点嘎嘎没有？哎呀，听到你打电话回来我就欢喜了。”
......
一口气摆了好久。心情就舒畅了好多。然后爬着就睡着了。。。。
睡着睡着就起来了。
恩？我在码字？这是真的么？恩，我没发烧。
刷刷微博。
“中秋节快乐，也祝我生日快乐”　+1 , 点赞。
“苹果公司发布正式版iOS7升级，此次升级......”　关我毛事，老子是穷屌丝。
......
果然ｑｑ空间才是四川人民的爱。我又在这里找归属感。
看到大刀的“我想回家，一接到家里的电话眼泪就止不住的流。”
哎呦，女生就是性感，哦不，感性。
噫，玩意儿在我脸上？咸咸的，滑滑的。
卧槽！！！我特么居然湿润了！！！这不科学！！！&lt;/p&gt;

&lt;p&gt;赶紧听首歌，我很忙，牛仔很忙，我不是牛仔也很忙！&lt;/p&gt;

&lt;p&gt;忙么？？？？？&lt;/p&gt;

&lt;p&gt;呜啦啦啦火车笛
随着奔腾的马蹄
小妹妹吹着口琴
夕阳下美了剪影
我用子弹写日记
介绍完了风景
接下来换介绍我自己&lt;/p&gt;

&lt;p&gt;我虽然是个牛仔
在酒吧只点牛奶
为什么不喝啤酒
因为啤酒伤身体
很多人不长眼睛
嚣张都靠武器
赤手空拳就缩成蚂蚁
Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的&lt;/p&gt;

&lt;p&gt;牛仔很忙是我和黄俊郎阿郎
所共同创造的美国乡村民谣新曲风
也是我之前所有专辑里面没有过的曲风哦
不要再说我没有改变
但是呢 我还是坚持自己的风格
咬字不清 哈哈~
虽然俺 在乎透明
为了爱 隆嘛跨不里&lt;/p&gt;

&lt;p&gt;我啦啦啦骑毛驴
因为马跨不上去
洗澡都洗泡泡浴
因为可以玩玩具
我有颗善良的心
都只穿假牛皮
喔跌倒时尽量不压草皮
Wu~
枪口它没长眼睛
我曾经答应上帝
除非是万不得已
我尽量射橡皮筋
老板先来杯奶昔
要逃命前请你
顺便喂喂我那只小毛驴
Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的
Wu~&lt;/p&gt;

&lt;p&gt;Hi Ha
不用麻烦了
不用麻烦了
不用麻烦不用麻烦了
不用麻烦了
你们一起上
我在赶时间
每天决斗观众都累了
英雄也累了
不用麻烦了
不用麻烦了
副歌不长你们有几个
一起上好了
正义呼唤我
美女需要我
牛仔很忙的&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>《c专家编程》学习笔记</title>
     <link href="http://dantangfan.github.io/c-study"/>
     <updated>2013-05-12T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/c-study</id>
     <content type="html">&lt;h2&gt;1.基本数据类型&lt;/h2&gt;

&lt;h3&gt;1.1 整型&lt;/h3&gt;

&lt;p&gt;整型的基本关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;char：有符号8位&lt;/li&gt;
&lt;li&gt;short：有符号16位&lt;/li&gt;
&lt;li&gt;int: 有符号32位&lt;/li&gt;
&lt;li&gt;long：在32位系统上是32位，64位系统上是64位&lt;/li&gt;
&lt;li&gt;long long：有符号64位&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在stdint.h文件中还定义了一些类型，看上去意思明确，使用方便&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef signed char    int5_t;
typedef short int      int16_t;
typedef int            int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short int uint16_t
typedef unsigned int   uint32_t;

#if __WORDSIZE = 64
    typedef long int    int64_t;
    typedef unsigned long int uint64_t;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，还定义了每种类型的大小范围限制，都根据以下命名方式，可以自己用printf函数查看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define INT32_MAX ……
#define INT32_MIN ……
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是：&lt;em&gt;字符常量默认是一个int整数，在编译的过程中编译器决定将其bani成int还是char&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在代码编译的过程中，小于int的类型，都会自动转化成int类型来编译，在使用的时候才会变成相应的类型&lt;/p&gt;

&lt;p&gt;我们在代码中应该经常使用&lt;code&gt;sizeof(……)&lt;/code&gt;来避免代码移植的时候因为32位和64位系统造成的区别&lt;/p&gt;

&lt;h3&gt;1.2浮点数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;float：32位，精度6&lt;/li&gt;
&lt;li&gt;double：64位，精度15&lt;/li&gt;
&lt;li&gt;long double：80位，精度19&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;浮点数的默认类型是&lt;code&gt;double&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C99还提供了复数类型，只要在float/double/long double 后面加上&lt;code&gt;complex&lt;/code&gt;关键字就可以表示复数了，但是平时使用相对较少&lt;/p&gt;

&lt;h3&gt;1.3类型转换&lt;/h3&gt;

&lt;p&gt;编译器的默认类型的优先级如下&lt;code&gt;long double&amp;gt;double&amp;gt;float&amp;gt;long long&amp;gt;long&amp;gt;int&amp;gt;char&lt;/code&gt;。表达式中，编译器会自动将char和short当作默认的int类型操作数，虽然浮点树默认的是double，但是float不会自动转换成double&lt;/p&gt;

&lt;p&gt;类型转换的时候特别要注意有符号数和无符号数的转换，避免符号位被覆盖。如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;long a=-1L;
unsigned int b=100;
printf(&quot;%lu&quot;, (unsigned long)a);
printf(&quot;%ld&quot;, a&amp;gt;b ? a:b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;4294967295&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果产生的原因很容易看懂，就是因为long（-1）的符号位是1,转换成无符号数之后就变成了2&lt;sup&gt;31&lt;/sup&gt;,非常大……&lt;/p&gt;

&lt;p&gt;强制转换的基本语法就是&lt;code&gt;(long )a&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;1.4 运算符优先级&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/c-study/youxianji.png&quot; alt=&quot;youxianji&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>c语言编程内存管理(未完成)</title>
     <link href="http://dantangfan.github.io/c-memory-manage-in-programs"/>
     <updated>2013-03-15T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/c-memory-manage-in-programs</id>
     <content type="html">&lt;ul&gt;
&lt;li&gt;本文翻译自&lt;a href=&quot;http://www.nethack4.org/blog/memory.html&quot;&gt;nethack4.org/blog/memory.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Alex Smith&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;C语言和其他语言最大的不同就是你必须要手动管理内存，而不像其他语言那样有垃圾回收器来帮你管理内存。要保证内存在某种特定的情况下被正确分配并不困难（并且有些操作几乎在所有语言中都需要手动完成）；困难的是要保证分配的内存足够大并且不再使用的时候能够回收。&lt;/p&gt;

&lt;p&gt;这里例举出几种可以应用在C语言的内存分配技术。其中很多都已被应用于NetHack 3.4.3；NetHack 4中应用得更广泛。我将在这篇博客中为大家分享这些方法的有点和缺点。在此，我最关心的是程序的正确性，而不是效率，因此，在性能差距不是特别大的情况下，我将尽量使用整洁的代码而不是高效的代码。&lt;/p&gt;

&lt;h2&gt;分配固定大小内存的技术&lt;/h2&gt;

&lt;p&gt;在这里我们关心两个问题：跟踪分配的内存的使用寿命，并且确保他们的大小是正确的。因此，我将从查看在编译时已经知道大小的内存开始，然后再转向可以处理未知大小内存的技术。&lt;/p&gt;

&lt;h3&gt;在栈中固定大小的缓冲区&lt;/h3&gt;

&lt;p&gt;在C语言中分配内存最简单的方法大概要数直接使用堆栈分配了。如果一个变量在函数内声明的时候没有指定成&lt;code&gt;static&lt;/code&gt;或者&lt;code&gt;extern&lt;/code&gt;，那么当这个变量的作用域启动的时候，系统将为他分配足够的内存，当作用域结束的时候，系统将释放刚刚分配的内存（有时候这个变量被称为“自动变量”）。因为在c语言中，作用域是良好嵌套的，一个典型的c语言实现将会用堆栈实现这一点：变量将从栈顶分配新的空间，并且在作用域结束的时候释放栈顶空间。（这里说的栈顶并离堆栈内存真正的顶部很远，因为栈是从高地址向低地址衍生的）&lt;/p&gt;

&lt;p&gt;这里是这么做主要优点（和一些小缺点）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它不需要额外的操作或者状态来实现这个操作。很多时候，内存分配计划本身就需要内存来工作，这反而导致了效率的倒退。栈分配内存经常就是用来提供这些内存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>C 语言编码风格和标准</title>
     <link href="http://dantangfan.github.io/C-stander"/>
     <updated>2013-02-20T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/C-stander</id>
     <content type="html">&lt;h2&gt;0.摘要&lt;/h2&gt;

&lt;p&gt;本文根据&lt;a href=&quot;http://code.google.com/p/recommended-c-style-and-coding-standards-cn/&quot;&gt;google code&lt;/a&gt;翻译自&lt;a href=&quot;https://www.doc.ic.ac.uk/lab/cplus/cstyle.html&quot;&gt;《Recommended C Style and Coding Standards》&lt;/a&gt;整理改编&lt;/p&gt;

&lt;h3&gt;作者信息:&lt;/h3&gt;

&lt;p&gt;L.W. Cannon (Bell Labs)&lt;br&gt;
R.A. Elliott (Bell Labs)&lt;br&gt;
L.W. Kirchhoff (Bell Labs)&lt;br&gt;
J.H. Miller (Bell Labs)&lt;br&gt;
J.M. Milner (Bell Labs)&lt;br&gt;
R.W. Mitze (Bell Labs)&lt;br&gt;
E.P. Schan (Bell Labs)&lt;br&gt;
N.O. Whittington (Bell Labs)&lt;br&gt;
Henry Spencer (Zoology Computer Systems, University of Toronto)&lt;br&gt;
David Keppel (EECS, UC Berkeley, CS&amp;amp;E, University of Washington)&lt;br&gt;
Mark Brader (SoftQuad? Incorporated, Toronto)&lt;/p&gt;

&lt;p&gt;本文是《Indian Hill C Style and Coding Standards》的更新版本,上面提到的最后三位作者对其进行了修改。本文主要介绍了一种C程序的推荐编码标准,内容着重于讲述编码风格,而不是功能组织(Functional Organization)。&lt;/p&gt;

&lt;h2&gt;1.简介&lt;/h2&gt;

&lt;p&gt;本文档修改于 AT&amp;amp;T Indian Hill 实验室内部成立的一个委员会的一份文档,旨在于建立一套通用的编码标准并推荐给 Indian Hill 社区。&lt;/p&gt;

&lt;p&gt;本文主要讲述编码风格。良好的风格能够鼓励大家形成一致的代码布局,提高代码可移植性并且减少错误数量。&lt;/p&gt;

&lt;p&gt;本文不关注功能组织,或是一些诸如如何使用 goto 的一般话题。我们尝试将之前的有关C代码风格的文档整合到一套统一的标准中,这套标准将适合于任何使用C语言的工程,当然还是会有部分内容是针对一些特定系统的。另外不可避免地是这些标准仍然无法覆盖到所有情况.经验以及广泛的评价十分重要,遇到特殊情况时,大家应该咨询有经验的C程序员,或者查看那些经验丰富的C程序员们的代码(最好遵循这些规则)。&lt;/p&gt;

&lt;p&gt;本文中的标准本身并不是必需的,但个别机构或团体可能部分或全部采用该标准作为程序验收的一部分。因此,在你的机构中其他人很可能以一种相似的风格编码。最终,这些标准的目的是提高可移植性,减少维护工作,尤其是提高代码的清晰度。这里很多风格的选择都有些许武断。混合的编码风格比糟糕的编码风格更难于维护,所以当变更现有代码时,最好是保持与现有代码风格一致,而不是盲目地遵循本文档中的规则。&lt;/p&gt;

&lt;p&gt;&quot;清晰的是专业的;不清晰的则是外行的&quot; — Sir Ernest Gowers&lt;/p&gt;

&lt;h2&gt;2.文件组织&lt;/h2&gt;

&lt;p&gt;一个文件包含的各个部分应该用若干个空行分隔。虽然对源文件没有最大长度限制,但超过1000行的文件处理起来非常不方便。编辑器很可能没有足够 的临时空间来编辑这个文件,编译过程也会因此变得十分缓慢。与回滚到前面所花费的时间相比,那些仅仅呈现了极少量信息的多行星号是不值得的,我们 不鼓励使用。超过79列的行无法被所有的终端都很好地处理,应该尽可能的避免使用。过长的行会导致过深的缩进,这常常是一种代码组织不善的症状。&lt;/p&gt;

&lt;h3&gt;2.1文件命名惯例&lt;/h3&gt;

&lt;p&gt;文件名由一个基础名、一个可选的句号以及后缀组成。名字的第一个字符应该是一个字母,并且所有字符(除了句号)都应该是小写的字母和数字。基础名 应该由八个或更少的字符组成,后缀应该由三个或更少的字符组成(四个,如果你包含句号的话)。这些规则对程序文件以及程序使用和产生的默认文件都 适用(例如,&quot;rogue.sav&quot;)。&lt;/p&gt;

&lt;p&gt;一些编译器和工具要求文件名符合特定的后缀命名约定。下面是后缀命名要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C 源文件的名字必须以.c 结尾&lt;/li&gt;
&lt;li&gt;汇编源文件的名字必须以.s 结尾&lt;/li&gt;
&lt;li&gt;我们普遍遵循以下命名约定:&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;可重定位目标文件名以.o 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;头文件名以.h 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;在多语言环境中一个可供选择的更好的约定是用语言类型和.h 共同作为后缀(例如,&quot;foo.c.h&quot; 或 &quot;foo.ch&quot;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;Yacc 源文件名以.y 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;Lex 源文件名以.l 结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;C++使用编译器相关的后缀约定,包括.c,..c,.cc,.c.c 以及.C。由于大多 C 代码也是 C++代码,因此这里并没有一个明确的方案。&lt;/p&gt;

&lt;p&gt;此外,我们一般约定使用&quot;Makefile&quot;(而不是&quot;makefile&quot;)作为 make(对于那些支持 make 的系统)工具的控制文件,并且使 用&quot;README&quot;作为简要描述目录内容或目录树的文件。&lt;/p&gt;

&lt;h3&gt;2.2 程序文件&lt;/h3&gt;

&lt;p&gt;下面是一个程序文件各个组成部分的推荐排列顺序:&lt;/p&gt;

&lt;p&gt;文件的第一部分是一个序,用于说明该文件中的内容是什么。对文件中的对象(无论它们是函数,外部数据声明或定义,或是其他一些东西)用途的描述比 一个对象名字列表更加有用。这个序可选择地包含作者信息、修订控制信息以及参考资料等。&lt;/p&gt;

&lt;p&gt;接下来是所有被包含的头文件。如果某个头文件被包含的理由不是那么显而易见,我们需要通过增加注释说明原因。大多数情况下,类似 stdio.h 这 样的系统头文件应该被放在用户自定义头文件的前面。&lt;/p&gt;

&lt;p&gt;接下来是那些用于该文件的 defines 和 typedefs。一个常规的顺序是先写常量宏、再写函数宏,最后是 typedefs 和枚举 (enums)定义。&lt;/p&gt;

&lt;p&gt;接下来是全局(外部)数据声明,通常的顺序如下:外部变量,非静态(non-static)全局变量,静态全局变量。如果一组定义被用于部分特定 全局数据(如一个标志字),那么这些定义应该被放在对应数据声明后或嵌入到结构体声明中,并将这些定义缩进到其应用的声明的第一个关键字的下一个 层次(译注:实在没有搞懂后面这句的含义)。&lt;/p&gt;

&lt;p&gt;最后是函数,函数应该以一种有意义的顺序排列。相似的函数应该放在一起。与深度优先(函数定义尽可能在他们的调用者前后)相比,我们应该首选广度 优先方法(抽象层次相似的函数放在一起)。这里需要相当多的判断。如果定义大量本质上无关的工具函数,可考虑按字母表顺序排列。&lt;/p&gt;

&lt;h3&gt;2.3 头文件&lt;/h3&gt;

&lt;p&gt;头文件是那些在编译之前由 C 预处理器包含在其他文件中的文件。诸如 stdio.h 的一些头文件被定义在系统级别,所有使用标准 I/O 库的程序必须 包含它们。头文件还用来包含数据声明和定义,这些数据不止一个程序需要。头文件应该按照功能组织,例如,独立子系统的声明应该放到独立的头文件中。如果一组声明在代码从一种机器移植到另外一种机器时变动的可能性很大,那么这些声明也应该被放在独立的头文件中。&lt;/p&gt;

&lt;p&gt;避免私有头文件的名字与标准库头文件的名字一样。下面语句:&lt;/p&gt;

&lt;p&gt;*#include &quot;math.h&quot;&lt;/p&gt;

&lt;p&gt;当预期的头文件在当前目录下没有找到时,它将会包含标准库中的 math 头文件。如果这的确是你所期望发生的,那么请加上注释。包含头文件时不要使 用绝对路径。当从标准位置获取头文件时,请使用&lt;name&gt;包含头文件;或相对于当前路径定义它们。C 编译器的&quot;include- path&quot;选项(在许多系统中为-l)是处理扩展私有库头文件的最好方法,它允许在不改变源码文件的情况下重新组织目录结构。&lt;/p&gt;

&lt;p&gt;声明了函数或外部变量的头文件应该被那些定义了这些函数和变量的文件所包含。这样一来,编译器就可以做类型检查了,并且外部声明将总是与定义保持 一致。&lt;/p&gt;

&lt;p&gt;在头文件中定义变量往往是个糟糕的想法,它经常是一个在文件间对代码进行低劣划分的症状。此外,在一次编译中,像 typedef 和经过初始化的数 据定义无法被编译器看到两次。在一些系统中,重复的没有使用 extern 关键字修饰的未初始化定义也会导致问题。当头文件嵌套时,会出现重复的声 明,这将导致编译失败。&lt;/p&gt;

&lt;p&gt;头文件不应该嵌套。一个头文件的序应该描述其使用的其他被包含的头文件的实用特性。在极特殊情况下,当大量头文件需要被包含在多个不同的源文件中 时,可以被接受的做法是将公共的头文件包含在一个单独的头文件中。&lt;/p&gt;

&lt;p&gt;一个通用的做法是将下面这段代码加入到每个头文件中以防止头文件被意外多次包含。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifndef EXAMPLE_H
#define EXAMPLE_H
...
/* body of example.h file */
#endif /* EXAMPLE_H */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们不应该对这种避免多次包含的机制产生依赖,特别是不应该因此而嵌套包含头文件。&lt;/p&gt;

&lt;h3&gt;2.4 其他文件&lt;/h3&gt;

&lt;p&gt;还有一个惯例就是编写一个名为&quot;README&quot;的文件,用于描述程序的整体情况以及问题。例如,我们经常在 README 包含程序所使用的条件编译 选项列表以及相关说明,还可以包含机器无关的文件列表等。&lt;/p&gt;

&lt;h2&gt;3. 声明&lt;/h2&gt;

&lt;p&gt;全局声明应该从第一列开始。在所有外部数据声明的前面都应该放置 extern 关键字。如果一个外部变量是一个在定义时大小确定的数组,那么这个数 组界限必须在 extern 声明时显示指出,除非数组的大小与数组本身编码在一起了(例如,一个总是以0结尾的只读字符数组)。重复声明数组大小对 于一些使用他人编写的代码的人特别有益。&lt;/p&gt;

&lt;p&gt;指针修饰符*应该与变量名在一起,而不是与类型在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *s, *t, *u;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char* s, t, u;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后者是错误的,因为实际上 t 和 u 并未如预期那样被声明为指针。不相关的声明,即使是相同类型的,也应该独立占据一行。我们应该对声明对象的角色进行注释,不过当常量名本身足以说明角色时,使用#define 定义的常量列表则不需要注释。通常多行变量名、值与注释使用相同缩进,使得他们在一列直线上。尽量使用 Tab 字符而不是空格。结构体和联合体的声明时,每个元素应该单独占据一行,并附带一条注释。{应该与结构体的 tag 名放在同一行,}应该放在声明结尾的第一列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct boat {
int
 wllength; /* water line length in meters */
int type; /* see below */
long sailarea; /* sail area in square mm */
};
/* defines for boat.type */
#define KETCH (1)
#define YAWL (2)
#define SLOOP (3)
#define SQRIG (4)
#define MOTOR (5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些 defines 有时放在结构体内 type 声明的后面,并使用足够的 tab 缩进到结构体成员成员的下一级。如果这些实际值不那么重要的话,使用 enum 会更好。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;enum bt { KETCH=1, YAWL, SLOOP, SQRIG, MOTOR };
struct boat {
int wllength; /* water line length in meters */
enum bt type;
long sailarea;
};
/* what kind of boat */
/* sail area in square mm */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何初值重要的变量都应该被显式地初始化,或者至少应该添加注释,说明依赖 C 的默认初始值0。空初始化&quot;{}&quot;应该永远不被使用。结构体初始化应 该用大括号完全括起来。用于初始化长整型(long)的常量应该使用显式长度。使用大写字母,例如2l 看起来更像21,数字二十一。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int x = 1;
char *msg = &quot;message&quot;;
struct boat winner[] = {
    { 40, YAWL, 6000000L },
    { 28, MOTOR, 0L },
    { 0 },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个文件不是独立程序,而是某个工程整体的一部分,那么我们应该最大化的利用 static 关键字,使得函数和变量对于单个文件来说是局部范畴 的。只有在有清晰需求且无法通过其他方式实现的特殊情况时,我们才允许变量被其他文件访问。这种情况下应该使用注释明确告知使用了其他文件中的变 量;注释应该说明其他文件的名字。如果你的调试器遮蔽了你需要在调试阶段查看的静态对象,那么可以将这些变量声明为 STATIC,并根据需要决定 是否#define STATIC。&lt;/p&gt;

&lt;p&gt;最重要的类型应该被 typedef,即使他们只是整型,因为独立的名字使得程序更加易读(如果只有很少的几个 integer 的 typedef)。 结构体在声明时应该被 typedef。保持结构体标志的名字与 typedef 后的名字相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef struct splodge_t {
int sp_count;
char *sp_name, *sp_alias;
} splodge_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总是声明函数的返回类型。如果函数原型可用,那就使用它。一个常见的错误就是忽略那些返回 double的外部数学函数声明。那样的话,编译器就会 假定这些函数的返回值为一个整型数,并且将 bit 位逐一尽职尽责的注意转换为一个浮点数(无意义)。&lt;/p&gt;

&lt;p&gt;&quot;C 语言的观点之一是程序员永远是对的&quot; — Michael DeCorte&lt;/p&gt;

&lt;h2&gt;4. 函数声明&lt;/h2&gt;

&lt;p&gt;每个函数前面应该放置一段块注释,概要描述该函数做什么以及(如果不是很清晰)如何使用该函数。重要的设计决策讨论以及副作用说明也适合放在注释 中。避免提供那些代码本身可以清晰提供的信息。&lt;/p&gt;

&lt;p&gt;函数的返回类型应该单独占据一行,(可选的)缩进一个级别。不用使用默认返回类型 int;如果函数没有返回值,那么将返回类型声明为 void。如 果返回值需要大段详细的说明,可以在函数之前的注释中描述;否则可以在同一行中对返回类型进行注释。函数名(以及形式参数列表)应该被单独放在一 行,从第一列开始。目的(返回值)参数一般放在第一个参数位置(从左面开始)。所有形式参数声明、局部声明以及函数体中的代码都应该缩进一级。函 数体的开始括号应该单独一行,放在开始处的第一列。&lt;/p&gt;

&lt;p&gt;每个参数都应该被声明(不要使用默认类型 int)。通常函数中每个变量的角色都应该被描述清楚,我们可以在函数注释中描述,或如果每个声明单独一 行,我们可以将注释放在同一行上。像循环计数器&quot;i&quot;,字符串指针&quot;s&quot;以及用于标识字符的整数类型&quot;c&quot;这些简单变量都无需注释。如果一组函数 都拥有一个相似的参数或局部变量,那么在所有函数中使用同一个名字来标识这个变量是很有益处的(相反,避免在相关函数中使用一个名字标识用途不同 的变量)。不同函数中的相似参数还应该放在各个参数列表中的相同位置。&lt;/p&gt;

&lt;p&gt;参数和局部变量的注释应该统一缩进以排成一列。局部变量声明应用一个空行与函数语句分隔开来。当你使用或声明变长参数的函数时要小心。目前在 C 中尚没有真正可移植的方式处理变长参数。最好设计一个使用固定个数参数的接口。如果一定要使用变 长参数,请使用标准库中的宏来声明具有变长参数的函数。&lt;/p&gt;

&lt;p&gt;如果函数使用了在文件中没有进行全局声明的外部变量(或函数),我们应该在函数体内部使用 extern关键字单独对这些变量进行声明。&lt;/p&gt;

&lt;p&gt;避免局部声明覆盖高级别的声明。尤其是,局部变量不应该在嵌套代码块中被重声明。虽然这在 C中是合法的,但是当使用-h 选项时,潜在的冲突可能性 足以让 lint 工具发出抱怨之声。&lt;/p&gt;

&lt;h2&gt;5. 空白&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int i;main(){for(;i[&quot;]
o, world!\n&quot;,'/'/'/'));}read(j,i,p){write(j/p+p,i—j,i/i);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;- 不光彩的事情,模糊 C 代码大赛,1984 年。作者要求匿名。&lt;/p&gt;

&lt;p&gt;通常情况下,请使用纵向和横向的空白。缩进和空格应该反映代码的块结构。例如,在一个函数定义与下一个函数的注释之间,至少应该有两行空白。&lt;/p&gt;

&lt;p&gt;如果一个条件分支语句过长,那就应该将它拆分成若干单独的行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (foo-&amp;gt;next==NULL &amp;amp;&amp;amp; totalcount&amp;lt;needed &amp;amp;&amp;amp; needed&amp;lt;=MAX_ALLOT
&amp;amp;&amp;amp; server_active(current_input)) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许下面这样更好&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (foo-&amp;gt;next == NULL
&amp;amp;&amp;amp; totalcount &amp;lt; needed &amp;amp;&amp;amp; needed &amp;lt;= MAX_ALLOT
&amp;amp;&amp;amp; server_active(current_input))
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地,复杂的循环条件也应该被拆分为不同行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (curr = *listp, trail = listp;
curr != NULL;
trail = &amp;amp;(curr-&amp;gt;next), curr = curr-&amp;gt;next )
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他复杂的表达式,尤其是那些使用了?:操作符的表达式,最好也能拆分成多行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;c = (a == b)
? d + f(a)
: f(b) – d;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当关键字后面有放在括号内的表达式时,应该使用空格将关键字与左括号分隔(sizeof 操作符是个例外)。在参数列表中,我们也应该使用空格显式 的将各个参数隔开。然而,带有参数的宏定义一定不能在名字与左括号间插入空格,否则 C 预编译器将无法识别后面的参数列表。&lt;/p&gt;

&lt;h2&gt;6. 例子&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/*
* Determine if the sky is blue by checking that it isn't night.
* CAVEAT: Only sometimes right.
 May return TRUE when the answer
* is FALSE.
 Consider clouds, eclipses, short days.
* NOTE: Uses 'hour' from 'hightime.c'.
 Returns 'int' for
* compatibility with the old version.
*/
int
 /* true or false */
skyblue()
{
extern int hour;
 /* current hour of the day */
return (hour &amp;gt;= MORNING &amp;amp;&amp;amp; hour &amp;lt;= EVENING);
}
/*
* Find the last element in the linked list
* pointed to by nodep and return a pointer to it.
* Return NULL if there is no last element.
*/
node_t *
tail(nodep)
node_t
 *nodep;
 /* pointer to head of list */
{
register node_t *np; /* advances to NULL */
register node_t *lp; /* follows one behind np */
if (nodep == NULL)
return (NULL);
for (np = lp = nodep; np != NULL; lp = np, np = np-&amp;gt;next)
;
 /* VOID */
return (lp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;7. 简单语句&lt;/h2&gt;

&lt;p&gt;每行只应该有一条语句,除非多条语句关联特别紧密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;case FOO:
 oogle (zork);
 boogle (zork);
 break;
case BAR:
 oogle (bork);
 boogle (zork);
 break;
case BAZ:
 oogle (gork);
 boogle (bork);
 break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for 或 while 循环语句的空体应该单独放在一行并加上注释,这样可以清晰的看出空体是有意而为,并非遗漏代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while (*dest++ = *src++)
;
 /* VOID */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要对非零表达式进行默认测试,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (f() != FAIL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比下面的代码更好&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (f())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使 FAIL 的值可能为0(在 C 中0被认为是假)。当后续有人决定使用-1替代0作为失败返回值时,一个显式的测试将解决你的问题。即使比较的值 永远不会改变,我们也应该使用显式的比较;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (!(bufsize % sizeof(int)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该被写成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if ((bufsize % sizeof(int)) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以反映这个测试的数值(非布尔)本质。一个常见的错误点是使用 strcmp 测试字符串是否相同,这个测试的结果永远不应该被放弃。比较好的 方法是定义一个宏 STREQ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define STREQ(a, b) (strcmp((a), (b)) == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对谓词或满足下面约束的表达式,非零测试经常被放弃:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0表示假,其他都为真。&lt;/li&gt;
&lt;li&gt;通过其命名可以看出返回真是显而易见的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;用 isvalid 或 valid 称呼一个谓词,不要用 checkvalid。&lt;/p&gt;

&lt;p&gt;一个非常常见的实践就是在一个全局头文件中声明一个布尔类型&quot;bool&quot;。这个特殊的名字可以极大地提高代码可读性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef int bool;
#define FALSE 0
#define TRUE 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typedef enum { NO=0, YES } bool;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即便有了这些声明,也不要检查一个布尔值与1(TRUE,YES 等)的相当性;可用测试与0(FALSE,NO 等)的不等性替代。绝大多数函数都 可以保证为假的时候返回0,但为真的时候只返回非零。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (func() == TRUE) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必须被写成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (func() != FALSE) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果可能的话,最好为函数/变量重命名或者重写这个表达式,这样就可以显而易见的知道其含义,而无需再与 true 或 false 比较了(例如,重命 名为 isvalid())。&lt;/p&gt;

&lt;p&gt;嵌入赋值语句也有用武之地。在一些结构中,在没有降低代码可读性的前提下,没有比这更好的方式来实现这个结果了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while ((c = getchar()) != EOF) {
    process the character
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;++和–操作符可算作是赋值语句。这样,为了某些意图,实现带有副作用的功能。使用嵌入赋值语句也可能提高运行时的性能。不过,大家应该在提高 的性能与下降的可维护性之间做好权衡。当在一些人为的地方使用嵌入赋值语句时,这种情况会发生,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;a = b + c;
d = a + r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不应该被下面代码替代:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;d = (a = b + c) + r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使后者可能节省一个计算周期。在长期运行时,由于优化器渐获成熟,两者的运行时间差距将下降,而两者在维护性方面的差异将提高,因为人类的记忆 会随着时间的流逝而衰退。&lt;/p&gt;

&lt;p&gt;在任何结构良好的代码中, goto 语句都应该保守地使用。使用 goto 带来好处最大的地方是从 switch、for 和 while 多层嵌套中跳出, 但这样做的需求也暗示了代码的内层结构应该被抽取出来放到一个单独的返回值为成功或失败的函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (...) {
    while (...) {
        ...
    if (disaster)
        goto error;
    }
}
...
error:
    clean up the mess
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当需要 goto 时候,其对应的标签应该被放在单独一行,并且后续的代码缩进一级。使用 goto 语句时应该增加注释(可能放在代码块的头)以说明它 的功用和目的。 continue 应该保守地使用,并且尽可能靠近循环的顶部。Break 的麻烦比较少。&lt;/p&gt;

&lt;p&gt;非原型函数的参数有时需要被显式做类型提升。例如,如果函数期望一个32bit 的长整型,但却被传入一个16bit 的整型数,可能会导致函数栈不 对齐。指针,整型和浮点值都会发生此问题。&lt;/p&gt;

&lt;h2&gt;8. 复合语句&lt;/h2&gt;

&lt;p&gt;复合语句是一个由括号括起来的语句列表。有许多种常见的括号格式化方式。如果你有一个本地标准,那请你与本地标准保持一致,或选择一个标准,并持 续地使用它。在编辑别人的代码时,始终使用那些代码中使用的样式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;control {
    statement;
    statement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的风格被称为&quot;K&amp;amp;R 风格&quot;,如果你还没有找到一个自己喜欢的风格,那么可以优先考虑这个风格。在 K&amp;amp;R 风格中, if- else 语句中的 else 部分以及 do-while 语句中的 while 部分应该与结尾大括号在同一行中。而其他大部分风格中,大括号都是单独占据 一行的。&lt;/p&gt;

&lt;p&gt;当一个代码块拥有多个标签时,每个标签应该单独放在一行上。必须为 C 语言的 switch 语句的fall-through 特性(即在代码段与下一个 case 语句之前间没有 break)增加注释以利于后期更好的维护。最好是 lint 风格的注释/指示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;switch (expr) {
    case ABC:
    case DEF:
    statement;
    break;
    case UVW:
    statement;
    /*FALLTHROUGH*/
    case XYZ:
    statement;
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里,最后那个 break 是不必要的,但却是必须的,因为如果后续另外一个 case 添加到最后一个 case的后面时,它将阻止 fall- through 错误的发生。如果使用 default case,那么应该该 default case 放在最后,且不需要 break,如果它是最后一个 case。&lt;/p&gt;

&lt;p&gt;一旦一个 if-else 语句在 if 或 else 段中包含一个复合语句,if 和 else 两个段都应该用括号括上(称为全括号(fully bracketed)语法)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (expr) {
    statement;
} else {
    statement;
    statement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在如下面那样的没有第二个 else 的 if-if-else 语句序列里,括号也是不必可少的。如果 ex1后面的括号被省略,编译器解析将出错:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (ex1) {
    if (ex2) {
    funca();
    }
} else {
    funcb();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个带 else if 的 if-else 语句在书写上应该让 else 条件左对齐。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (STREQ (reply, &quot;yes&quot;)) {
    statements for yes
    ...
} else if (STREQ (reply, &quot;no&quot;)) {
    ...
} else if (STREQ (reply, &quot;maybe&quot;)) {
    ...
} else {
    statements for default
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种格式看起来像一个通用的 switch 语句,并且缩进反映了在这些候选语句间的精确切换,而不是嵌套的语句。&lt;/p&gt;

&lt;p&gt;Do-while 循环总是使用括号将循环体括上。&lt;/p&gt;

&lt;p&gt;下面的代码非常危险:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifdef CIRCUIT
#define CLOSE_CIRCUIT(circno) { close_circ(circno); }
#else
#define CLOSE_CIRCUIT(circno)
#endif
...
if (expr)
    statement;
else
    CLOSE_CIRCUIT(x)
++i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意,在 CIRCUIT 没有定义的系统上,语句++i 仅仅在 expr 是假的时候获得执行。这个例子指出宏用大写命名的价值,以及让代码完全括号化 的价值。&lt;/p&gt;

&lt;p&gt;有些时候,通过 break,continue,goto 或 return,if 可以无条件地进行控制转移。else 应该是隐式的,并且代码不应该缩 进。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (level &amp;gt; limit)
    return (OVERFLOW)
normal();
return (level);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;平坦的缩进告诉读者布尔测试在密封块的其他部分是保持不变的。&lt;/p&gt;

&lt;h2&gt;9. 操作符&lt;/h2&gt;

&lt;p&gt;一元操作符不应该与其唯一的操作数分开。通常,所有其他二元操作符都应该使用空白与其操作树分隔开,但'.'和'-&gt;'例外。当遇到复杂表 达式的时候我们需要做出一些判断。如果内层操作符没有使用空白分隔而外层使用了,那么表达式也许会更清晰些。&lt;/p&gt;

&lt;p&gt;如果你认为一个表达式很难于阅读,可以考虑将这个表达式拆分为多行。在接近中断点的最低优先级操作符处拆分是最好的选择。由于 C 具有一些想不到的 优先级规则,混合使用操作符的表达式应该使用括号括上。但是过多的括号也会使得代码可读性变差,因为人类不擅长做括号匹配。&lt;/p&gt;

&lt;p&gt;二元逗号操作符也会被使用到,但通常我们应该避免使用它。逗号操作符的最大用途是提供多元初始化或操作,比如在 for 循环语句中。复杂表达式,例 如那些使用了嵌套三元?:操作符的表达式,可能引起困惑,并且应该尽可能的避免使用。三元操作符和逗号操作符在一些使用宏的地方很有用,诸如getchar。在三元操作符?:前的逻辑表达式的操作数应该被括起来,并且两个子表达式的返回值应该是相同类型。&lt;/p&gt;

&lt;h2&gt;10. 命名约定&lt;/h2&gt;

&lt;p&gt;毫无疑问,每个独立的工程都有一套自己的命名约定,不过仍然有一些通用的规则值得参考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为系统用途保留以下划线开头或下划线结尾的名字,并且这些名字不应该被用在任何用户自定义的名字中。大多数系统使用这些名字用于用户不应 该也不需知道的名字中。如果你一定要使用你自己私有的标识符,可以用标识它们归属的包的字母作为开头。&lt;/li&gt;
&lt;li&gt;&lt;h1&gt;define 定义的常量名字应该全部大写。&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;Enum 常量应该大写或全部大写。&lt;/li&gt;
&lt;li&gt;函数名、typedef 名,变量名以及结构体、联合体与枚举标志的名字应该用小写字母。&lt;/li&gt;
&lt;li&gt;很多&quot;宏函数&quot;都是全部大写的。一些宏(诸如 getchar 和 putchar)使用小写字母命名,这事因为&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;他们可能被当成函数使用。只有在宏的行为类似一 个函数调用时才允许小写命名的宏,也就是说它们只对其参数进行一次求值,并且不会给具名形式参数赋值。有些时候我们无法编写出一个具有函数行为的 宏,即使其参数也只是求值一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免在同一情形下使用不同命名方式,比如 foo 和 Foo。同样避免 foobar 和 foo_bar 这种方式。需要考虑这样所带来的困惑。&lt;/li&gt;
&lt;li&gt;同样,避免使用看起来相似的名字。在很多终端以及打印设备上,'I'、'1'和'l'非常相似。给变量命名为 l 特别糟糕,因为它看起来十分像常量'1'。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通常,全局名字(包括 enum)应该具有一个统一的前缀,通过该前缀名我们可以识别出这个名字归属于哪个模块。全局变量可以选择汇集在一个全局结 构中。typedef 的名字通常在结尾加一个't'。&lt;/p&gt;

&lt;p&gt;避免名字与各种标准库中的名字冲突。一些系统可能包含一些你所不需要的库。另外你的程序将来某天很可能也要扩展。&lt;/p&gt;

&lt;h2&gt;11. 常量&lt;/h2&gt;

&lt;p&gt;数值型常量不应该被硬编码到源文件中。应该使用 C 预处理器的#define 特性为常量赋予一个有意义的名字。符号化的常量可以让代码具有更好的可 读性。在一处地方统一定义这些值也便于进行大型程序的管理,这样常量值可以在一个地方进行统一修改,只需修改 define 的值即可。枚举数据类型 更适合声明一组具有离散值的变量,并且编译器还可以对其进行额外的类型检查。至少,任何硬编码的值常量必须具有一段注释,以说明该值的来历。&lt;/p&gt;

&lt;p&gt;常量的定义应该与其使用是一致的;例如使用540.0作为一个浮点数,而不是使用540外加一个隐式的float 类型转换。有些时候常量0和1被 直接使用而没有用 define 进行定义。例如,一个 for 循环语句中用于标识数组下标的常量,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;for (i = 0; i &amp;lt; ARYBOUND; i++)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码是合理的,但下面代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;door_t *front_door = opens(door[i], 7);
if (front_door == 0)
    error(&quot;can't open %s\\\\n&quot;, door[i]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不合理的。在最后的那个例子中, front_door 是一个指针。当一个值是指针的时候,它应该与 NULL比较而不是与0比较。NULL 被定义 在标准 I/O 库头文件 stdio.h 中,在一些新系统中它在 stdlib.h 中定义。即使像1或0这样的简单值,我们最好也用 define 定义成 TRUE 和 FALSE 定义后再使用(有些时候,使用 YES 和 NO 可读性更好)。&lt;/p&gt;

&lt;p&gt;简单字符常量应该被定义成字面值,不应该使用数字。不鼓励使用非可见文本字符,因为它们是不可移植的。如果非可见文本字符十分必要,尤其是当它们 在字符串中使用时,它们应该定义成三个八进制数字的转义字符(例如: '\007‘)而非一个字符。即使这样,这种用法也应该考虑其机器相关性,并按这里的方法处理。&lt;/p&gt;

&lt;h2&gt;12. 宏&lt;/h2&gt;

&lt;p&gt;复杂表达式可能会被用作宏参数,这可能会因操作符优先级顺序而引发问题,除非宏定义中所有参数出现的位置都用括号括上了。对这种因参数内副作用而 引发的问题,我们似乎也无能为例,除了在编写表达式时杜绝副作用(无论如何,这都是一个很好的主意)。如果可能的话,尽量在宏定义中对宏参数只进 行一次求值。有很多时候我们无法写出一个可像函数一样使用的宏。&lt;/p&gt;

&lt;p&gt;一些宏也当成函数使用(例如,getc 和 fgetc)。这些宏会被用于实现其他函数,这样一旦宏自身发生变化,使用该宏的函数也会受到影响。在交 换宏和函数时务必要小心,因为函数参数是按值传递的,而宏参数则是通过名称替换。只有在宏定义时特别谨慎小心,才有可能减少使用宏时的担心。&lt;/p&gt;

&lt;p&gt;宏定义中应该避免使用全局变量,因为全局变量的名字很可能被局部声明遮盖。对于那些对具名参数进行修改(不是这些参数所指向的存储区域)或被用作 赋值语句左值的宏,我们应该添加相应的注释以给予提醒。那些不带参数但引用变量,或过长或作为函数别名的宏应该使用空参数列表,例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define OFF_A() (a_global+OFFSET)
#define BORK() (zork())
#define SP3() if (b) { int x; av = f (&amp;amp;x); bv += x; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;宏节省了函数调用和返回的额外开销,但当一个宏过长时,函数调用和返回的额外开销就变得微不足道了,这种情况下我们应该使用函数。&lt;/p&gt;

&lt;p&gt;在一些情况下,让编译器确保宏在使用时应该以分号结尾是很有必要的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if (x==3)
    SP3();
else
    BORK();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果省略 SP3调用后面的分号,后面的 else 将会匹配到 SP3宏中的那个 if。有了分号,else 分支就不会与任何 if 匹配。SP3宏可以这样 安全地实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define SP3() \\\\
    do { if (b) { int x; av = f (&amp;amp;x); bv += x; }} while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;手工给宏定以加上 do-while 包围看起来很别扭,而且很多编译器和工具会抱怨在 while 条件是一个常量值。一个用来声明语句的宏可以使得编 码更加容易:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#ifdef lint
    static int ZERO;
#else
#define ZERO 0
#endif
#define STMT( stuff ) do { stuff } while (ZERO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用下面代码来声明 SP3宏:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define SP3() \\\\
    STMT( if (b) { int x; av = f (&amp;amp;x); bv += x; } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 STMT 宏可以有效阻止一些可以潜在改变程序行为的打印排版错误。除了类型转换、sizeof 以及上面那些技巧和手法,只有当整个宏用括号括上时才应该包含关键字。&lt;/p&gt;

&lt;h2&gt;13. 条件编译&lt;/h2&gt;

&lt;p&gt;条件编译在处理机器依赖、调试以及编译阶段设定特定选项时十分有用。不过要小心条件编译。各种控制很容易以一种无法预料的方式结合在一起。如果使 用#ifdef 判断机器依赖,请确保当没有机器类型适配时,返回一个错误,而不是使用默认机器类型(使用#error 并缩进一级,这样它可以一些老旧的编 译器下工作)。如果你#ifdef 优化选项,默认情况下应该是一个未经优化的代码,而不是一个不兼容的程序。确保测试的是未经优化的代码。&lt;/p&gt;

&lt;p&gt;注意在#ifdef 区域内的文本可能会被编译器扫描(处理),即使#ifdef 求值的结果为假。但即使文件的#ifdef 部分永远不能被编译到(例如,#ifdef COMMENT),这部分也不该随意的放置文本。&lt;/p&gt;

&lt;p&gt;尽可能地将#ifdefs 放在头文件中,而不是源文件中。使用#ifdef 定义可以在源码中统一使用的宏。例如,一个用于检查内存分配的头文件可能这样实现:(省略了 REALLOC 和 FREE):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifdef DEBUG
extern void *mm_malloc();
#define MALLOC(size) (mm_malloc(size))
#else
    extern void *malloc();
#define MALLOC(size) (malloc(size))
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件编译通常应该基于一个接一个的特性的。多数情况下,都应该避免使用机器或操作系统依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifdef BSD4
long t = time ((long *)NULL);
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码之所以糟糕有两个原因:很可能在某个4BSD 系统上有更好的选择,并且也可能存在在某个非4BSD 系统中上述代码是最佳代码。我们可以通过定义诸 如 TIME_LONG 和 TIME_STRUCTD 等宏作为替代,并且在诸如 config.h 的配置文件中定义一个合适的宏。&lt;/p&gt;

&lt;h2&gt;14. 可移植性&lt;/h2&gt;

&lt;p&gt;&quot;C语言结合了汇编的强大功能和可移植性&quot; — 无名氏,暗指比尔.萨克。&lt;/p&gt;

&lt;p&gt;可移植代码的好处是有目共睹的。这一节将阐述一些编写可移植代码的指导原则。这里&quot;可移植的&quot;是指一个源码文件能够在不同机器上被编译和执行,其 前提仅仅是在不同平台上可能包含不同的头文件,使用不同的编译器开关选项罢了。头文件包含的#define 和 typedef 可能因机器而异。一般 来说,一个新&quot;机器&quot;是指一种不同的硬件,一种不同的操作系统,一个不同的编译器,或者是这些的任意组合。参考1包含了很多关于风格和可移植 性方面的有用信息。下面是一个隐患列表,当你设计可移植代码时应该考虑避免这些隐患:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写可移植的代码。只有当被证明是必要的情况下才考虑优化的细节。优化后的代码往往是模糊不清、难以理解的。在一台机器上经过优化后的代码,在其他机器上 可能变得更加糟糕。将采用的性能优化手段记录下来并尽可能多地本地化。文档应该解释这些手段的工作原理以及引入它们的原因(例如:&quot;循环执行了无 数次&quot;)&lt;/li&gt;
&lt;li&gt;要意识到很多东西天生就是不可移植的。比如处理类似程序状态字这样的特定硬件寄存器的代码,以及被设计用于支持某特定硬件部件的代码,诸如汇编器以及 I/O 驱动。即使在这种情况下,许多例程和数据仍然可以被设计成机器无关的。&lt;/li&gt;
&lt;li&gt;组织源文件时将机器无关与机器相关的代码分别放在不同文件中。之后如果这个程序需要被移植到一个新机器上时,我们就可以很容易判断出来哪些需要被改变。为 一些文件的头文件中机器依赖相关的代码添加注释。&lt;/li&gt;
&lt;li&gt;任何&quot;实现相关&quot;的行为都应该作为机器(编译器)依赖对待。假设编译器或硬件以一种十分古怪的方式实现它。&lt;/li&gt;
&lt;li&gt;注意机器字长。对象的大小可能不直观,指针大小也不总是与整型大小相同,也不总是彼此大小相同,或者可相互自由转换。下面的表中列举了 C 语言基本类型在不 同机器和编译器下的大小(以bit 为单位)。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/c-stander/table1.jpg&quot; alt=&quot;table1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有些机器针对某一类型可能有不止一个大小。其类型大小取决于编译器和不同的编译期标志。下面表展示了大多数系统的&quot;安全&quot;类型大小。无符号与带符 号数具有相同的大小(单位:bit)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/c-stander/table2.jpg&quot; alt=&quot;table2&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;void 类型可以保证有足够位精度来表示一个指向任意数据对象的指针。void()()类型可以保证表示一个指向任意函数的指针。当你需要通用指针时 可以使用这些类型(在一些旧的编译器里,分别用char 和 char()()表示)。确保在使用这些指针类型之前将其转换回正确的类型。&lt;/li&gt;
&lt;li&gt;即使说一个 int 和一个 char 类型大小相同,它们仍可能具有不同的格式。例如,下面例子在一些 sizeof(int)等于 sizeof(char)的机器上可能失败。其原因在与 free 函数期望一个 char,但却传入了一个 int。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *p = (int *) malloc (sizeof(int));
free (p);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意,一个对象的大小不能保证这个对象的精度。Cray-2可能使用64位来存储一个整型,但一个长整型转换为一个整型并且再转换回长整型后可能会被截断 为32位。&lt;/li&gt;
&lt;li&gt;整型常量0可以强制转型为任何指针类型。转换后的指针称为对应那个类型的空指针,并且与那个类型的其他指针不同。空指针比较总是与常量0相当。空指针不应 该与一个值为0的变量比较。空指针不总是使用全0的位模式表示。两个不同类型的空指针有些时候可能不同。某个类型的空指针被强制转换为另外一个类 型的指针,其结果是该指针转换为第二个类型的空指针。&lt;/li&gt;
&lt;li&gt;对于 ANSI 编译器,当两个类型相同的指针访问同一块存储区时,则它们比较是相等的。当一个非0整型常量被转换为指针类型时,它们可能与其他指针相等。对 于非 ANSI 编译器,访问同一块存储区的两个指针比较可能并不相同。例如,下面两个指针比较可能相等或不相等,并且他们可能或可能没有访问同一块 存储区域。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;((int *) 2 )
((int *) 3 )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要'magic'指针而不是 NULL,要么分配一些内存,要么将指针视为机器相关的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;extern int x_int_dummy;
 /* in x.c */
#define X_FAIL (NULL)
#define X_BUSY (&amp;amp;x_int_dummy)
#define X_FAIL (NULL)
#define X_BUSY MD_PTR1
 /* MD_PTR1 from &quot;machdep.h&quot; */
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;浮点数字既包含精度也包含范围。这些都是数据对象大小无关的。但是,一个32位浮点数在不同机器上溢出时的值有所不同。同时,4.9乘以5.1在不同的机 器上可能产生两个不同的数字。在圆整(rounding)和截断方面的差异将给出特别不同的答案。&lt;/li&gt;
&lt;li&gt;在一些机器上,一个双精度浮点数在精度或范围方面可能比一个单精度浮点数还要低。&lt;/li&gt;
&lt;li&gt;在一些机器上,double 值的前半部分可能是一个具有相同值的 float 类型。千万不要依赖于此。&lt;/li&gt;
&lt;li&gt;提防带符号字符。例如,在某些 VAX 系统上,用在表达式中的字符是符号扩展的,但在其他一些机器上并非如此。对有符号和无符号有依赖的代码是不可移植的。 例如,如果假设 c 是正值,arrayc 在 c 为有符号且为负值时将无法正常工作。如果你一定要假设 signed 或 unsigned 字符的话,请 用 SIGNED 或 UNSIGNED 为其加上注释。无符号字符的行为可由 unsigned char 保证。&lt;/li&gt;
&lt;li&gt;避免对 ASCII 做假设。如果你必须假设,那么请将其记录下来并本地化。请记住字符很可能用不止8位表示。&lt;/li&gt;
&lt;li&gt;大多数机器采用2的补码表示数,但我们在代码中不应该利用这一特点。使用等价移位操作替代算术运算的优化尤其值得怀疑。如果必须这么做,那么机器相关的代 码应该用#ifdef 定义,或者操作应该在#ifdef 宏判定下执行。你应该衡量一下使用这种难以理解的代码所节省的时间与做代码移植时找 bug 所花费的时间相比孰多孰少。&lt;/li&gt;
&lt;li&gt;一般情况下,如果字长或值范围非常重要,应该使用 typedef 定义具有特定大小的类型。大型程序应该具有一个统一的头文件用于提供通用的、大小 (size)敏感的类型的 typedef 定义,这样更加便于修改以及在紧急修复时查找大小敏感的代码。无符号类型比有符号整型更加编译器无关。如 果既可以用16bit 也可以用32bit 标识一个简单 for 循环的计数器,我们应该使用 int。因为对于当前机器来说,通过整型可以获取更高效 (自然)的存储单元。&lt;/li&gt;
&lt;li&gt;数据对齐也很重要。例如,在不同的机器上,一个四字节的整型数的可能以任意地址作为起始地址,也可能只允许以偶数地址作为起始地址,或者只能以4的整数倍 的地址作为起始地址。因此,一个特定的结构体的各个元素在不同的机器上的偏移量有不同,即使给定的这些元素在所有机器上的大小相同。事实上,一个 包含一个32位指针和一个8位字符的结构提在三个不同的机器上可能有三个不同的大小。作为一个推论,对象指针可能无法自由互换;通过一个指向起始 地址为奇数地址长度为4个字节的指针保存一个整型数有时可以正常工作,但有时则会导致产生 core,有些时候静悄悄地失败了(在这个过程中会破坏 其他数据)。在那些不按字节寻址的机器上,字符指针更是&quot;事故高发地区&quot;。对齐考虑以及加载器的特殊性使得很容易轻率地认为两个连续声明的变量在 内存中也是连在一起的,或者某个类型的变量已经被适当对齐并可以用作其他类型变量使用了。&lt;/li&gt;
&lt;li&gt;在一些机器上,诸如 VAX(小端),一个字的字节随着地址的增加,其重要性提高;而另外一些机器上,诸如68000(大端),随着地址的增加,其重要性降 低。字或更大数据对象(诸如一个双精度字)的字节顺序可能并不相同。因此,任何依赖对象内从左到右方向位模式的代码都值得特别细致的审查。只有当 结构体中两个不同的位字段不被连接以及不被当作一个单元时,这些位字段才具备可移植性。事实上,连接任意两个变量都是不可移植的行为。&lt;/li&gt;
&lt;li&gt;结构体中有一些未使用的空洞。猜想联合体用于类型欺骗。尤其是,一个值不应该在存储时使用一个类型,而在读取时使用另外一种类型。对联合体来说,一个显式 的标签(tag)字段可能会很有用。&lt;/li&gt;
&lt;li&gt;不同的编译器在返回结构体时使用不同的约定。这就会导致代码在接受从不同编译器编译的库代码中返回的结构体值时会出现错误。结构体指针不是问题。&lt;/li&gt;
&lt;li&gt;不要假设参数传递机制。特别是指针大小以及参数求值顺序,大小等。例如,下面的代码就不具备可移植性。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;    c = foo (getchar(), getchar());
char
foo (c1, c2, c3)
char c1, c2, c3;
{
    char bar = *(&amp;amp;c1 + 1);
    return (bar);
    /* often won't return c2 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上面的例子有诸多问题。栈可能向上增长,也可能向下增长(事实上,甚至都不需要一个栈)。参数在传入时可能被扩大,例如一个 char 可能以 int 型被传 入。参数可能以从左到右,从右到左,或以任意顺序压入栈,或直接放在寄存器中(根本无需压栈)。参数求值的顺序也可能与压栈的次序有所不同。一个 编译器可能使用多种(不兼容的)调用约定。&lt;/li&gt;
&lt;li&gt;在某些机器上,空字符指针((char *)0)常被当作指向空字符串的指针对待。不要依赖于此。&lt;/li&gt;
&lt;li&gt;不要修改字符串常量。下面就是一个臭名昭著的例子&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;s = &quot;/dev/tty??&quot;;
strcpy (&amp;amp;s[8], ttychars);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;地址空间可能有空洞。简单计算一个数组中未分配空间的元素(在数组实际存储区域之前或之后)的地址可能会导致程序崩溃。如果这个地址被用于比较,有时程序 可以运行,但会破坏数据,报错,或陷入死循环。在 ANSI C 中,指向一个对象数组的指针指向数组结尾后的第一个元素是合法的,这在一些老编译器上通常是安全的。不过这个&quot;在外边&quot;不可以被解引用。&lt;/li&gt;
&lt;li&gt;只有==和!=比较可用于某给定类型的所有指针。当两个指针指向同一个数组内的元素(或数组后第一个元素)时,使用&amp;lt;&amp;lt;、&amp;lt;=、&amp;amp; amp; gt;或&gt;=对两个指针进行比较是可移植的。同样,仅仅对指向同一个数组内的元素(或数组后第一个元素)的两个指针使用算术操作符才是可移 植的。&lt;/li&gt;
&lt;li&gt;字长(word size)也影响移位和掩码。下面代码在一些68000机器上只会将一个整型数的最右三个位清0,而在其他机器上它还会将高地址的两个字节清零。x &amp;amp;= 0177770 使用 x &amp;amp;= ~07可以在所有机器上正常工作。位字段(bitfield)没有这些问题。&lt;/li&gt;
&lt;li&gt;表达式内的副作用可能导致代码语义是编译器相关的,因为在大多数情况下 C 语言的求值顺序是没有显式定义的。下面是一个臭名昭著的例子:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;a[i] = b[i++];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们只知道 b 的下标值没有被增加。a 的下标 i 值可能是自增后的值也可能是自增前的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;struct bar_t { struct bar_t *next; } bar;
bar-&amp;gt;next = bar = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第二个例子中,bar-&gt;next 的地址很可能在 bar 被赋值之前被计算使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;bar = bar-&amp;gt;next = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三个例子中,bar 可能在 bar-&gt;next 之前被赋值。虽然这可能有悖于&quot;赋值从右到左处理&quot;的规则,但这确是一个合法的解析。考虑下 面的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;long i;
short a[N];
i = old
i = a[i] = new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赋给 i 的值必须是一个按照从右到左的处理顺序进行赋值处理后的值。但是 i 可能在 ai 被赋值前而被赋值为&quot;(long) (short)new&quot;。不同编译器作法不同。
* 质疑代码中出现的数值(“魔数”)。
* 避免使用预处理器技巧。一些诸如使用/ /粘和字符串以及依赖参数字符串展开的宏会破坏代码可靠性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define FOO(string) (printf(&quot;string = %s&quot;,(string)))
...
FOO(filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只是在有些时候会扩展为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;(printf(&quot;filename = %s&quot;,(filename)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小心。诡异的预处理器在一些机器上可能导致宏异常中断。下面是一个宏的两种不同实现版本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define LOOKUP(chr) (a['c'+(chr)]) /* Works as intended. */
#define LOOKUP(c) (a['c'+(c)]) /* Sometimes breaks. */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个版本的 LOOKUP 可能以两种不同的方式扩展,并且会导致代码异常中断。
* 熟悉现有的库函数和定义(但不用太熟悉。与其外部接口相反,库基础设施的内部细节常会改变并且没有警告,这些细节常常也是不可移植的)。你不应该再自己重 新编写字符串比较例程、终端控制例程或为系统结构编写你自己的定义。自己动手实现既浪费你的时间,又使得你的代码可读性变差,因为另外一个读者需 要知道你是否在新的实现中做了什么特殊的事情,并尝试证实它们的存在。同时这样做会使得你无法充分利用一些辅助的微代码或其他有助于提高系统例程 性能的方法。更进一步,它将是一个 bug 的高产源头。如果可能的话,要知道公共库之间的差异(如 ANSI、POSIX 等等)。
* 如果 lint 可用,请使用 lint。这个工具对于查找代码中机器相关的构造、其他不一致性以及顺利通过编译器检查的程序 bug 时具有很高价值。如果你的编 译器具备打开警告的开关,请打开它。
* 质疑在代码块内部的与代码块外部 switch 或 goto 有关联的标签(Label)。无论类型在哪里,参数都应该被转换为适当的类型。当 NULL 用在没有原型的函数调用时,请对NULL 进行转换。不要让函数调用成为类型欺骗发生的地方。C 语言的类型提升规则很是让人费解,所以尽量小心。例如,如果一个函数接受一个32位长的长整型做为参数,但实际传入的却是一个16位长的整型数, 函数栈可能会无法对齐,这个值也可能会被错误提升。
* 在混用有符号和无符号值的算术计算时请使用显式类型转换
* 应该谨慎使用跨程序的 goto、longjmp。很多实现&quot;忘记&quot;恢复寄存器中的值了。尽可能将关键的值声明为 volatile,或将它们注释为 VOLATILE。
* 一些链接器将名字转换为小写,并且一些链接器只识别前六个字母作为唯一标识。在这些系统上程序可能会悄悄地中断运行。
* 当心编译器扩展。如果使用了编译器扩展,请将他们视为机器依赖并用文档记录下来。
* 通常程序无法在数据段执行代码或者无法将数据写入代码段。即使程序可以这么做,也无法保证这么做是可靠的。&lt;/p&gt;

&lt;h2&gt;15. 标准 C&lt;/h2&gt;

&lt;p&gt;现代 C 编译器支持一些或全部的 ANSI 提议的标准 C。无论何时可能的话,尽量用标准 C 编写和运行程序,并且使用诸如函数原型,常量存储以及 volatile(易失性)存储等特性。标准 C 通过给优化器提供有有效的信息以提升程序的性能。标准 C 通过保证所有编译器接受同样的输入语言以及提供相关 机制隐藏机器相关内容或对于那些机器相关代码提供警告的方式提升代码的可移植性。&lt;/p&gt;

&lt;h3&gt;15.1 兼容性&lt;/h3&gt;

&lt;p&gt;编写很容易移植到老编译器上的代码。例如,有条件地在 global.h 中定义一些新(标准中的)关键字,比如 const 和 volatile。标准编译器预 定义了预处理器符号 STDC(见脚注8)。void 类型很难简单地处理正确,因为很多老编译器只理解 void,但不认识 void。&lt;/p&gt;

&lt;p&gt;最简单的方法就是定义一 个新类型 VOIDP(与机器和编译器相关),通常在老编译器下该类型被定义为 char*。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#if __STDC__
typedef void *voidp;
#define COMPILER_SELECTED
#endif
#ifdef A_TARGET
#define const
#define volatile
#define void int
typedef char *voidp;
#define COMPILER_SELECTED
#endif
#ifdef ...
...
#endif
#ifdef COMPILER_SELECTED
#undef COMPILER_SELECTED
#else
{ NO TARGET SELECTED! }
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在 ANSI C 中,#必须是同一行中预处理器指示符的第一个非空白字符。在一些老编译器中,它必须是同一行中的第一个字符。&lt;/p&gt;

&lt;p&gt;当一个静态函数具有前置声明时,前置声明必须包含存储修饰符。在一些老编译器中,这个修饰符必须是&quot;extern&quot;。对于 ANSI 编译器,这个存储修饰符 必须为 static,但全局函数依然必须声明为 extern。因此,静态函数的前置声明应该使用一个#define,例如 FWD_STATIC,并通 过#ifdef 适当定义。&lt;/p&gt;

&lt;p&gt;一个&quot;#ifdef NAME&quot;应该要么以&quot;#endif&quot;结尾,要么以&quot;#endif / NAME /结尾,不应该用&quot;#endif NAME&quot;结尾。对于短小的#ifdef 不应该使用注释,因为通过代码我们可以明确其含义。&lt;/p&gt;

&lt;p&gt;ANSI 的三字符组可能导致内容包含??的字符串的程序神秘的中断。&lt;/p&gt;

&lt;h3&gt;15.2 格式化&lt;/h3&gt;

&lt;p&gt;ANSI C 的代码风格与常规 C 一样,但有两点意外:存储修饰符(storage qualifiers)和参数列表。&lt;/p&gt;

&lt;p&gt;由于 const 和 volatile 的绑定规则很奇怪,因此每个 const 或 volatile 对象都应该单独声明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;int const *s; /* YES */
int const *s, *t; /* NO */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具备原型的函数将参数声明和定义归并在一个参数列表中了。应该在函数的注释中提供各个参数的注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;/*
* `bp': boat trying to get in.
* `stall': a list of stalls, never NULL.
* returns stall number, 0 =&amp;gt; no room.
*/
int
enter_pier (boat_t const *bp, stall_t *stall)
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;15.3 原型&lt;/h3&gt;

&lt;p&gt;应该使用函数原型使得代码更加健壮并且运行时性能更好。不幸地是原型的声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;extern void bork (char c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与定义不兼容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void bork (c)
char c;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原型中 c 应该以机器上最自然的类型传入,很可能是一个字节。而非原型化(向后兼容)的定义暗示 c总是以一个整型传入。如果一个函数具有可类型提升的参数, 那么调用者和被调用者必须以相等地方式编译。要么都必须使用函数原型,要么都不使用原型。如果在程序设计时参数就是可以提升类型的,那么问题就可以被避 免,例如 bork 可以定义成接受一个整型参数。&lt;/p&gt;

&lt;p&gt;如果定义也是原型化的,上面的声明将工作正常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;void bork (char c)
{
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不幸地是,原型化的语法将导致非 ANSI 编译器拒绝这个程序。&lt;/p&gt;

&lt;p&gt;但我们可以很容易地通过编写外部声明来同时适应原型与老编译器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#if __STDC__
#define PROTO(x) x
#else
#define PROTO(x) ()
#endif
extern char **ncopies PROTO((char *s, short times));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 PROTO 必须使用双层括号。&lt;/p&gt;

&lt;p&gt;最后,最好只使用一种风格编写代码(例如,使用原型)。当需要非原型化的版本时,可使用一个自动转换工具生成。&lt;/p&gt;

&lt;h3&gt;15.4 Pragmas&lt;/h3&gt;

&lt;p&gt;Pragmas 用于以一种可控的方式引入机器相关的代码。很显然,pragma 应该被视为机器相关的。不幸地是,ANSI pragmas 的语法使得我们无法将其隔离到机器相关的头文件中了。&lt;/p&gt;

&lt;p&gt;Pragmas 分为两类。优化相关的可以被安全地忽略。而那些影响系统行为(需要 pragmas)的 Pragmas则不能忽略。需要的 pragmas 应该结合#ifdef 使用,这样如果一个 pragma 都没有选到,编译过程将退出。&lt;/p&gt;

&lt;p&gt;两个编译器可能通过两个不同的方式使用同一个给定的 pragma。例如,一个编译器可能使用 haggis发出一个优化信号。而另一个可能使用它暗示一个特 定语句,一旦执行到此,程序应该退出。不过,一旦使用了 pragma,它们必须总是被机器相关的#ifdef 包围。对于非 ANSI 编译器,Pragmas 必须总是被#ifdef。确保对#pragma 的#进行缩进,否则一些较老的预处理器处理它时会挂起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#if defined(__STDC__) &amp;amp;&amp;amp; defined(USE_HAGGIS_PRAGMA)
#pragma (HAGGIS)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&quot;ANSI 标准中描述的'#pragma'命令具有任意实现定义的影响。在 GNU C 预处理中,'#pragma'首先尝试运行游戏'rogue';如果失败,它将尝试运行游戏'hack';如果失败,它将尝试运行 GNU Emacs显示汉诺塔;如果失败,它将报告一个致命错误。无论如何,预处理将不再继续。&quot;
—-- GNU CC 1.34 C 预处理手册。&lt;/p&gt;

&lt;h2&gt;16. 特殊考虑&lt;/h2&gt;

&lt;p&gt;这节包含一些杂项:‘做'与'不做'。
* 不要通过宏替换来改变语法。这将导致程序对于所有人都是难以理解的,除了那个肇事者。
* 不要在需要离散值的地方使用浮点变量。使用一个浮点数作为循环计数器无疑是搬起石头砸自己的脚。总是用&amp;lt;=或&gt;=测试浮点数,对它们永远不要 用精确比较(==或!=)。
* 编译器也有 bug。常见且高发的问题包括结构体赋值和位字段。你无法泛泛的预测一个编译器都有哪些 bug。但你可以在程序中避免使用那些已知的在所有编译 器上都存在问题的结构。你无法让你写的任何代码都是有用的,你可能仍然会遇到 bug,并且在这期间编译器很可能会被修复。因此,只有当你被强制使 用某个特定的充斥 bug 的编译器时,你才应该&quot;围绕&quot;着编译器 bug 写代码。
* 不要依赖自动代码美化工具。良好代码风格的主要受益者就是代码的编写者,并且尤其在手写算法或伪代码的早期设计阶段。自动代码美化工具只应该用在那些已经 完成、语法正确并且此后不能满足当空白和缩进被更为关注的要求时。伴随着对细致程序员的细节的关注,对于那些将函数或文件布局解释清楚的工作,程 序员们会做得更好(换句话说,一些视觉布局是由意图而不是语法决定的,美化工具无法了解到程序员的思想)。粗心的程序员应该学习成为一个细致的程 序员,而不是依赖美化工具让代码可读性更好。
* 意外地遗漏逻辑比较表达式中的第二个=是一个常犯的问题。使用显式测试。避免对赋值使用隐式测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;abool = bbool;
if (abool) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当嵌入的赋值表达式使用时,确保测试是显式的,这样后续它就无法被&quot;修复&quot;了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;while ((abool = bbool) != FALSE) { ...
while (abool = bbool) { ... /* VALUSED */
while (abool = bbool, abool) { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显式地注释那些在正常控制流之外被修改的变量,或其他可能在维护过程中中断的代码。&lt;/p&gt;

&lt;p&gt;现代编译器会自动将变量放到寄存器中。对于你认为最关键的变量慎用寄存器。在极端情况下,用寄存器标记2-4个最为关键的值,并且将剩余的标记为 REGISTER。后者在那些具有较多寄存器的机器上可以#define 为寄存器。&lt;/p&gt;

&lt;h2&gt;17. Lint&lt;/h2&gt;

&lt;p&gt;Lint 是一个 C 程序检查工具,用于检查 C 语言源码文件,探测和报告诸如类型不兼容、函数定义与调用不一致以及潜在的 bug 等情况。强烈建议在所 有程序上使用 lint 工具,并且期望大多数工程将lint 作为官方验收程序的一部分。&lt;/p&gt;

&lt;p&gt;应该注意的是使用 lint 的最好方法不是将 lint 作为官方验收之前的一道必须跨过的栅栏,而是作为一个在代码发生添加或变更之后使用的工具。 Lint 可以发现一些隐藏的 bug 并且可以在问题发生前保证程序的可移植性。lint 产生的许多信息确实暗示了一些事情是错误的。一个有意思的故 事是关于一个漏掉了 fprintf 的一个参数的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;fprintf (&quot;Usage: foo -bar &amp;lt;file&amp;gt;\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作者从未有过一个问题。但每当一个正常用户在命令行上犯错,这个程序就会产生一个 core。许多版本的 lint 工具都能发现这个问题。&lt;/p&gt;

&lt;p&gt;大多 lint 选项都值得我们学习。一些选项可能在合法的代码上给出警告,但它们也会捕捉到许多把事情搞遭的代码。注意'–p'只能为库的一个子 集检查函数调用和类型的一致性,因此程序为了最大化的覆盖检查,应该同时进行带–p 和不带–p 的 lint 检查。&lt;/p&gt;

&lt;p&gt;Lint 也可以识别代码里的一些特殊注释。这些注释可以强制让 lint 在发现问题时关闭警告输出,还可以作为一些特殊代码的文档。&lt;/p&gt;

&lt;h2&gt;18. Make&lt;/h2&gt;

&lt;p&gt;另外一个非常有用的工具是 make。在开发过程中,make 只会重新编译那些上次 make 后发生了改变的模块。它也可以用于自动化其他任务。一些 常见的约定包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt;执行所有二进制文件的构建过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clean&lt;/code&gt;删除所有中间文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;debug&lt;/code&gt;构建一个测试用二进制文件 a.out 或 debug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depend&lt;/code&gt;制作可传递的依赖关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;install&lt;/code&gt;安装二进制文件,库等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deinstall&lt;/code&gt;取消安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkcat&lt;/code&gt;安装手册&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lint&lt;/code&gt;运行 lint 工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print/list&lt;/code&gt;制作一个所有源文件的拷贝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shar&lt;/code&gt;为所有源文件制作一个 shar 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spotless&lt;/code&gt;执行 make clean,并将源码存入版本控制工具。注意:不会删除 Makefile,即便它是一个源文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source&lt;/code&gt;撤销 spotless 所做的事情。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt;运行 ctags(建议使用-t 标志)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdist&lt;/code&gt;分发源码到其他主机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file.c&lt;/code&gt;从版本控制系统中检出这个文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;除此之外,通过命令行也可以定义 Makefile 使用的值(如&quot;CFLAGS&quot;)或源码中使用的值(如&quot;DEBUG&quot;)。&lt;/p&gt;

&lt;h2&gt;19. 工程相关的标准&lt;/h2&gt;

&lt;p&gt;除了这里提到内容外,每个独立的工程都期望能建立附加标准。下面是每个工程程序管理组需要考虑的问题中的一部分:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;哪些额外的命名约定需要遵守?尤其是,那些用于全局数据的功能归类以及结构体或联合体成员名字的系统化的前缀约定非常有用。&lt;/li&gt;
&lt;li&gt;什么样的头文件组织适合于工程特定的数据体系结构?&lt;/li&gt;
&lt;li&gt;应该建立什么样的规程来审核 lint 警告?需要确立一个与 lint 选项一致的宽容度,保证 lint 不会针对一些不重要的问题给出警告,但同时保证真正的 bug 或不一致问题不被隐藏。&lt;/li&gt;
&lt;li&gt;如果一个工程建立了自己的档案库,它应该计划向系统管理员提供一个 lint 库文件。这个 lint库文件允许 lint 工具检查对库函数的兼容性使用。&lt;/li&gt;
&lt;li&gt;需要使用哪种版本控制工具?&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;20. 结论&lt;/h2&gt;

&lt;p&gt;这里描述了一套 C 语言编程风格的标准。其中最重要的几点是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;合理使用空白和注释,使得我们通过代码布局就可以清楚地看出程序的结构。使用简单表达式、语句和函数,使他们可以很容易地被理解。&lt;/li&gt;
&lt;li&gt;记住,在将来某个时候你或其他人很可能会被要求修改代码或让代码运行在一台不同的机器上。精心编写代码,使得其可以移植到尚不确定的机器上。局部化你的优化,因为这些优化经常让人困惑,并且对于该优化措施是否适合其他机器我们持悲观态度。&lt;/li&gt;
&lt;li&gt;许多风格选择是主观武断的。保持代码风格一致比遵循这些绝对的风格规则更重要(尤其是与组织内部标准保持一致)。混用风格比任何一种糟糕的风格都更加糟糕。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;无论采用哪种标准,如果认为该标准有用就必须遵循它。如果你觉得遵循某条标准时有困难,不要仅仅忽略它们,而是在和你当地的大师或组织内的有经验的程序员讨论后再做决定。&lt;/p&gt;

&lt;h2&gt;21. 参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;B.A. Tague, C Language Portability, Sept 22, 1977. This document issued by department 8234 contains three memos by R.C. Haight, A.L. Glasser, and T.L. Lyon dealing with style and portability.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;S.C. Johnson, Lint, a C Program Checker, Unix Supplementary Documents, November 1986.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.W. Mitze, The 3B/PDP-11 Swabbing Problem, Memorandum for File, 1273-770907.01MF, September 14, 1977.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.A. Elliott and D.C. Pfeffer, 3B Processor Common Diagnostic Standards- Version 1, Memorandum for File, 5514-780330.01MF, March 30, 1978.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;R.W. Mitze, An Overview of C Compilation of Unix User Processes on the 3B, Memorandum for File, 5521-780329.02MF, March 29, 1978.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;B.W. Kernighan and D.M. Ritchie, The C Programming Language, Prentice Hall 1978, Second Ed. 1988, ISBN 0-13-110362-8.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;S.I. Feldman, Make — A Program for Maintaining Computer Programs, UNIXSupplementary Documents, November 1986.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Ian Darwin and Geoff Collyer, Can't Happen or / NOTREACHED / or Real Programs Dump Core, USENIX Association Winter Conference, Dallas 1985 Proceedings.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Brian W. Kernighan and P. J. Plauger The Elements of Programming Style. McGraw-Hill, 1974, Second Ed. 1978, ISBN 0-07-034-207-5.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;Lapin Portable C and UNIX System Programming, Prentice Hall 1987, ISBN 0-13-686494-5.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Ian F. Darwin, Checking C Programs with lint, O'Reilly &amp;amp; Associates, 1989. ISBN 0-937175-30-7.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;Andrew R. Koenig, C Traps and Pitfalls, Addison-Wesley, 1989. ISBN 0-201-17928-8.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>c语言学习——指针</title>
     <link href="http://dantangfan.github.io/C-pointer"/>
     <updated>2012-12-20T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/C-pointer</id>
     <content type="html">&lt;h2&gt;指针——保存变量地址的变量&lt;/h2&gt;

&lt;p&gt;第一步，我们来看应该怎么定义指针。指针包含两重意思：指针类型和指针指向的类型。指针类型就是我们平时说的int类型指针、double类型指针；对应的，指针指向的类型就是int、double。关于指针的声明个人只有一个建议，那就是把星号放在变量的旁边。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a,**b;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;定义中常见错误&lt;/h3&gt;

&lt;p&gt;当指针定义后不赋值，那么他会指向一个不确定的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a;
printf(&quot;%p\n&quot;,a);
printf(&quot;%c\n&quot;,*a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译的时候可以通过，但是往往会造成运行时错误，这就是我们俗称的野指针。解决的方案很简单，就是为她赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *a = NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的说，一个xx类型的指针会指向一个xx类型的地址（赵岩老师的《c语言点滴》里面称这句话为“指针真理”）。理解这句话，基本就能正确的为指针赋值。得到xx类型地址方法有很多，这里给出几种赵岩老师的几个例子。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;amp;符号直接获得&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地址符号&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他xx类型指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xx类型数组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;malloc动态申请的地址&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任何void类型指针&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NULL&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;void和NULL&lt;/h2&gt;

&lt;h3&gt;void&lt;/h3&gt;

&lt;p&gt;我们习惯了用void声明函数或者函数返回值，但是很少用void声明指针变量。实际上，用void声明的指针变量之保存了一个地址，但是不会设计任何类型，也就是说任何类型的指针都可以直接赋值给void类型的指针。需要注意的是要将void类型指针赋值给其他类型就要用强制类型转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *p;
int i;
int *ip = &amp;amp;i;
p = ip;//right
ip = (int *)p;//be careful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们经常使用的内存分配函数的返回值也是void类型的指针。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *malloc(size_t size);
void *memcop(void *dest,const void *src,size_t len);
void *memset(void *buffer,int c,size_t num);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此我们平时在使用的时候加上的强制类型转换是必要的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *i = (int *)malloc(sizeof(int)*len);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;NULL&lt;/h3&gt;

&lt;p&gt;NULL是一个值，而不是类型。通常情况下他被定义成0。这就造成了NULL、EOF、/0三个表示终止字符的混淆。我的理解如下，只要区分开按照常规使用，一般就不会犯错&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NULL是指针，用于表示空地址&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EOF--End Of File 的缩写，常用于表示文件结束或者读取文件不成功&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;/0表是空字符，是判断一个字符串结束的标准&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;指针和数组&lt;/h2&gt;

&lt;p&gt;首先：指针和数组是不同的事物！他们仅仅能表达某些相似的意思。我们在使用指针的时候，尽量之使用地址解析&lt;code&gt;\*p&lt;/code&gt;的形式，使用数组的时候多使用下标&lt;code&gt;p[1]&lt;/code&gt;。一般情况下，指针和数组作为函数调用参数的时候是相同的。也就是说下面两种声明是一个意思&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int func(int *a);
int func(int a[]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上他们都会被转换成指针的模式，这个时候的a在函数中用任何形式操作都是对的。&lt;/p&gt;

&lt;h3&gt;二维数组&lt;/h3&gt;

&lt;p&gt;单维度的数组是简单的，但是把数组和指针混合在一起的时候就不那么简单了。用一个表格表示二维情况就可以把人弄晕&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/aptable.jpg&quot; alt=&quot;aptable&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很多书上把这个解释的很复杂。其实，单单对这个问题来说，我们可以认为变量变量声明是右结合的就可以很轻松的把它们区分开来。比如说&lt;code&gt;int *pa[5]&lt;/code&gt;，可以认为首先他是一个a[5]的数组，然后才是一个指针，也就是&lt;code&gt;int *(a[5])&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;难点在于如何理解指针类型的数组跟数组类型的指针，我实在说不清楚他们两个怎么区分，只能截取网上的一幅图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/diffap.jpg&quot; alt=&quot;diffap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一旦理解了二维情况，多维情况也就以此类推了。&lt;/p&gt;

&lt;h2&gt;动态分配内存&lt;/h2&gt;

&lt;p&gt;内存也是老生常谈的内容了。这里截取一副图来解释程序在运行过程中的内存使用情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/C-pointer/mem.jpg&quot; alt=&quot;mem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯，有了这幅图其他也就没有什么好说的了。&lt;/p&gt;

&lt;h3&gt;为神马&lt;/h3&gt;

&lt;p&gt;动态分配内存的原因很简单，我们在初始化一个变量的时候并不知道他会有多大，比如说字符串长度。所以我们就需要根据实际需要来分配，以确保最大效率的利用好内存。&lt;/p&gt;

&lt;p&gt;接下来介绍一些内存操作函数&lt;/p&gt;

&lt;h3&gt;malloc 和 calloc&lt;/h3&gt;

&lt;p&gt;两个函数很相似，完成的任务也大体相似，简单的说calloc = malloc + memset&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *malloc(size_t size);
void *calloc(size_t size_of_one_element, size_t len_of_elements)；

int *p = calloc(sizeof(int),10);//等价于下两句

int *q = malloc(sizeof(int)*10);
memset(q,0,10)；
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;realloc&lt;/h3&gt;

&lt;p&gt;realloc对于初学者并不长用，我们在学习数据结构用数组的方式书写栈的时候，如果遇到数组元素个数不够用了，往往都是从新遭一个更大的数组，然后把刚刚的元素放进去然后继续进行其他操作。calloc也又着相似的功能。&lt;/p&gt;

&lt;p&gt;realloc通常用在动态递增的分配内存上面，re的意思是重复，那么realloc之前，一定已经有过内存分配的操作,或者初始值为NULL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int *oldbuf = malloc(sizeof(int)*len);
int *newbuf = NULL;
newbuf = realloc(oldbuf,len*2);
if(newbuf!=NULL)
    oldbuf = newbuf;
else{
    free(oldbuf);
    return NULL;
}
/*
不推荐使用oldbuf = realloc(oldbuf,len*2);
因为一旦内存分配失败的时候，
会直接返回NULL给oldbuf，
但是他刚刚指向的空间此时还没有被清空，
就造成了内存浪费
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的函数就可以把内存长度加倍了&lt;/p&gt;

&lt;h3&gt;memset、memcpy、memmove&lt;/h3&gt;

&lt;p&gt;内存操作函数使得动态内存的使用更加简洁。从他们的名字就可以知道他们的功能，给出他们的定义自然就知道他们怎么用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void *memcpy(void *dest, void *src,size_t count);
void *memmove(void *dest, void *src ,size_t count);
void *memset(void *buffer,int c,size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;free&lt;/h3&gt;

&lt;p&gt;我们需要养成内存操作配对的好习惯，每次分配了内存，一定要记住使用结束后将它们free掉。free函数的定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void free(void *ptr)
{
    struct mem_control_block *free;
    free = ptr-sizeof(struct mem_control_block);
    free-&amp;gt;is_available = 1;
    return ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看出，free释放内存的时候，并没有将原来的数据擦出，只是简单的把内存可访问置1，而没有还给操作系统。当下一次遇到本部分内存被分配的时候，才重新对内存中的内容进行操作&lt;/p&gt;

&lt;p&gt;实际上，释放指针p之后，p依然是指向释放前的地址的，也就是说*p同样有值。所以释放内存的好习惯是每次释放内存之后，就将原来的指针指空&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;if(p!=NULL){
    free(p);
    p = NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;动态数组&lt;/h2&gt;

&lt;p&gt;动态数组很简单，只要掌握了他的分配和释放方式就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int (*p)[3] = (int *[3])calloc(10,sizeof(int));
int **q = (int **)malloc(sizeof(int *)*10);
for(i=0;i&amp;lt;10;i++&amp;gt;)
    q[i] = (int *)malloc(sizeof(int)*10);
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>C语言学习——让人头疼的scanf</title>
     <link href="http://dantangfan.github.io/C-scanf"/>
     <updated>2012-12-15T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/C-scanf</id>
     <content type="html">&lt;h2&gt;stdin/stdout/stderr&lt;/h2&gt;

&lt;p&gt;提到输入数出，最先要说的就是字节流，它是一种线性的数据结构。流是有方向的，就向您在阅读这篇文章的时候肯定是从左往右读下去的。&lt;/p&gt;

&lt;p&gt;而任何流都是有源头，也有流向的，最长见的就是我们经常说到的I/O流。c语言为我们提供了三个流，一个是输入流stdin，默认指向的源头的键盘。还有两个流是stdout和stderr，默认情况下流向指向屏幕，也就是从屏幕输出。对任何一个输入输出函数，如果没有特殊的参数指明，默认都是从stdin读取字节，再从stdout输出。&lt;/p&gt;

&lt;p&gt;虽然说stdout和stderr都是输出到屏幕，但是他们是有很大区别的。输出到stdout的内容首先要保存到缓冲区中，而stderr直接输出到屏幕（因为我们总是希望尽快就看到错误提示）。如果希望马上就的到错误信息，常用如下语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fprintf(stderr,&quot;something wrong\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是stdin或者是stdout都是不可修改的，因为它们是常量。虽然c语言有提供重定向函数&lt;code&gt;freopen()&lt;/code&gt;，但是一般不建议使用。&lt;/p&gt;

&lt;h2&gt;字符输入输出函数&lt;/h2&gt;

&lt;p&gt;在介绍scanf之前，我们还是循序渐进的现介绍以下他的兄弟连——各种字符输入输出函数。&lt;/p&gt;

&lt;p&gt;首先是最简单的getchar(),putchar()，需要注意的是这两个函数都是读取一个字符，无论他是不是空白字符（这里的空白字符主要是指\n,\t,以及空格等）。虽然简单，但是还是可能出现一些小问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char a,b;
getchar(a);
putchar('a');putchar(a);putchar('\n');
getchar(b);
putchar('b');putchar(b);putchar('\n');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，当我们输出xy再回车的时候，出现的我们预期的结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax
by
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当我们输入x回车的时候却出现了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ax
b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是刚刚说的getchar(),putchar()会接收当下的任何字符，包括回车。&lt;/p&gt;

&lt;p&gt;然后是字符串输入输出函数gets()和puts()。需要了解的就是gets()总是以回车结束，所以不会带走回车，但是可以带走中间的/t,/b等等空白符。&lt;/p&gt;

&lt;h2&gt;scanf&lt;/h2&gt;

&lt;p&gt;下面是本文的主要内容scanf。我们需要清楚两个关键的概念：缓冲区和空白符。空白符前面已经说过了，什么是缓冲区呢？在使用scanf或者gets函数的时候，键盘的输入最先都被保存在缓冲区中，直到输入回车，相应的输入函数才会从缓冲区中读取数据。输入函数从缓冲区读取数据的时候，如果缓冲区为空，函数将等待用户输入，如果不为空，会直接从缓冲区中读取字符。这是一个比较关键的概念，有助于理解下面的问题。&lt;/p&gt;

&lt;p&gt;scanf的函数定义原型如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int scanf(&quot;格式&quot;,地参数);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，函数的返回值是int类型。实际上，scanf函数正确匹配了几个输入参数，返回值就是几。&lt;/p&gt;

&lt;p&gt;下面一个例子来说明scanf函数的主要方面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scanf(&quot;%c,%s %d&quot;,&amp;amp;ch,str,&amp;amp;a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要正确的输入该改函数，我们需要从键盘输入&lt;code&gt;字符,字符串 整数&lt;/code&gt;，如果如果成功的读入，返回值将是3（而不是5）。在输入过程中，一定要在正确的位置输入&lt;code&gt;,&lt;/code&gt;和&lt;code&gt;&lt;/code&gt;与格式匹配。如果不匹配，scanf会失败并且退出。值得注意的是，如果格式里面又空白字符，那么scanf会从stdin中读取空白字符匹配，直到遇到下一个非空白字符，也就是说输入两三个空白字符也是无所谓的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scanf(&quot;%c&quot;,&amp;amp;c)&lt;/code&gt;在读取单个字符的时候跟&lt;code&gt;getchar()&lt;/code&gt;完全一样，读取数字的时候只要类型匹配就对了，不必多说。最扰人的地方是读取字符串，而出事的关键就在于缓冲区！如果还不理解缓冲区，那就管会google一下&lt;/p&gt;

&lt;p&gt;下面看一个几乎所有初学者都遇到过的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i;
while(1){
    printf(&quot;*&quot;);
    scanf(&quot;%d&quot;,&amp;amp;i);
    if(i==1)
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面函数，只要任意输入一个非数字字符，函数就会陷入死循环不停的输出*，您最好亲自再试一试是不是这样的。&lt;/p&gt;

&lt;p&gt;造成无限循环的原因就是scanf按照格式读取的时候失败自动退出，但是他&lt;em&gt;不会清空缓冲区&lt;/em&gt;。于是，我们在输入错误一次后，比如说输入a，scanf发现不匹配，马斯就退出了，但是当下次循环时候，scanf发现缓冲区不空就不会等待输入，又继续匹配不成功，一直这样想去就死循环了。&lt;/p&gt;

&lt;p&gt;那么，这时候我们就需要在每次匹配过后清空缓冲区，我是这样写的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a;
char c;
while(1){
    printf(&quot;*&quot;);
    scanf(&quot;%d&quot;,&amp;amp;a);
    while((c=getchar)!='\n' &amp;amp;&amp;amp; c!=EOF)
        ;
    if(a==1)
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些书上说fflush(stdin)可以清空缓冲区，但是我在使用gcc的时候并没有成功。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;除了缓冲区和格式匹配之外，scanf还可能引发其他很多奇奇怪怪的问题。很多时候我们知道它错了，但是却不知道它为什么错了。所以把scanf说成c函数库中最复杂的函数之一是没问题的。&lt;/p&gt;

&lt;p&gt;解决问题最好的方法就是不让他发生，所以在不熟悉的情况下，尽量使用其他函数来代替scanf，比如说先用fgets()来读取用户输入的整行，然后再用sscanf，strtol，atoi等函数来解析读取的行。这样的好处是，就算我们解析失败了，还可以用其他解析函数来重新解析fgets中的数据&lt;/p&gt;

&lt;p&gt;最长用的算是sscanf了，他从字符串中读取与指定格式匹配的数据。比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char buf[1024];
fgets(buf,sizeof(buf),stdin);
if(sscanf(buf,&quot;%d %c %d&quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c)==3)
    printf(&quot;OK\n&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面罗嗦的过程中，我们可以简单总结出几个要点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;scanf输入字符的时候，任何字符都不会被忽视&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scanf输入数字和字符串的时候，空白字符会被当成输入结束&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;键盘的输入都被保存到缓冲区，直到输入回车输入函数才会去读取缓冲区。输入函数读取缓冲区的时候，如果缓冲区为空，程序会等待输入；如果不为空，程序会直接读取缓冲区中字符&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scanf读取成功会清空缓冲区，读取不成功不会清空缓冲区&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>使用Github Pages建独立博客</title>
     <link href="http://dantangfan.github.io/learn-gitPage"/>
     <updated>2012-11-09T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/learn-gitPage</id>
     <content type="html">&lt;h3&gt;转自&lt;a href=&quot;http://www.beiyuu.com&quot;&gt;www.beiyuu.com&lt;/a&gt;增删涂改个人信息，感谢分享&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com&quot; title=&quot;Github&quot;&gt;Github&lt;/a&gt;很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如&lt;a href=&quot;https://github.com/jquery/jquery&quot; title=&quot;jQuery@github&quot;&gt;jQuery&lt;/a&gt;、&lt;a href=&quot;https://github.com/twitter/bootstrap&quot; title=&quot;Twitter@github&quot;&gt;Twitter&lt;/a&gt;等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。&lt;/p&gt;

&lt;p&gt;Github Pages有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
    &lt;li&gt;使用标记语言，比如&lt;a href=&quot;http://markdown.tw&quot;&gt;Markdown&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;无需自己搭建服务器&lt;/li&gt;
    &lt;li&gt;根据Github的限制，对应的每个站有300MB空间&lt;/li&gt;
    &lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然他也有缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;模板系统，相当于静态页发布，适合博客，文档介绍等。&lt;/li&gt;
&lt;li&gt;动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。&lt;/li&gt;
&lt;li&gt;基于Git，很多东西需要动手，不像Wordpress有强大的后台&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。&lt;/p&gt;

&lt;h2&gt;购买、绑定独立域名&lt;/h2&gt;

&lt;p&gt;虽说&lt;a href=&quot;http://www.godaddy.com/&quot; title=&quot;Godaddy&quot;&gt;Godaddy&lt;/a&gt;曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。&lt;/p&gt;

&lt;p&gt;域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。&lt;/p&gt;

&lt;p&gt;流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在[dantangfan][]也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。&lt;/p&gt;

&lt;p&gt;我们选择&lt;a href=&quot;https://www.dnspod.cn/&quot; title=&quot;DNSPod&quot;&gt;DNSPod&lt;/a&gt;的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;首先添加域名记录，可参考DNSPod的帮助文档：&lt;a href=&quot;https://www.dnspod.cn/Support&quot;&gt;https://www.dnspod.cn/Support&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;在DNSPod自己的域名下添加一条&lt;a href=&quot;http://baike.baidu.com/view/65575.htm&quot;&gt;A记录&lt;/a&gt;，地址就是Github Pages的服务IP地址：207.97.227.245&lt;/li&gt;
    &lt;li&gt;在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：&lt;a href=&quot;https://www.dnspod.cn/support/index/fid/119&quot;&gt;Godaddy注册的域名如何使用DNSPod&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;等待域名解析生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;域名的配置部分完成，跪谢方校长。&lt;/p&gt;

&lt;h2&gt;配置和使用Github&lt;/h2&gt;

&lt;p&gt;Git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本&lt;a href=&quot;http://progit.org/book/zh/&quot; title=&quot;Pro Git中文版&quot;&gt;Git中文教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/list&quot; title=&quot;Windows版Git客户端&quot;&gt;http://code.google.com/p/msysgit/downloads/list&lt;/a&gt;。其他系统的安装也可以参考官方的&lt;a href=&quot;http://help.github.com/mac-set-up-git/&quot; title=&quot;Mac下Git安装&quot;&gt;安装教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。&lt;/p&gt;

&lt;p&gt;在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）：
&lt;img src=&quot;/images/githubpages/bootcamp_1_win_gitbash.jpg&quot; alt=&quot;Git Bash&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1、检查SSH keys的设置&lt;/h3&gt;

&lt;p&gt;首先我们需要检查你电脑上现有的ssh key：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示“No such file or directory”，跳到第三步，否则继续。&lt;/p&gt;

&lt;h3&gt;2、备份和移除原来的ssh key设置：&lt;/h3&gt;

&lt;p&gt;因为已经存在key文件，所以需要备份旧的数据并删除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
config  id_rsa  id_rsa.pub  known_hosts
$ mkdir key_backup
$ cp id_rsa* key_backup
$ rm id_rsa*
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、生成新的SSH Key：&lt;/h3&gt;

&lt;p&gt;输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&amp;lt;回车就好&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后系统会要你输入加密串（&lt;a href=&quot;http://help.github.com/ssh-key-passphrases/&quot;&gt;Passphrase&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase):&amp;lt;输入加密串&amp;gt;
Enter same passphrase again:&amp;lt;再次输入加密串&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后看到这样的界面，就成功设置ssh key了：
&lt;img src=&quot;/images/githubpages/ssh-key-set.png&quot; alt=&quot;ssh key success&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4、添加SSH Key到GitHub：&lt;/h3&gt;

&lt;p&gt;在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。&lt;/p&gt;

&lt;p&gt;用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。&lt;/p&gt;

&lt;p&gt;在GitHub的主页上点击设置按钮：
&lt;img src=&quot;/images/githubpages/github-account-setting.png&quot; alt=&quot;github account setting&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：
&lt;img src=&quot;/images/githubpages/bootcamp_1_ssh.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PS：如果需要配置多个GitHub账号，可以参看这个&lt;a href=&quot;http://omiga.org/blog/archives/2269&quot;&gt;多个github帐号的SSH key切换&lt;/a&gt;，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令&lt;code&gt;git config --global --unset user.email&lt;/code&gt;删除用户账户设置，在每一个repo下面使用&lt;code&gt;git config --local user.email '你的github邮箱@mail.com'&lt;/code&gt; 命令单独设置用户账户信息&lt;/p&gt;

&lt;h3&gt;5、测试一下&lt;/h3&gt;

&lt;p&gt;可以输入下面的命令，看看设置是否成功，&lt;code&gt;git@github.com&lt;/code&gt;的部分不要修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是下面的反应：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要紧张，输入&lt;code&gt;yes&lt;/code&gt;就好，然后会看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi &amp;lt;em&amp;gt;username&amp;lt;/em&amp;gt;! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6、设置你的账号信息&lt;/h3&gt;

&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;/p&gt;

&lt;p&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.email &quot;your_email@youremail.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置GitHub的token&lt;/h4&gt;

&lt;p&gt;2012-4-28补充：新版的接口已经不需要配置token了，所以下面这段可以跳过了&lt;/p&gt;

&lt;p&gt;有些工具没有通过SSH来链接GitHub。如果要使用这类工具，你需要找到然后设置你的API Token。&lt;/p&gt;

&lt;p&gt;在GitHub上，你可以点击&lt;em&gt;Account Setting &gt; Account Admin&lt;/em&gt;：
&lt;img src=&quot;/images/githubpages/bootcamp_1_token.jpg&quot; alt=&quot;set ssh keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在你的命令行中，输入下面的命令，把token添加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &quot;你的名字&quot;
$ git config --global user.token 0123456789your123456789token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你改了GitHub的密码，需要重新设置token。&lt;/p&gt;

&lt;h3&gt;成功了&lt;/h3&gt;

&lt;p&gt;好了，你已经可以成功连接GitHub了。&lt;/p&gt;

&lt;h2&gt;使用GitHub Pages建立博客&lt;/h2&gt;

&lt;p&gt;与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的&lt;code&gt;username.github.io&lt;/code&gt;这样的用户&amp;amp;组织页（站），另一种是依附项目的pages。&lt;/p&gt;

&lt;h3&gt;User &amp;amp; Organization Pages&lt;/h3&gt;

&lt;p&gt;想建立个人博客是用的第一种，形如&lt;code&gt;beiyuu.github.io&lt;/code&gt;这样的可访问的站，每个用户名下面只能建立一个，创建之后点击&lt;code&gt;Admin&lt;/code&gt;进入项目管理，可以看到是这样的：
&lt;img src=&quot;/images/githubpages/user-pages.png&quot; alt=&quot;user pages&quot; /&gt;
而普通的项目是这样的，即使你也是用的&lt;code&gt;othername.github.io&lt;/code&gt;：
&lt;img src=&quot;/images/githubpages/other-pages.png&quot; alt=&quot;other pages&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建好&lt;code&gt;username.github.io&lt;/code&gt;项目之后，提交一个&lt;code&gt;index.html&lt;/code&gt;文件，然后&lt;code&gt;push&lt;/code&gt;到GitHub的&lt;code&gt;master&lt;/code&gt;分支（也就是普通意义上的主干）。第一次页面生效需要一些时间，大概10分钟左右。&lt;/p&gt;

&lt;p&gt;生效之后，访问&lt;code&gt;username.github.io&lt;/code&gt;就可以看到你上传的页面了，&lt;a href=&quot;http://dantangfan.github.io&quot;&gt;dantangfan.github.io&lt;/a&gt;就是一个例子。&lt;/p&gt;

&lt;p&gt;关于第二种项目&lt;code&gt;pages&lt;/code&gt;，简单提一下，他和用户pages使用的后台程序是同一套，只不过它的目的是项目的帮助文档等跟项目绑定的内容，所以需要在项目的&lt;code&gt;gh-pages&lt;/code&gt;分支上去提交相应的文件，GitHub会自动帮你生成项目pages。具体的使用帮助可以参考&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;Github Pages&quot;&gt;Github Pages&lt;/a&gt;的官方文档：&lt;/p&gt;

&lt;h3&gt;绑定域名&lt;/h3&gt;

&lt;p&gt;我们在第一部分就提到了在DNS部分的设置，再来看在GitHub的配置，要想让&lt;code&gt;username.github.io&lt;/code&gt;能通过你自己的域名来访问，需要在项目的根目录下新建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，文件内容形如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以绑定在二级域名上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blog.beiyuu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要提醒的一点是，如果你使用形如&lt;code&gt;beiyuu.com&lt;/code&gt;这样的一级域名的话，需要在DNS处设置A记录到&lt;code&gt;207.97.227.245&lt;/code&gt;（&lt;strong&gt;这个地址会有变动，&lt;a href=&quot;https://help.github.com/articles/my-custom-domain-isn-t-working&quot;&gt;这里&lt;/a&gt;查看&lt;/strong&gt;），而不是在DNS处设置为CNAME的形式，否则可能会对其他服务（比如email）造成影响。&lt;/p&gt;

&lt;p&gt;设置成功后，根据DNS的情况，最长可能需要一天才能生效，耐心等待吧。&lt;/p&gt;

&lt;h2&gt;Jekyll模板系统&lt;/h2&gt;

&lt;p&gt;GitHub Pages为了提供对HTML内容的支持，选择了&lt;a href=&quot;https://github.com/mojombo/jekyll&quot; title=&quot;Jekyll&quot;&gt;Jekyll&lt;/a&gt;作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看&lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/README.textile&quot;&gt;Jekyll官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;你可以直接fork&lt;a href=&quot;https://github.com/dantangfan/dantangfan.github.com&quot;&gt;我的项目&lt;/a&gt;，然后改名，就有了你自己的满足Jekyll要求的文档了，当然你也可以按照下面的介绍自己创建。&lt;/p&gt;

&lt;h3&gt;Jekyll基本结构&lt;/h3&gt;

&lt;p&gt;Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过&lt;code&gt;layout&lt;/code&gt;将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。&lt;/p&gt;

&lt;p&gt;基本的Jekyll结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单介绍一下他们的作用：&lt;/p&gt;

&lt;h4&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;配置文件，用来定义你想要的效果，设置之后就不用关心了。&lt;/p&gt;

&lt;h4&gt;_includes&lt;/h4&gt;

&lt;p&gt;可以用来存放一些小的可复用的模块，方便通过&lt;code&gt;{ % include file.ext %}&lt;/code&gt;（去掉前两个{中或者{与%中的空格，下同）灵活的调用。这条命令会调用_includes/file.ext文件。&lt;/p&gt;

&lt;h4&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这是模板文件存放的位置。模板需要通过&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML front matter&lt;/a&gt;来定义，后面会讲到，&lt;code&gt;{ { content }}&lt;/code&gt;标记用来将数据插入到这些模板中来。&lt;/p&gt;

&lt;h4&gt;_posts&lt;/h4&gt;

&lt;p&gt;你的动态内容，一般来说就是你的博客正文存放的文件夹。他的命名有严格的规定，必须是&lt;code&gt;2012-02-22-artical-title.MARKUP&lt;/code&gt;这样的形式，MARKUP是你所使用标记语言的文件后缀名，根据_config.yml中设定的链接规则，可以根据你的文件名灵活调整，文章的日期和标记语言后缀与文章的标题的独立的。&lt;/p&gt;

&lt;h4&gt;_site&lt;/h4&gt;

&lt;p&gt;这个是Jekyll生成的最终的文档，不用去关心。最好把他放在你的&lt;code&gt;.gitignore&lt;/code&gt;文件中忽略它。&lt;/p&gt;

&lt;h4&gt;其他文件夹&lt;/h4&gt;

&lt;p&gt;你可以创建任何的文件夹，在根目录下面也可以创建任何文件，假设你创建了&lt;code&gt;project&lt;/code&gt;文件夹，下面有一个&lt;code&gt;github-pages.md&lt;/code&gt;的文件，那么你就可以通过&lt;code&gt;yoursite.com/project/github-pages&lt;/code&gt;访问的到，如果你是使用一级域名的话。文件后缀可以是&lt;code&gt;.html&lt;/code&gt;或者&lt;code&gt;markdown&lt;/code&gt;或者&lt;code&gt;textile&lt;/code&gt;。这里还有很多的例子：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;https://github.com/mojombo/jekyll/wiki/Sites&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jekyll的配置&lt;/h3&gt;

&lt;p&gt;Jekyll的配置写在_config.yml文件中，可配置项有很多，我们不去一一追究了，很多配置虽有用但是一般不需要去关心，&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/configuration&quot;&gt;官方配置文档&lt;/a&gt;有很详细的说明，确实需要了可以去这里查，我们主要说两个比较重要的东西，一个是&lt;code&gt;Permalink&lt;/code&gt;，还有就是自定义项。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Permalink&lt;/code&gt;项用来定义你最终的文章链接是什么形式，他有下面几个变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;year&lt;/code&gt; 文件名中的年份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;month&lt;/code&gt; 文件名中的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;day&lt;/code&gt; 文件名中的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt; 文件名中的文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categories&lt;/code&gt; 文章的分类，如果文章没有分类，会忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-month&lt;/code&gt; 文件名中的除去前缀0的月份&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i-day&lt;/code&gt; 文件名中的除去前缀0的日期&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;看看最终的配置效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: pretty&lt;/code&gt; /2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /:month-:day-:year/:title.html&lt;/code&gt; /04-29-2009/slap-chop.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permalink: /blog/:year/:month/:day/:title&lt;/code&gt; /blog/2009/04/29/slap-chop/index.html&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我使用的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink: /:title&lt;/code&gt; /github-pages&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;自定义项的内容，例如我们定义了&lt;code&gt;title:BeiYuu的博客&lt;/code&gt;这样一项，那么你就可以在文章中使用&lt;code&gt;{ { site.title }}&lt;/code&gt;来引用这个变量了，非常方便定义些全局变量。&lt;/p&gt;

&lt;h3&gt;YAML Front Matter和模板变量&lt;/h3&gt;

&lt;p&gt;对于使用YAML定义格式的文章，Jekyll会特别对待，他的格式要求比较严格，必须是这样的形式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前后的&lt;code&gt;---&lt;/code&gt;不能省略，在这之间，你可以定一些你需要的变量，layout就是调用&lt;code&gt;_layouts&lt;/code&gt;下面的某一个模板，他还有一些其他的变量可以使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;permalink&lt;/code&gt; 你可以对某一篇文章使用通用设置之外的永久链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;published&lt;/code&gt; 可以单独设置某一篇文章是否需要发布&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt; 设置文章的分类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt; 设置文章的tag&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面的&lt;code&gt;title&lt;/code&gt;就是自定义的内容，你也可以设置其他的内容，在文章中可以通过&lt;code&gt;{ { page.title }}&lt;/code&gt;这样的形式调用。&lt;/p&gt;

&lt;p&gt;模板变量，我们之前也涉及了不少了，还有其他需要的变量，可以参考官方的文档：&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/template-data&quot; title=&quot;Jekyll Template Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/template-data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;使用Disqus管理评论&lt;/h2&gt;

&lt;p&gt;模板部分到此就算是配置完毕了，但是Jekyll只是个静态页面的发布系统，想做到关爽场倒是很容易，如果想要评论呢？也很简单。&lt;/p&gt;

&lt;p&gt;现在专做评论模块的产品有很多，比如&lt;a href=&quot;http://disqus.com/&quot;&gt;Disqus&lt;/a&gt;，还有国产的&lt;a href=&quot;http://duoshuo.com/&quot;&gt;多说&lt;/a&gt;，Disqus对现在各种系统的支持都比较全面，到写博客为止，多说现在仅是WordPress的一个插件，所以我这里暂时也使用不了，多说与国内的社交网络紧密结合，还是有很多亮点的，值得期待一下。我先选择了Disqus。&lt;/p&gt;

&lt;p&gt;注册账号什么的就不提了，Disqus支持很多的博客平台，参见下图：
&lt;img src=&quot;/images/githubpages/disqus-site.jpg&quot; alt=&quot;Disqus sites&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们选择最下面的&lt;code&gt;Universal Code&lt;/code&gt;就好，然后会看到一个介绍页面，把下面这段代码复制到你的模板里面，可以只复制到显示文章的模板中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;disqus_thread&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'example'; // required: replace example with your forum shortname 这个地方需要改成你配置的网站名

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
&amp;lt;/script&amp;gt;
&amp;lt;noscript&amp;gt;Please enable JavaScript to view the &amp;lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&amp;gt;comments powered by Disqus.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;
&amp;lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&amp;gt;blog comments powered by &amp;lt;span class=&quot;logo-disqus&quot;&amp;gt;Disqus&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置完之后，你也可以做一些异步加载的处理，提高性能，比如我就在最开始页面打开的时候不显示评论，当你想看评论的时候，点击“显示评论”再加载Disqus的模块。代码很简单，你可以参考我的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('#disqus_container .comment').on('click',function(){
        $(this).html('加载中...');
        var disqus_shortname = 'beiyuu';
        var that = this;
        BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()}); //这是一个加载js的函数
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不喜欢Disqus的样式，你也可以根据他生成的HTML结构，自己改写样式覆盖它的，Disqus现在也提供每个页面的评论数接口，&lt;a href=&quot;http://docs.disqus.com/developers/universal/&quot;&gt;帮助文档&lt;/a&gt;在这里可以看到。&lt;/p&gt;

&lt;h2&gt;代码高亮插件&lt;/h2&gt;

&lt;p&gt;如果写技术博客，代码高亮少不了，有两个可选插件&lt;a href=&quot;http://mihai.bazon.net/projects/javascript-syntax-highlighting-engine&quot;&gt;DlHightLight代码高亮组件&lt;/a&gt;和&lt;a href=&quot;http://code.google.com/p/google-code-prettify/&quot;&gt;Google Code Prettify&lt;/a&gt;。DLHightLight支持的语言相对较少一些，有js、css、xml和html，Google的高亮插件基本上任何语言都支持，也可以自定义语言，也支持自动识别，也有行号的特别支持。&lt;/p&gt;

&lt;p&gt;Google的高亮插件使用也比较方便，只需要在&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;的标签上加入&lt;code&gt;prettyprint&lt;/code&gt;即可。所以我选择了Google Code Prettify。&lt;/p&gt;

&lt;h2&gt;搭建本地jekyll环境&lt;/h2&gt;

&lt;p&gt;这里主要介绍一下在Mac OS X下面的安装过程，其他操作系统可以参考官方的&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Install&quot;&gt;jekyll安装&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作为生活在水深火热的墙内人民，有必要进行下面一步修改gem的源，方便我们更快的下载所需组建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gem sources --remove http://rubygems.org/
sudo gem sources -a http://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用Gem安装jekyll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过一般如果有出错提示，你可能需要这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我到了这一步的时候总是提示错误&lt;code&gt;Failed to build gem native extension&lt;/code&gt;，很可能的一个原因是没有安装rvm，&lt;a href=&quot;https://rvm.io/rvm/install/&quot;&gt;rvm的安装&lt;/a&gt;可以参考这里，或者敲入下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L https://get.rvm.io | bash -s stable --ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要安装Markdown的解释器，这个需要在你的_config.yml里面设置&lt;code&gt;markdown:rdiscount&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，如果一切顺利的话，本地环境就基本搭建完成了，进入之前我们建立的博客目录，运行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候，你就可以通过&lt;code&gt;localhost:4000&lt;/code&gt;来访问了。还有关于&lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll bootstrap&lt;/a&gt;的资料，需要自己修改调试的，可以研究一下。&lt;/p&gt;

&lt;p&gt;我在这个过程中还遇到两个诡异的没有解决的问题，一个是我放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，可以通过&lt;code&gt;beiyuu.com/blog&lt;/code&gt;访问的到，但是在本地环境下，总是&lt;code&gt;not found&lt;/code&gt;，很是让人郁闷，看生成的&lt;code&gt;_site&lt;/code&gt;目录下面的文件，也是正常的&lt;code&gt;blog.html&lt;/code&gt;，但就是找不到，只有当我把URL改为&lt;code&gt;localhost:4000/blog.html&lt;/code&gt;的时候，才能访问的到，环境不同真糟糕。&lt;/p&gt;

&lt;p&gt;还有一个是关于&lt;code&gt;category&lt;/code&gt;的问题，根据&lt;code&gt;YAML&lt;/code&gt;的语法，我们在文章头部可以定义文章所属的类别，也可以定义为&lt;code&gt;category:[blog,rss]&lt;/code&gt;这样子的多类别，我在本地试一切正常，但是push到GitHub之后，就无法读取了，真让人着急，没有办法，只能采用别的办法满足我的需求了。这里还有一篇&lt;a href=&quot;http://chxt6896.github.com/blog/2012/02/13/blog-jekyll-native.html&quot;&gt;Jekyll 本地调试之若干问题&lt;/a&gt;，安装中如果有其他问题，也可以对照参考一下。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;如果你跟着这篇不那么详尽的教程，成功搭建了自己的博客，恭喜你！剩下的就是保持热情的去写自己的文章吧。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>从一个地方到另一个地方</title>
     <link href="http://dantangfan.github.io/yearOf2011"/>
     <updated>2012-02-24T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/yearOf2011</id>
     <content type="html">&lt;p&gt;好久没有远离自己了，从心里靠近自己，从日子的鞭笞中醒过来，让放纵的生活重新回到正轨。凝视这周围的一切，才发现，我变了。&lt;/p&gt;

&lt;p&gt;好像这就是事实一样，有些事情我们可以改变，我们就应该让它向最好的方向，有些事不可以改变，我们就应该学会接受，至少这样不至于心力交瘁。生活就是一出悲剧，一场戏，我们在等待自己戈多的时候至少不应该只是挖挖鼻屎，扣扣脚趾。如果死亡只是为了明白一些事，那么活着难道不就是用来反思的么？&lt;/p&gt;

&lt;p&gt;成长了，偶尔忍不住停下脚步思考人生，感觉好像这样我们就老了。反反复复的唱着同样的歌，好像好久没有接触过新的明星了，感觉没意思。还有那种冲动，希望一个人活着两个人背着乌龟壳去穷旅，想想过完大学就不会有那样的激情了吧。不久前，跟高中同学一起去ktv，一开口就是筷子兄弟的《老男孩》，狗狗不假思索的就感慨了一句“哎，你也是老男孩。”当时有一种不知道的滋味，难易言表的，突然想想身边好多的朋友都已经成家立业了，虽然好多都是典型的打工仔，大多数应该是已经误了下半生吧，真心希望每个人都能闯出自己的天空。自己还在大学纠结，我们选择的路就是一条大众的道路，就算是不成功，至少还是可以养家糊口，讨个老婆过日子。&lt;/p&gt;

&lt;p&gt;又想起农民说过的话“将来我不当警察就要当强盗！”现在还是在大学挣扎，挣扎就挣扎吧，我看我还是只有当强盗了，最可恨的值恐怕我们现在连当强盗的勇气都没有了。好像年轻的人都是有豪情壮志的，但是现在就老了么？20岁的我们好像都每有当年的激情了，只是在自己的专业上下功夫，但是又有几个是自己钟爱的专业呢？我们经常说，但是却很少人做了。花一些时间做自己喜欢做的事情，我们都用很能接受的理由拒绝了，太忙，太累，太不现实….那次舅舅要我事事要听他的安排的时候，虽然知道那样可以走很少的弯路，但是我还是义正言辞的拒绝了，要是20岁的时候都不敢做自己想做的事情，那么你30岁40岁还能干嘛！&lt;/p&gt;

&lt;p&gt;想想，要是这几年没有背上我的旅行包，兴许一辈子都没有机会了。&lt;/p&gt;

&lt;p&gt;好像还真的有人甘于平庸，在简单的幸福中度过，狼王就是那样的吧。好像很久没有见到了，大概是有两年了，最近过年本来就是要在喝酒的，但是寡人身体不适就没有干成，约好明年，又不知道明年我还回家么。有些事就是这样，错过了就没有机会了，虽然不带有任何伤感，但为免有些遗憾。多少还是三郎钦点的变异僵尸狼王嘛~&lt;/p&gt;

&lt;p&gt;已经忘了上高中时候回家坐车的那种激动了，只记得当时是多喜欢坐车啊！而且只能是那种很多人挤的公共汽车，上面坐满了学生，都是回家的。就是偶尔有一两个老人或者是带小孩的人上车还是没有人理，然后就自己默默地站起来让座，也不会受到答谢，好像从来就是这样的，我就应该让座。这就不得不想去起车窗外的世界了，每一次坐车都是间隔一两个月，窗外都会是另一番景象。油菜花应该开的像金色地毯了吧！上面零星的飘着几只快活的蜜蜂，一看就知道是家养的！短短的身体还有圆圆的屁股，怎么打也打不走。只知道车上偶尔会闯进一两只，惊慌的窜来窜去...还记得以前还写过一篇关于车上的杂记，被松哥表扬过的，内容大概就是说人们怎么花钱找罪受，就像要当奴隶一样，被人家给卖了还欢欢喜喜的帮人数钱。想起来还真是搞笑，咋现在就没有那文艺劲儿呢！现在看到两个男的就是好基友，两个女的就是好蕾丝，一男一女就是好奇怪….还好，我还属于好奇怪。&lt;/p&gt;

&lt;p&gt;生活就是这样，只要勇气跨出第一步，一切都会比先前想的好。&lt;/p&gt;

&lt;p&gt;有的人忍受不了生活的平淡而死去，却不知生命本来就是一个奇迹，因此受宫刑的人很多，而司马迁只有一个。人性本色，出生的时候都是原创，但渐渐地你就成了赝品，成了别人的翻版，你只能是xx第二。科比之所以要争第一，因为第二就是第一个失败者。过去再优美，我们不能住进去，未来在艰险，我们只能挺过去。那天又看到了那张退学申请书，忍不住还是笑了，很高兴当时可以那么大胆，可是当时是多么的无助啊！！做的最坏的打算就是泡不到妞而且成绩也不会比那一次好，可笑的是老天爷还真的老是忘坏处走，欲哭无泪。为什么就不让我才色兼收呢！嗯，想想还是没有什么不对，就像二胡说的，我总是在丑与美的边缘徘徊，两边都不进去..可恶的二胡已经进入了丑的包围圈了！我们不去想是否能成功，我们不去想身后会不会袭来寒风冷雨，既然目标是地平线，留给世间的就只能是背影。二胡还是如愿以偿的走向了自己漫画的世界，可能有一天我活着我的儿子看到的就是那样一位大师了，我还可以吹嘘我们的友情，额，前提是人家还记得我这个恶心的同桌。&lt;/p&gt;

&lt;p&gt;还好我不是孤独的，我还有几枚好基友，胖子包养了我几年，波仔又陪睡了几年，好基友的价值就是在你没有女人的时候第一时间变成你的女人。好吧，不得不承认现在有多了一个好女友，一个会吃男人的醋的女人…&lt;/p&gt;

&lt;p&gt;但是呢，我现在还是一个穷光蛋，算不得一个男人，当有一天能靠自己的双手让自己的家人过得幸福的时候就算是男人了。我并不奢侈情感的丰富多彩，本来我就是个无趣的人了，我说的是对自己没有兴趣。幸福是用来感觉的，感情是用来维系的，情人是用来疼爱的，要感谢的是你在我一无是处的时候选择了我。陈哥说男人对女人的誓言都是放屁，你说誓言就是别人不信而自己却深信不疑的情话。爱是人间最美好的情感，也是世间最迷人的渴望，爱与被爱都是一种幸福，希望你能一直吃着幸福的棉花糖，笑得像只猴子。&lt;/p&gt;

&lt;p&gt;但是呢，渐渐地还是西喜欢上了充实的感觉。忙碌是一种幸福，奔波是一种快乐，疲惫是一种享受。跟小东仔聊天他说起喜欢快节奏的生活，那是一种人生追求，永远不会疲惫，永远保持着兴奋。忙碌带走感性，奔波书写生活，疲惫祛除空虚。渐渐地从慢节奏的生活中醒悟过来，充满激情的过着三点一线的生活。&lt;/p&gt;

&lt;p&gt;突然才发发现，自己已经从一个地方到了另一个地方。可以毫无畏惧的做事，不用考虑任何阻力。心智成熟了，人才能成长，走出自己生活的罅隙才能看到新的希望。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
