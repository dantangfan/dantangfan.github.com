<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>python2.7.x和python3.x的简单区别</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,300i,600">
  <link rel="stylesheet" href="/style.css">
  </head>
<body>
  <div class="container">
    <header class="masthead">
  <h1 class="masthead-title--small">
    <a href="/">Dantangfan</a>
  </h1>
</header>      
<div class="content post">
  <h1 class="post-title">python2.7.x和python3.x的简单区别</h1>
  <div class="post-date">
    <time>11 Sep 2014</time>
  </div>
  <p>许多python初学者都在为难到底是选择python2还是python3，我刚刚学python的时候也有这个疑问。大佬们各有个的说法，但学完基础之后，我觉得你选一个适合自己的就是最好的了，看哪个爽就学哪个。开源东西没有专门维护和标准，果然还是够但疼。</p>

<p>我觉得也没有什么好坏之分，简单了解了之后，你会发现他们支持的库已经基本差不太多了。这里就简单的说说两个版本的一些区别，以免后面东西学咋了就什么都忘了。</p>

<h2><strong>future</strong>模块</h2>

<p>这应该是python中最有用的模块之一了，虽然python3中有一些python2不支持的关键字和特性，但他们都可以在python2的<code>__future__</code>中找到。所以如果你打算在你的python2中体验python3语言的特性，就可以简单通过导入<strong>future</strong>模块。比如说我们想在python2中使用python3的整除算法，可以这样做</p>

<pre><code class="python">from __future__ import division
</code></pre>

<p>当然，<strong>future</strong>并不是专门为从python2跨越到python3准备的，它只是提供了向后兼容，也就是说python2.1中的<strong>future</strong>可以导入python2.2的特性，以此类推。</p>

<p><a href="https://docs.python.org/2/library/__future__.html#module-__future__">更多的<strong>future</strong>特性可以从官方文档中看到</a></p>

<h2>print函数</h2>

<p>print在python2中还只是一个表达式，但在python3中已经成了一个函数调用了，所以括号必不可少。</p>

<p>python2里面这样写</p>

<pre><code class="python">print 'Python', python_version()
print 'Hello, World!'
print('Hello, World!')
print('Hello','World!')
print "text", ; print 'print more text on the same line'
</code></pre>

<p>它会给出这样的答案</p>

<pre><code>Python 2.7.6
Hello, World!
Hello, World!
('Hello','World!')
text print more text on the same line
</code></pre>

<p>python3中这样写</p>

<pre><code class="python">print('Python', python_version())
print('Hello, World!')

print("some text,", end="") 
print(' print more text on the same line')
</code></pre>

<p>会给出这样的答案</p>

<pre><code>Python 3.4.1
Hello, World!
some text, print more text on the same line
</code></pre>

<p>当然，如果你不争气的在python3中写出了这样的代码</p>

<pre><code class="python">print 'Hello, World!'
</code></pre>

<p>那你就只能得到这样的答案</p>

<pre><code class="bash">  File "&lt;ipython-input-3-139a7c5835bd&gt;", line 1
    print 'Hello, World!'
                        ^
SyntaxError: invalid syntax
</code></pre>

<h2>整除方法</h2>

<p>这个改变有点变态，因为如果当你把python2的代码移植到python3上的时候，虽然写法一样，但是操作结果却不一样。</p>

<p>比如在python2中</p>

<pre><code class="python">print 'Python', python_version()
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0
</code></pre>

<p>输出是这样的</p>

<pre><code>Python 2.7.6
3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
</code></pre>

<p>但是在python3中同样的代码</p>

<pre><code class="python">print('Python', python_version())
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)
</code></pre>

<p>输出却是这样的</p>

<pre><code>Python 3.4.1
3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
</code></pre>

<p>所以这个坑等着你跳，而且相信有很多人会跳</p>

<h2>字符串</h2>

<p>python2使用的是ASCII编码来表示字符串，与unicode()不同，而且没有byte类型。
python3默认是使用Unicode(UTF-8)来表示字符串，并且有byte和bytearrays两种类型(类)。</p>

<p>python2的如下代码</p>

<pre><code class="python">print type(unicode('this is like a python3 str type'))
print type(b'byte type does not exist')
print 'they are really' + b' the same'
print type(bytearray(b'bytearray oddly does exist though'))
</code></pre>

<p>将得到如下输出</p>

<pre><code>&lt;type 'unicode'&gt;
&lt;type 'str'&gt;
they are really the same
&lt;type 'bytearray'&gt;
</code></pre>

<pre><code class="python">print('strings are now utf-8 \u03BCnico\u0394é!')
print(' has', type(b' bytes for storing data'))
print('and Python', python_version(), end="")
</code></pre>

<p>将得到下面输出</p>

<pre><code>strings are now utf-8 μnicoΔé!
has &lt;class 'bytes'&gt;
also has &lt;class 'bytearray'&gt;
</code></pre>

<h2>异常处理</h2>

<p>这里只是写法不一样，python2允许使用两种错误抛出的写法，python3中值允许一种，如下：</p>

<p>在python2中</p>

<pre><code class="python">raise IOError, "file error"
</code></pre>

<pre><code class="python">raise IOError("file error")
</code></pre>

<p>都可以可以得到输出</p>

<pre><code>---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
&lt;ipython-input-8-25f049caebb0&gt; in &lt;module&gt;()
----&gt; 1 raise IOError, "file error"

IOError: file error
</code></pre>

<p>在python3中只有</p>

<pre><code class="python">raise IOError("file error")
</code></pre>

<p>才能得到正确的输出</p>

<h2>except</h2>

<p>python2中的except表达式如下</p>

<pre><code class="python">try:
    let_us_cause_a_NameError
except NameError, err:
    print err, '--&gt; our error message'
</code></pre>

<p>但在python3中必须使用as关键字，有些不习惯。</p>

<pre><code class="python">try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--&gt; our error message')
</code></pre>

<p>他们都能输出</p>

<pre><code>name 'let_us_cause_a_NameError' is not defined --&gt; our error message
</code></pre>

<h2>for循环</h2>

<p>这是一个很棒的改进，for-loop中的变量不再会泄漏到全局命名空间了！</p>

<p>比如在python2中</p>

<pre><code class="python">i = 1
print 'before: i =', i
print 'comprehension: ', [i for i in range(5)]
print 'after: i =', i
</code></pre>

<p>会得到这样的输出</p>

<pre><code>before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4
</code></pre>

<p>在python3中，就正常了</p>

<pre><code class="python">i = 1
print('before: i =', i)
print('comprehension:', [i for i in range(5)])
print('after: i =', i)
</code></pre>

<p>输出是这样的</p>

<pre><code>before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1
</code></pre>

<h2>比较大小</h2>

<p>还有一个重要的改变是比较功能，不同类型比较的时候python3会抛出错误了。</p>

<p>python2代码如下</p>

<pre><code class="python">print "[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo'
print "(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo'
print "[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2)
</code></pre>

<p>这样的比较能得到结果，是c/c艹程序员想都不敢想的。但python2就能得到结果</p>

<pre><code>[1, 2] &gt; 'foo' =  False
(1, 2) &gt; 'foo' =  True
[1, 2] &gt; (1, 2) =  False
</code></pre>

<p>在跑一趟好哦你3中</p>

<pre><code class="python">print("[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo')
print("(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo')
print("[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2))
</code></pre>

<p>会抛出异常</p>

<pre><code>---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-16-a9031729f4a0&gt; in &lt;module&gt;()
      1 print('Python', python_version())
----&gt; 2 print("[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo')
      3 print("(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo')
      4 print("[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2))

TypeError: unorderable types: list() &gt; str()
</code></pre>

<h2>input</h2>

<p>python3的input函数也有所改变，它把把接收的数据都当成<code>str</code>处理。而在python中，我们还需要raw_input()来解决这个问题</p>

<p>python2代码</p>

<pre><code class="shell">&gt;&gt;&gt; my_input = input('enter a number: ')
enter a number: 123
&gt;&gt;&gt; type(my_input)
&lt;type 'int'&gt;
&gt;&gt;&gt; my_input = raw_input('enter a number: ')
enter a number: 123
&gt;&gt;&gt; type(my_input)
&lt;type 'str'&gt;
</code></pre>

<p>python3代码</p>

<pre><code class="python">&gt;&gt;&gt; my_input = input('enter a number: ')
enter a number: 123
&gt;&gt; type(my_input) &lt;class 'str'&gt; 
</code></pre>

<h2>xrange()</h2>

<p>在python2总我们广泛的使用<code>xrange()</code>来做迭代，通常情况下<code>xrange()</code>会比<code>range()</code>快一点，但是python3中取消了<code>xrange()</code>。</p>

<p>比如函数如下</p>

<pre><code class="python">import timeit

n = 10000
def test_range(n):
    return for i in range(n):
        pass

def test_xrange(n):
    for i in xrange(n):
        pass    
</code></pre>

<p>在python2中调用</p>

<pre><code class="python">print '\ntiming range()'
%timeit test_range(n)

print '\n\ntiming xrange()'
%timeit test_xrange(n)
</code></pre>

<p>得到输出</p>

<pre><code>timing range()
1000 loops, best of 3: 433 µs per loop
timing xrange()
1000 loops, best of 3: 350 µs per loop
</code></pre>

<p>在python3中调用</p>

<pre><code class="python">print('\ntiming range()')
%timeit test_range(n)
</code></pre>

<p>输出</p>

<pre><code>timing range()
1000 loops, best of 3: 520 µs per loop
</code></pre>

<h4>不断继续补充中。。。。。</h4>

</div>

  </div>
</body>
</html>
