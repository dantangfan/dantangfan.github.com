<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>dantangfan.github.io</title>
   <link href="http://dantangfan.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://dantangfan.github.io" rel="alternate" type="text/html" />
   <updated>2015-04-02T18:51:54+08:00</updated>
   <id>http://dantangfan.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>PEP333中文概要</title>
     <link href="http://dantangfan.github.io/zh-cn-PEP333"/>
     <updated>2015-03-31T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/zh-cn-PEP333</id>
     <content type="html">&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;PEP333的原文在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0333/&quot;&gt;PEP333&lt;/a&gt;，这篇文章是对他的一个大体翻译，好多语句不知道怎么翻译就用自己的话说了。有些觉得不影响理解的东西就没有翻译直接跳过，因为看原文总是比看翻译好的。&lt;/p&gt;

&lt;p&gt;再次深深的感受到了国外作者的屁话真是太多了，就跟写毕业论文一样天花乱坠。。&lt;/p&gt;

&lt;p&gt;在Python Web 开发中，服务端程序分为两个部分：服务器和应用程序。前者接收客户端请求，后者处理具体逻辑。常用的框架就是把这些功能封装起来，统一使用。不同的框架有不同的开发模式，这样，服务器程序就需要为不同的框架提供不同的支持。这样纷繁复杂，就需要定一个统一的标准来让服务器支持符合标准的框架，框架能跑在符合标准的服务器上。&lt;/p&gt;

&lt;h2&gt;摘要&lt;/h2&gt;

&lt;p&gt;本文档的主要目的是拟定web服务器和PythonWeb应用程序或框架之间的标准接口，用于加强web应用程序在不同web服务器之间的可移植性。&lt;/p&gt;

&lt;h2&gt;基本原理和目标&lt;/h2&gt;

&lt;p&gt;python目前拥有大量的web框架 ，如 Zope, Quixote, Webware, SkunkWeb, PSO, and Twisted Web等。过多的选择对新手来说往往是个问题，因为web框架的选择往往直接限制了web服务器的选择，反之亦然。&lt;/p&gt;

&lt;p&gt;相比之下，虽然java也有很多web框架，但是java的&lt;code&gt;servlet&lt;/code&gt;API能够让用任意java-web框架写出来的应用程序运行在支持&lt;code&gt;servlet&lt;/code&gt;API的web服务器上（没用过java，我神码都不知道）。&lt;/p&gt;

&lt;p&gt;在服务器端对这种Python API（不管这些服务器使用Python写的，还是内嵌Python，或是通过网关协议如CGI来启动Python）的使用和普及，可以把开发人员对web框架和web服务器的选择分离开，让用户自由的选择自己喜欢的组合，同时让框架和服务器的开发者专注于自己的领域。&lt;/p&gt;

&lt;p&gt;因此，这份PEP提出了一个web服务器和web应用或框架之间的简单接口规范，也就是Python Web Server Gateway Interface (WSGI)。&lt;/p&gt;

&lt;p&gt;但仅仅存在一个WSGI规范的无助于解决现有状态。服务器和框架的作者或维护者必须自己实现一份WSGI才能让规范生效。&lt;/p&gt;

&lt;p&gt;由于没有现成的服务器或框架支持WSGI，并且对实现WSGI的作者也很少有直接的收获或奖励。因此，WSGI的实现就必须足够简单，最大化的减少实现成本。&lt;/p&gt;

&lt;p&gt;但是请注意，一个作者实现WSGI的简单性和一个用户使用web框架的简单性并不是同一件事。WSGI也不能有太多规定，比如说cookie、session之类的应该留给框架自己决定，这样才能保证框架的灵活多样。请牢记，WSGI的目标是促进现有的服务器和应用程序或框架容易互连，而不是制造一个新的web框架。&lt;/p&gt;

&lt;p&gt;另外，WSGI不需要除当前版本python之外的任何功能，也不会依赖于任何模块。&lt;/p&gt;

&lt;p&gt;除了能轻松实现程序和框架之间的互联，它也应该能轻松的创建请求预处理器、响应后处理器和其他的基于WSGI的中间件的组建（对于服务器来说这些组建是应用程序，对于应用程序来说这些组建是服务器）。&lt;/p&gt;

&lt;p&gt;如果中间件可以既简单又健壮，并且WSGI广泛使用于服务器和框架，那么就会有一种全新的Python的Web应用程序框架：一个仅仅由几个松散-耦合（loosely-coupled）的WSGI中间件组成的web框架。事实上，现有的框架作者都偏向于重构现有框架来让框架以这种方式提供服务（就是全新的web应用程序框架），使他们看起来更像是配合使用WSGI的库，而不是整体框架。这让web应用的开发者能自由的选择合适的组合，而不需要把所有的功能都让一个框架提供。&lt;/p&gt;

&lt;p&gt;很明显，这一天的到来还遥遥无期，在这期间，一个合理的目标就是让任何框架在任何服务器上运行起来。&lt;/p&gt;

&lt;p&gt;最后，应该提及的是，当前版本的WSGI并没有明确的规定一个web应用需要以什么方式部署在web服务器或gateway上。目前，者需要服务器或者gateway来定义和实现。&lt;/p&gt;

&lt;p&gt;在有足够多的服务器和框架实现了WSGI并在实践中产生这个需求之后，再创建一份PEP来描述WSGI服务器和应用程序的架构部署标准也不迟。&lt;/p&gt;

&lt;p&gt;简单解释中间件：它处于服务器程序与应用程序之间，对服务器程序来说，它相当于应用程序，对应用程序来说，它相当于服务器程序。于是，对用户请求的处理，可以变成多个中间件叠加在一起，每个middleware实现不同的功能。请求从服务器来的时候，依次通过中间件；响应从应用程序返回的时候，反向通过层层中间件。我们可以方便地添加，替换中间件，以便对用户请求作出不同的处理。&lt;/p&gt;

&lt;h2&gt;概览&lt;/h2&gt;

&lt;p&gt;WSGI接口有两种形式：一种针对服务器或gateway，另一种针对web应用或web框架。服务器调用一个由应用程序提供的可调用对象（callable），至于该对象是如何被调用的就要取决于服务器或者gateway。一些服务器或者gateway需要应用程序的部署人员编写一个脚本来起启动服务器或gateway的实例，并把应用程序对象提供给服务器。其他服务器或gateway可以使用配置文件或其他机制来指定应用程序对象该从那里导入或者获取。&lt;/p&gt;

&lt;p&gt;除了&lt;code&gt;pure&lt;/code&gt;（纯）服务器/gateway和web框架/应用，也可以实现创建实现了这份WSGI的中间件。这种中间件对于包含它们的服务器序而言是应用程序，对于它们包含的应用程序而言是服务器，并且用来提供扩展的API，内容转换、导航等其他有用的功能。&lt;/p&gt;

&lt;p&gt;在整篇文章中，我们使用的属于&lt;code&gt;可调用&lt;/code&gt;（callable）的意思是一个函数、方法、类、或者一个包含&lt;code&gt;__call__&lt;/code&gt;方法的实例。者依赖于服务器/框架根据自己所需要的技术来选择实现方式。但是，一个服务器/框架调用一个可调用程序的时候不能依赖调用程序的实现方式。可调用程序仅仅是用来调用的，而不是用来自省的（意思是可调用程序跟&lt;strong&gt;call&lt;/strong&gt;方法没有关系，只是这里的一个术语）。&lt;/p&gt;

&lt;h3&gt;框架/应用程序端&lt;/h3&gt;

&lt;p&gt;应用程序对象是一个接收两个参数的可调用对象。这里的&lt;code&gt;对象&lt;/code&gt;并不是一个真正的对象（python对象），一个函数、方法、类、或者一个包含&lt;code&gt;__call__&lt;/code&gt;方法的实例可以用作应用程序对象。应用程序对象必须能被多次调用，因为几乎所有的服务器/gateway（除了CGI）都会重复的请求。&lt;/p&gt;

&lt;p&gt;（注意：尽管我们把它叫做应用程序对象，但并不是说开发人员要把WSGI当成API来调用。我们假定应用程序开发者仍然使用现有的，高层的框架服务来开发他们的应用程序。WSGI 是一个给框架和服务器开发者用的工具，并且不会提供对应用程序开发者的直接支持。）&lt;/p&gt;

&lt;p&gt;如下是应用程序对象的两个例子：&lt;/p&gt;

&lt;p&gt;```python
def simple_server(environ, start_response):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;Simplest possible application object&quot;&quot;&quot;
status = &quot;200 OK&quot;
response_headers = [('Content-type', 'text/plain')]
start_response(status, response_headers)
return ['Hello world !\n']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;```python
class AppClass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;Produce the same output, but using a class
注意：AppClass 就是这里的 application，所以调用它的时候会返回AppClass的一个实例，这个实例迭代的返回‘application callable’该返回的对象。
如果我们想使用AppClass的实例，我们需要实现一个__call__方法，外部通过调用这个方法来执行应用程序，并且我们需要创建一个实例给服务器使用
&quot;&quot;&quot;
def __init__(self, environ, start_response):
    self.environ = environ
    self.start_response = start_response

def __iter__(self):
    status = &quot;200 OK&quot;
    response_headers = [('Content-type', 'text/plain')]
    self.start_response(status, response_headers)
    yield &quot;Hello world !\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3&gt;服务器/gateway端&lt;/h3&gt;

&lt;p&gt;每次收到从HTTP客户端来的请求服务器就会调用应用程序。下面是一个简单的CGI gateway，以一个接受一个应用程序对象作为参数的函数来实现。这个简单的例子还拥有有限的容错功能，因为未捕捉的异常默认会写到 sys.error 里并被web服务器记录下来.&lt;/p&gt;

&lt;p&gt;```python
import os, sys&lt;/p&gt;

&lt;p&gt;def run_with_cgi(application):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environ = dict(os.environ.items())
environ['wsgi.input']        = sys.stdin
environ['wsgi.errors']       = sys.stderr
environ['wsgi.version']      = (1, 0)
environ['wsgi.multithread']  = False
environ['wsgi.multiprocess'] = True
environ['wsgi.run_once']     = True

if environ.get('HTTPS', 'off') in ('on', '1'):
    environ['wsgi.url_scheme'] = 'https'
else:
    environ['wsgi.url_scheme'] = 'http'

headers_set = []
headers_sent = []

def write(data):
    if not headers_set:
         raise AssertionError(&quot;write() before start_response()&quot;)

    elif not headers_sent:
         # Before the first output, send the stored headers
         status, response_headers = headers_sent[:] = headers_set
         sys.stdout.write('Status: %s\r\n' % status)
         for header in response_headers:
             sys.stdout.write('%s: %s\r\n' % header)
         sys.stdout.write('\r\n')

    sys.stdout.write(data)
    sys.stdout.flush()

def start_response(status, response_headers, exc_info=None):
    if exc_info:
        try:
            if headers_sent:
                # Re-raise original exception if headers sent
                raise exc_info[0], exc_info[1], exc_info[2]
        finally:
            exc_info = None     # avoid dangling circular ref
    elif headers_set:
        raise AssertionError(&quot;Headers already set!&quot;)

    headers_set[:] = [status, response_headers]
    return write

result = application(environ, start_response)
try:
    for data in result:
        if data:    # don't send headers until body appears
            write(data)
    if not headers_sent:
        write('')   # send headers now if body was empty
finally:
    if hasattr(result, 'close'):
        result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3&gt;中间件&lt;/h3&gt;

&lt;p&gt;我们知道有些中间件又能当成服务器又能当成应用程序，这些中间件可以提供这样的一些功能
- 根据目标url将请求传递到不同应用程序对象
- 允许多个应用程序和框架在同一个进程中执行
- 通过在网络上传递请求和响应实现负载均衡和远程处理
- 对内容进行加工&lt;/p&gt;

&lt;p&gt;中间件对于服务器和应用程序都是透明的，所以不需要特殊支持。想在应用程序中加入中间件的用户只需要把中间件当成应用程序提供给服务器。当然，这里的中间件包裹的“应用程序”可能还还有中间件，层层包裹就形成了所谓的&lt;code&gt;中间件堆栈&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;大多数情况下，中间件需要符合服务器端和应用程序端的限制和要求。有时候，中间件的要求会比纯纯服务器和纯应用程序的要求更苛刻。&lt;/p&gt;

&lt;p&gt;这里有一个中间件组件的例子，它用Joe Strout的piglatin.py将text/plain的响应转换成pig latin（注意：真正的中间件应该使用更加安全的方式——应该检查内容的类型和内容的编码，这个简单的例子还忽略了一个单词跨块进行行分裂的可能性)。&lt;/p&gt;

&lt;p&gt;```python
from piglatin import piglatin&lt;/p&gt;

&lt;p&gt;class LatinIter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;Transform iterated output to piglatin, if it's okay to do so

Note that the &quot;okayness&quot; can change until the application yields
its first non-empty string, so 'transform_ok' has to be a mutable
truth value.
&quot;&quot;&quot;

def __init__(self, result, transform_ok):
    if hasattr(result, 'close'):
        self.close = result.close
    self._next = iter(result).next
    self.transform_ok = transform_ok

def __iter__(self):
    return self

def next(self):
    if self.transform_ok:
        return piglatin(self._next())
    else:
        return self._next()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;class Latinator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# by default, don't transform output
transform = False

def __init__(self, application):
    self.application = application

def __call__(self, environ, start_response):

    transform_ok = []

    def start_latin(status, response_headers, exc_info=None):

        # Reset ok flag, in case this is a repeat call
        del transform_ok[:]

        for name, value in response_headers:
            if name.lower() == 'content-type' and value == 'text/plain':
                transform_ok.append(True)
                # Strip content-length if present, else it'll be wrong
                response_headers = [(name, value)
                    for name, value in response_headers
                        if name.lower() != 'content-length'
                ]
                break

        write = start_response(status, response_headers, exc_info)

        if transform_ok:
            def write_latin(data):
                write(piglatin(data))
            return write_latin
        else:
            return write

    return LatinIter(self.application(environ, start_latin), transform_ok)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Run foo_app under a Latinator's control, using the example CGI gateway&lt;/h1&gt;

&lt;p&gt;from foo_app import foo_app
run_with_cgi(Latinator(foo_app))
```&lt;/p&gt;

&lt;h2&gt;详细信息&lt;/h2&gt;

&lt;p&gt;应用程序对象必须接收两个参数，我们把它命名为&lt;code&gt;environ&lt;/code&gt;和&lt;code&gt;start_response&lt;/code&gt;（可随意修改），服务器&lt;strong&gt;必须&lt;/strong&gt;根据关键字位置（而不是名称）调用应用程序如&lt;code&gt;result = application(environ, start_response)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里&lt;code&gt;environ&lt;/code&gt;是一个包含CGI-style环境变量的字典对象，这个对象&lt;strong&gt;必须&lt;/strong&gt;是python内建的字典对象（不是子类、UserDict或其他字典对象），应用程序可以自由的修改这个对象。这个字典还必须包含一些必须的WSGI所需要的变量（后文有描述），还可能包含一些服务器特定的变量，这些变量根据下文描述的惯例命名。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;是一个接收两个必选参数和一个可选参数的可调用对象，把这几个参数依次命名为&lt;code&gt;status&lt;/code&gt;、&lt;code&gt;response_headers&lt;/code&gt;、&lt;code&gt;exc_info&lt;/code&gt;（可随意修改命名），调用的时候&lt;strong&gt;必须&lt;/strong&gt;根据参数位置调用如&lt;code&gt;start_response(status, response_headers)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;status&lt;/code&gt;是格式如&lt;code&gt;999 msg here&lt;/code&gt;的状态码，&lt;code&gt;response_headers&lt;/code&gt;是一个由如&lt;code&gt;(header_name, header_value)&lt;/code&gt;的元组组成的列表，它描述了HTTP响应的响应头。&lt;code&gt;exc_info&lt;/code&gt;将会在下文的 &lt;a href=&quot;&quot;&gt;The start_response() Callable&lt;/a&gt;、&lt;a href=&quot;&quot;&gt;出错处理&lt;/a&gt;中讲到，这个参数只有在应用程序捕获出错并且要将错误输出到浏览器的时候才会用到。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;可调用程序必须返回一个可调用的&lt;code&gt;write(body_data)&lt;/code&gt;，它接收一个可选参数：一个可以作为HTTP响应体(response body)一部分的字符串。（注意：提供可调用的write()只是为了支持现有的框架必要的输出API，新的框架应尽可能避免使用，详见&lt;a href=&quot;&quot;&gt;Buffering and Streaming&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;当被调用时，应用程序对象必须返回一个可以产生0或者多个字符串的iterable（yielding zero or more strings）。有很多方法可以实现这个目标，比如返回一个字符串列表，或者应用程序本身是个可以返回字符串的生成器函数(generator function that yield strings)，或者应用程序本身是一个可以产生可迭代对象的类。&lt;/p&gt;

&lt;p&gt;服务器必须将产生的的字符串（也就是上文中返回的yielded string）无缓冲的发送给客户端，每次传输完成之后才能取下一个字符串（换句话说，应用程序需要实现自己的缓冲区，&lt;a href=&quot;&quot;&gt;Buffering and Streaming&lt;/a&gt;阐述了更多关于如何处理输出的问题。。。这句话的意思是不能将东西缓冲在服务器内，但是可以缓冲在狂间/应用程序内）&lt;/p&gt;

&lt;p&gt;服务器应该把产生的字符串当成字节流处理：特别的是，要确保行末尾没被修改（it should ensure that line endings are not altered）。应用程序负责保证输出的这些字符串的编码是与客户端匹配的。&lt;/p&gt;

&lt;p&gt;如果调 len(iterable) 成功，服务器将认为返回的结果是正确的。也就是说，应用程序返回的可迭代的字符串提供了一个有用 的&lt;strong&gt;len&lt;/strong&gt;() 方法，那么肯定返回了正确的结果。&lt;/p&gt;

&lt;p&gt;如果可迭代对象返回了&lt;code&gt;close()&lt;/code&gt;方法，那么不管这个请求是否成果完成，每次请求结束前服务器都必须在请求结束之前调用这个方法（这是用来支持应用程序对象占用资源的释放）。&lt;/p&gt;

&lt;p&gt;（注意：应用程序必须在可迭代对象产生第一个字符串之前调用&lt;code&gt;start_response&lt;/code&gt;，这样服务器才能先发送header再发送body。但是这个过程也可以发生在可迭代对象第一次迭代前，所以服务器不能保证迭代开始前&lt;code&gt;start_response&lt;/code&gt;已经被调用过了。）&lt;/p&gt;

&lt;p&gt;最后，服务器不能直接调用应用程序返回的可迭代对象的其他任何属性，除非这个属性是针对服务器实现的特定实例。&lt;/p&gt;

&lt;h3&gt;environ变量&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;environ&lt;/code&gt;需要包含如下CGI定义的环境变量。下面的变量必须被呈现出来，除非他的值是空（这时候如果没有特别指出，空值会被忽略）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;REQUEST_METHOD：HTTP请求的方式，比如 &quot;GET&quot; 或者 &quot;POST&quot;， 这个不能是空字符串并且也是必须给出的字段。&lt;/li&gt;
&lt;li&gt;SCRIPT_NAME：请求URL中路径的开始部分，对应应用程序对象，这样应用程序就知道它的虚拟位置。如果该应用程序对应服务器的根的话， 它可能是为空字符串。&lt;/li&gt;
&lt;li&gt;PATH_INFO：请求URL中路径的剩余部分，指定请求的目标在应用程序内部的虚拟位置。如果请求的目标是应用程序跟并且没有trailing slash的话，可能为空字符串 。&lt;/li&gt;
&lt;li&gt;QUERY_STRING：请求URL中跟在&quot;?&quot;后面的那部分,可能为空或不存在。&lt;/li&gt;
&lt;li&gt;CONTENT_TYPE：HTTP请求中任何 Content-Type 域的内容。&lt;/li&gt;
&lt;li&gt;CONTENT_LENGTH：HTTP请求中任何 Content-Length 域的内容。可能为空或不存在。&lt;/li&gt;
&lt;li&gt;SERVER_NAME , SERVER_PORT ：SCRIPT_NAME和PATH_INFO结合可以产生完整的url。但是，如果HTTP_HOST存在的话，优先使用它代替SCRIIPT_NAME。这两个参数都不能为空。&lt;/li&gt;
&lt;li&gt;SERVER_PROTOCOL ：浏览器返送请求的协议版本（如HTTP/1.0），这将决定应用程序如何处理浏览器发送的headers。&lt;/li&gt;
&lt;li&gt;HTTP_ Variables：以&lt;code&gt;HTTP_&lt;/code&gt;打头的变量，也就是对应客户端提供的HTTP请求headers。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;服务器应该尽可能的提供做够多的其他CGI变量。另外，如果使用了SSL，那服务器还要提供足够多的Apache SSL环境变量。但是，请注意，任何使用比上面列出的其他变量的CGI应用程序必然是不可移植到不支持扩展相关的Web服务器。&lt;/p&gt;

&lt;p&gt;注意：不需要的变量一定要移除environ，还有就是CGI定义的变量都是字符串类型（str）。&lt;/p&gt;

&lt;p&gt;除了CGI变量之外，&lt;code&gt;environ&lt;/code&gt;还可以包含操作系统环境变量，下面是必须包含的环境变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wsgi.version：用元组(1,0)表示1.0版本&lt;/li&gt;
&lt;li&gt;wsgi.url_scheme：代表被调用应用程序url的“scheme”字段，通常是&quot;http&quot;或&quot;https&quot;&lt;/li&gt;
&lt;li&gt;wsgi.input：输入流（文件对象），HTTP请求body可以从里面读取&lt;/li&gt;
&lt;li&gt;wsgi.errors：输出流（文件对象），可以将错误写入。这应该是一个文本模式的流，应用程序使用&quot;\n&quot;作为一行的结束，并且假定它可以被服务器转换成正确的行。对许多服务器来说，wsgi.errors是服务器主要的错误日志，也就是说，它也可以是sys.stderr，或者日志文件。&lt;/li&gt;
&lt;li&gt;wsgi.multithread：如果为True，那么应用程序对象就可以在被同一进程中的另一个线程同时调用。&lt;/li&gt;
&lt;li&gt;wsgi.multiprocess：....&lt;/li&gt;
&lt;li&gt;wsgi.run_once：如果为True，服务器将认为应用程序只在它所被包含的进程的生命周期中调用一次。通常，只有在基于CGI的网关中才为True。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最后 environ 字典也可以包含服务器定义的变量。这些变量的名字必须是小写字母、数字、点和下划线，并且应该带一个能唯一代表服务器的前缀。比如， mod_python可能会定义象这样的一些变量:&lt;code&gt;mod_python.some_variable&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;输入和错误流&lt;/h4&gt;

&lt;p&gt;输入和错误流必须支持如下方法&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt; 方法名        &lt;/th&gt;
&lt;th align=&quot;right&quot;&gt; 流   &lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;  注解  &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;   read(size)  &lt;/td&gt;
&lt;td align=&quot;right&quot;&gt; input &lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;  1     |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;   readline()     &lt;/td&gt;
&lt;td align=&quot;right&quot;&gt; input     &lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;   1,2  |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;    readlines(hint)    &lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;  input      &lt;/td&gt;
&lt;td align=&quot;center&quot;&gt; 1,3   |&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;iter&lt;/strong&gt;()&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;input&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;flush()&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;error&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write(str)&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;error&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;writelines(seq)&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;error&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;ol&gt;
&lt;li&gt;服务器不需要通过读取客户端全部内容来计算Content-Length长度，但是如果应用程序试图这样做，就可以用这一点来模拟文件结束的条件。应用程序不应该读取长度大于Content-Length变量的数据。&lt;/li&gt;
&lt;li&gt;readline并不支持可选参数’size‘，因为它对于服务器开发者来实现有些复杂了，并且也不常使用&lt;/li&gt;
&lt;li&gt;可选参数’hint‘对应用程序和服务器都是可有可无的&lt;/li&gt;
&lt;li&gt;由于错误流可能无法倒回，服务器端可以无缓冲的转发写操作，flash()方法可以是空。应用程序就不行了，它不能认为flash()是个空操作也不能认为输出无缓冲。它们必须调用flash()来确保输出。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;符合本说明的服务器都必须支持上面这些方法，符合本说明的应用程序/框架使用输入流对象及错误流对象时，只能使用这些方法，禁止使用其它方法。需要指出的是，应用程序不能试图关闭这些流，即便他们有close()方法。&lt;/p&gt;

&lt;h3&gt;start_response()&lt;/h3&gt;

&lt;p&gt;这是应用程序/框架对象的第二个参数&lt;code&gt;start_response(status,response_headers,exc_info=None)&lt;/code&gt;，&lt;code&gt;start_response&lt;/code&gt;是用来开始一个HTTP响应的，而且它必须返回一个&lt;code&gt;write(body_data)&lt;/code&gt;的可调用对象。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;status&lt;/code&gt;只能是&lt;code&gt;404 Not Found&lt;/code&gt;这种格式的，不能有回车之类乱七八糟的控制字符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;response_headers&lt;/code&gt;前面说过了，是&lt;code&gt;(header_name, header_value)&lt;/code&gt;类型的元组(type(response_headers) is List)，内容可以由服务器修改但&lt;code&gt;header_name&lt;/code&gt;必须符合HTTP标准。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;header_value&lt;/code&gt;不能包含任何控制字符。&lt;/p&gt;

&lt;p&gt;一般情况下，服务器需要保证送到客户端的HTTP头是正确的：如果应用程序省略了HTTP需要的头，服务器就要加上去。&lt;/p&gt;

&lt;p&gt;（注意：HTTP头的名字是大小写敏感的，在应用程序检查的时候要注意这个问题）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start_response&lt;/code&gt;不能直接传输响应headers，它需要为服务器保存这些headers，直到应用程序返回值的第一个迭代对象yields一个非空字符串，或者应用程序第一次调用&lt;code&gt;write()&lt;/code&gt;方法的时候，服务器才传输这些headers。换句话说，只有当body data可用时或者应用程序返回的可迭代对象耗尽时才传输这些headers，唯一的例外是头部Content-Length本身就为0(这其实是在说，HTTP响应body部分必须有数据，不能只返回一个header。有这句话前面句简直废话还看不懂)。&lt;/p&gt;

&lt;p&gt;响应头的传输延迟是为了确保缓冲和异步应用程序能在请求结束前的任何时刻用error message代替原本的输出。例如，当在缓冲区内的body产生的时候出错，应用程序就要把响应码从“200 OK”改成“500 Internal Error”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exc_info&lt;/code&gt;一旦被提供的话，就必须是&lt;code&gt;sys.exc_info()&lt;/code&gt;返回值的相同元组格式的。只有在&lt;code&gt;start_response&lt;/code&gt;被error handler调用的时候，这个参数才需要被提供。如果有&lt;code&gt;exc_info&lt;/code&gt;参数，并且还没有HTTP headers被输出，&lt;code&gt;start_response&lt;/code&gt;就需要用新的HTTP response headers替换当前存储的HTTP response headers，从而使应用程序在出错的时候“改变主意”。&lt;/p&gt;

&lt;p&gt;但是如果&lt;code&gt;exc_info&lt;/code&gt;被提供了，而且HTTP headers也被发送了，&lt;code&gt;start_response&lt;/code&gt;就必须raise a error，也需要raise the exc_info
tuple， 如下：
&lt;code&gt;python
raise exc_info[0], exc_info[1], exc_info[2]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这将重新抛出被应用程序捕获的异常，并且原则上要终止应用程序（在HTTP headers被发送之后还继续将错误信息发送到浏览器是不安全的）。如果使用了&lt;code&gt;exc_info&lt;/code&gt;参数，应用程序不能捕获任何&lt;code&gt;start_response&lt;/code&gt;抛出的异常，应该交给服务器处理。&lt;/p&gt;

&lt;p&gt;只有当&lt;code&gt;exc_info&lt;/code&gt;被提供的时候，应用程序才有可能多次调用&lt;code&gt;start_response&lt;/code&gt;。 （参见示例：CGI gateway 正确的逻辑的示意图。）&lt;/p&gt;

&lt;p&gt;注意：为了避免循环引用，start_response实现时需要保证 exc_info在函数调用后不再包含引用。服务器或者中间件实现&lt;code&gt;start_response&lt;/code&gt;的时候要确保在函数生命周期之后&lt;code&gt;exc_info&lt;/code&gt;的值是空，要做到这一点最简单的办法是这样：
```python
def start_response(status, response_headers, exc_info=None):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if exc_info:
     try:
         # do stuff w/exc_info here
     finally:
         exc_info = None    # Avoid circular ref.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;CGI gateway也提供了这个技术的示意图&lt;/p&gt;

&lt;h4&gt;处理Content-Length&lt;/h4&gt;

&lt;p&gt;如果应用程序支持 Content-Length，那么服务器程序传递的数据大小不应该超过 Content-Length，当发送了足够的数据后，应该停止迭代，或者raise一个error。当然，如果应用程序返回的数据大小没有它指定的Content-Length那么多，那么服务器程序应该关闭连接，使用Log记录，或者报告错误。&lt;/p&gt;

&lt;p&gt;如果应用程序没有提供这个header，服务器就需要从多种处理办法中选一个处理，最简单的处理方式就是在响应结束时关闭客户端连接。&lt;/p&gt;

&lt;p&gt;有时候，服务器有可能可以自己添加一个Content-Length header，或者至少避免直接关闭连接。如果应用程序没有调用write()，并且返回的可迭代对象的len()是1，服务器就能自动的用可迭代对象yield的第一个字符串的长度当成Content-Length的长度。&lt;/p&gt;

&lt;h3&gt;Buffering and Streaming&lt;/h3&gt;

&lt;p&gt; 一般情况下，应用程序会把需要返回的数据放在缓冲区里，然后一次性发送出去。之前说的应用程序会返回一个可迭代对象，多数情况下，这个可迭代对象，都只有一个元素，这个元素包含了HTML内容。但是在有些情况下，数据太大了，无法一次性在内存中存储这些数据，所以就需要做成一个可迭代对象，每次迭代只发送一块数据。&lt;/p&gt;

&lt;p&gt;禁止服务器程序延迟任何一块数据的传送，要么把一块数据完全传递给客户端，要么保证在产生下一块数据时，继续传递这一块数据。&lt;/p&gt;

&lt;p&gt;服务器/中间件可以从下面三种方法中选取一种实现：
1. 在收回应用程序控制权之前把全部的数据块发送给操作系统。
2. 在应用程序产生下一个块的时候另起一个线程来传输
3. （中间件才能实现）把数据传输给父容器（服务器/中间件）&lt;/p&gt;

&lt;h4&gt;中间件处理程序块边界&lt;/h4&gt;

&lt;p&gt;为了更好的处理异步，如果 middleware调用的应用程序产生了数据，那么middleware至少要产生一个数据，即使它想等数据积累到一定程度再返回，它也需要产生一个空的bytestring。&lt;/p&gt;

&lt;p&gt; 注意，这也意味着只要middleware调用的应用程序产生了一个可迭代对象，middleware也必须返回一个可迭代对象。 同时，禁止middleware使用可调用对象write传递数据，write是middleware调用的应用程序使用的。&lt;/p&gt;

&lt;h4&gt;write()&lt;/h4&gt;

&lt;p&gt;一些现有的框架可能提供了不符合WSGI的输出API，比如说无缓冲的&lt;code&gt;write&lt;/code&gt;，或者有缓冲的&lt;code&gt;write&lt;/code&gt;但是是使用&lt;code&gt;flush&lt;/code&gt;技术清空缓冲区。但是这些API不能用WSGI的返回迭代的方式实现，除非使用了线程或者其他特别的技术。所以，为了让这些框架能继续使用当前的API，WSGI就包含了一个特殊的&lt;code&gt;write&lt;/code&gt;可调用对象，他由&lt;code&gt;start_response&lt;/code&gt;返回。&lt;/p&gt;

&lt;p&gt;但是，如果能避免使用这个 write，最好避免使用，这是为兼容以前的应用程序而设计的。这个write的参数是HTTP response body的一部分，这意味着在write()返回前，必须保证传给它的数据已经完全被传送到客户端，或者已经放在缓冲区了。&lt;/p&gt;

&lt;p&gt;应用程序必须返回一个可迭代对象，即使它使用write产生HTTP response body。&lt;/p&gt;

&lt;h3&gt;unicode问题&lt;/h3&gt;

&lt;p&gt;HTTP和这里的接口都不会直接支持unicode，所有的编码解码问题都要应用程序来做：传递到服务器的字符串必须是&lt;code&gt;python byte string&lt;/code&gt;而不是&lt;code&gt;unicode object&lt;/code&gt;，如果格式不对，结果会是未定义。&lt;/p&gt;

&lt;p&gt;同时，传递给&lt;code&gt;start_response&lt;/code&gt;的字符串必须&lt;code&gt;RFC 2616&lt;/code&gt;编码，也就是说它必须是&lt;code&gt;ISO-8859-1&lt;/code&gt;的字符串或者&lt;code&gt;RFC 2047 MIME&lt;/code&gt;编码。&lt;/p&gt;

&lt;p&gt;本规范涉及到的所有string都是&lt;code&gt;str&lt;/code&gt;或&lt;code&gt;StringType&lt;/code&gt;，决不能是&lt;code&gt;unicode&lt;/code&gt;或&lt;code&gt;unicodeType&lt;/code&gt;的。即使当前平台支持多余8微的字符串，在本规范中的字符串也只能取低8位。&lt;/p&gt;

&lt;h3&gt;出错处理&lt;/h3&gt;

&lt;p&gt;一般情况下，应用程序应该尽可能的捕获自己内部的错误，并且在浏览器中显示有用的信息。&lt;/p&gt;

&lt;p&gt;要显示这种信息，应用程序就必须还没有发送任何数据到浏览器，否则会破坏正常的响应。因此WSGI提供了一种机制，它允许应用程序发送错误信息，或终止响应：在&lt;code&gt;start_response&lt;/code&gt;中给出&lt;code&gt;exc_info&lt;/code&gt;参数，如下：
```python
try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# regular application code here
status = &quot;200 Froody&quot;
response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
start_response(status, response_headers)
return [&quot;normal body goes here&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# XXX should trap runtime issues like MemoryError, KeyboardInterrupt
#     in a separate handler before this bare 'except:'...
status = &quot;500 Oops&quot;
response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]
start_response(status, response_headers, sys.exc_info())
return [&quot;error body goes here&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;如果发生异常的时候还没有任何数据被写入，那么&lt;code&gt;start_response&lt;/code&gt;就会返回正常，应用程序也会返回一个出错body给浏览器。如果异常时已经有数据发送给浏览器，那么&lt;code&gt;start_response&lt;/code&gt;就会重新抛出异常。这种异常不应该被应用程序捕获，这样应用程序才能被终止！服务器可以捕获这种（致命）的错误，然后终止响应。&lt;/p&gt;

&lt;p&gt;服务器需要捕获并且记录那些使应用程序或者应用程序返回的可迭代对象终止的异常，如果在异常之前已经有数据发送给浏览器，那么服务器将尝试添加一个error message浏览器，如果已经发送的数据中有&lt;code&gt;text/*&lt;/code&gt;，服务器也知道该如何处理。&lt;/p&gt;

&lt;p&gt;有些中间件可能希望提供额外的出错处理服务，或者说拦截、替换应用程序产生的出错信息。这种情况下，中间件可以不用为&lt;code&gt;start_response&lt;/code&gt;提供&lt;code&gt;exc_info&lt;/code&gt;参数，而是抛出一个特定的额中间件异常，或者干脆存储提供参数之后无异常。这就让应用程序返回its error body iterable，并且允许中间件修改error output。只要开发人员尊需以下规则，这项技术就可以工作：
1. 当发生一个error response的时候总是提供&lt;code&gt;exc_info&lt;/code&gt;
2. 当&lt;code&gt;exc_info&lt;/code&gt;被提供的时候，绝对不要捕获&lt;code&gt;start_response&lt;/code&gt;产生的异常。&lt;/p&gt;

&lt;h3&gt;HTTP 1.1 Expect/Continue&lt;/h3&gt;

&lt;h3&gt;Other HTTP Features&lt;/h3&gt;

&lt;h3&gt;线程支持&lt;/h3&gt;

&lt;p&gt;是否支持线程，也取决于服务器。可并行运行多个请求的服务器也应该提供单线程运行应用程序的选项，如此一来，非线程安全的框架或者应用程序都能使用这个服务器。&lt;/p&gt;

&lt;h2&gt;实现&lt;/h2&gt;

&lt;h3&gt;服务器扩展API&lt;/h3&gt;

&lt;p&gt;有些服务器作者可能想给出更先进的API，这些API可以用于让框架作者处理专门的功能。例如，基于&lt;code&gt;mod_python&lt;/code&gt;的gateway可能希望提供Apache 的一部分API作为WSGI的扩展。&lt;/p&gt;

&lt;p&gt;简单情况下，这种实现值需要在&lt;code&gt;environ&lt;/code&gt;中添加特定的环境变量就行了，比如&lt;code&gt;mod_python.some_api&lt;/code&gt;。但多数情况下，中间可能会带来困难。比如一个API可以访问一个特定的能在&lt;code&gt;environ&lt;/code&gt;中找到的HTTP header，但是很有可能访问到的只是被中间件修改过后的值。&lt;/p&gt;

&lt;p&gt;一般情况下，扩展API和中间件的不兼容会带来风险，服务器开发者也不应该假设每人会使用中间件。&lt;/p&gt;

&lt;p&gt;为了提供最大程度额兼容，提供扩展API代替WSGIAPI的服务器必须把这些API设计成像被替代的那一部分API的调用方式那样调用。如果扩展API不能保证永远与&lt;code&gt;environ&lt;/code&gt;中的HTTP header标志的内容一致，就必须拒绝应用程序跑在这个服务器上，比如说可以raise a error 或者返回 None。&lt;/p&gt;

&lt;p&gt;同样，如果扩展API提供了写响应数据或者headers的手段，就必须在应用程序得到扩展服务之前让&lt;code&gt;start_response&lt;/code&gt;被传入。如果传入的对象和服务器原先给出的不一样，它就不能保证正确的操作，并且应该被终止。&lt;/p&gt;

&lt;p&gt;让服务器/中间件开发者遵循安全的可扩展API规定是很重要也很必要的！&lt;/p&gt;

&lt;h3&gt;应用配置&lt;/h3&gt;

&lt;p&gt;这里并不是定义服务器如何去调用一个应用程序，因为这些选项有关服务器高级配置，需要服务器作者在文档中写明。&lt;/p&gt;

&lt;p&gt;同样，框架的作者也需要在文档中说明如何利用框架创建一个可执行的应用程序。用户必须自己把选择的框架和服务器结合在一起。尽管框架和服务器有共同的接口，但这仅仅是物理上的问题，比不影响每个框架/服务器的配对。&lt;/p&gt;

&lt;p&gt;有些应用程序、框架或中间件可能希望通过&lt;code&gt;environ&lt;/code&gt;来获取简单的配置字符串，这时候服务器应该支持应用程序能向&lt;code&gt;environ&lt;/code&gt;中加入键值对。简单情况下，这个过程只需要把&lt;code&gt;os.environ&lt;/code&gt;所提供的环境变量加入到&lt;code&gt;environ&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;应用程序应该尽量把这种需求降到最低，因为并不是所有的服务器都支持简单配置。最坏情况下，部署人员可以提供一个简单的配置文件：
```python
from the_app import application&lt;/p&gt;

&lt;p&gt;def new_app(environ, start_response):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environ['the_app.configval1'] = 'something'
return application(environ, start_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;大多数常见的框架都只需要一个&lt;code&gt;environ&lt;/code&gt;的值来指定应用程序的配置文件地址（当然，应用程序应该cache这些配置，以避免每次调用都需要重新读取文件）。&lt;/p&gt;

&lt;h3&gt;URL重建&lt;/h3&gt;

&lt;p&gt;如果一个应用程序希望重建完整的请求url，那么他可能需要下面的算法，contributed by Ian Bicking：
```python
from urllib import quote
url = environ['wsgi.url_scheme']+'://'&lt;/p&gt;

&lt;p&gt;if environ.get('HTTP_HOST'):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url += environ['HTTP_HOST']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url += environ['SERVER_NAME']

if environ['wsgi.url_scheme'] == 'https':
    if environ['SERVER_PORT'] != '443':
       url += ':' + environ['SERVER_PORT']
else:
    if environ['SERVER_PORT'] != '80':
       url += ':' + environ['SERVER_PORT']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;url += quote(environ.get('SCRIPT_NAME', ''))
url += quote(environ.get('PATH_INFO', ''))
if environ.get('QUERY_STRING'):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url += '?' + environ['QUERY_STRING']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;有时候重建的url可能跟浏览器请求的url不太一样，有可能是服务器重写url的规则把客户端请求的url修改成了服务器认为规范的形式，或者其他原因。&lt;/p&gt;

&lt;h3&gt;Supporting Older( &amp;lt; 2.2)Versions of Python&lt;/h3&gt;

&lt;h3&gt;特定平台文件处理&lt;/h3&gt;

&lt;p&gt;有些操作环境提供高效的文件级传输设备，比如说Unix的&lt;code&gt;sendfile()&lt;/code&gt;调用。服务器可以通过&lt;code&gt;environ&lt;/code&gt;中配置&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;选项来揭露此功能。应用程序可以使用这个“file wrapper”来把file-like的对象转换为iterable再返回。
```python
if 'wsgi.file_wrapper' in environ:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return environ['wsgi.file_wrapper'](filelike, block_size)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return iter(lambda: filelike.read(block_size), '')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;如果服务器支持&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;，那么他的值必须是一个可以接一个必填参数和一个可选参数的可调用对象。第一个参数是将要发送文件的对象，第二个是建议的block size（服务器中不需要使用）。这个可调用对象必须返回一个iterable object，而且只有在应用程序把这个iterable返回给服务器并且服务器收到的时候，它才可以传输数据。&lt;/p&gt;

&lt;p&gt;一个file-like对象必须有接收一个可选叫块大小的可选参数的read()方法，它也可以有close()方法有，一旦有close()方法，&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;对象就必须有一个可以调用file-like文件close()方法的close()方法。如果file-like对象有任何跟Python内置文件对象相同的方法或者属性（如fileon()），&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;可以假设这些方法和属性都是和内置的方法属性一样。&lt;/p&gt;

&lt;p&gt;特定平台文件处理的实际调用都必须在应用程序返回之后，由服务器检查是否返回了一个wrapper对象。&lt;/p&gt;

&lt;p&gt;跟处理&lt;code&gt;close()&lt;/code&gt;不同的是，从应用程序返回一个file wrapper和返回iter(filelike.read,&quot;&quot;)的语义是一样的。也就是说，传输开始时，起始位置应该是文件的当前位置，这个过程一直持续到结束。&lt;/p&gt;

&lt;p&gt;当然，特定平台的文件传输API并不会接收任意的file-like对象。因此一个&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;必须自省(检查)所提供的file-like对象以确定是否支持。&lt;/p&gt;

&lt;p&gt;需要注意的是，即便该file-like对象不支持对应平台的API，&lt;code&gt;wsgi.file_wrapper&lt;/code&gt;也应该返回一个包含read()和close()的iterator，这样应用程序才是可移植的。就像下面这个例子：
```python
class FileWrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __init__(self, filelike, blksize=8192):
    self.filelike = filelike
    self.blksize = blksize
    if hasattr(filelike, 'close'):
        self.close = filelike.close

def __getitem__(self, key):
    data = self.filelike.read(self.blksize)
    if data:
        return data
    raise IndexError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;这里是一个服务器利用上面方法来访问特定平台API的例子：
```python
environ['wsgi.file_wrapper'] = FileWrapper
result = application(environ, start_response)&lt;/p&gt;

&lt;p&gt;try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if isinstance(result, FileWrapper):
    # check if result.filelike is usable w/platform-specific
    # API, and if so, use that API to transmit the result.
    # If not, fall through to normal iterable handling
    # loop below.

for data in result:
    # etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;finally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if hasattr(result, 'close'):
    result.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Q &amp;amp; A&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>python小技巧</title>
     <link href="http://dantangfan.github.io/python-skills"/>
     <updated>2015-02-04T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/python-skills</id>
     <content type="html">&lt;h4&gt;迭代一个列表&lt;/h4&gt;

&lt;p&gt;```python
string=['a','b','c']
for index in range(len(string)):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print index, string[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;p&gt;```python
string=['a','b','c']
for index, item in enumerate(string):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pring index, item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;检查列表中的每个元素&lt;/h4&gt;

&lt;p&gt;```python
numbers = [10,100,1000,10000]
if [number for numeber in numbers if number&amp;lt;10000]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &quot;at list one small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;p&gt;```python
numbers = [10,100,1000,10000]
if any(number &amp;lt; 10000 for number in numbers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &quot;at list one small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```
类似的&lt;/p&gt;

&lt;p&gt;```python
numbers = [10,100,1000,10000]
if all(number &amp;lt; 10000 for number in numbers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &quot;all small than 10000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;函数&lt;/h2&gt;

&lt;h4&gt;默认值只被计算一次&lt;/h4&gt;

&lt;p&gt;在python中，函数的默认值是在函数定义的时候实例化的，而不是在函数调用的时候！所以会出现下面结果&lt;/p&gt;

&lt;p&gt;```python
def func(item, stuff=[]):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stuff.append(item)
print stuff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func(1)&lt;/p&gt;

&lt;h1&gt;print &quot;[1]&quot;&lt;/h1&gt;

&lt;p&gt;func(2)&lt;/p&gt;

&lt;h1&gt;print &quot;[1,2]&quot;&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;```python
def foo(number=[]):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;number.append(9)
print number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;[9]&lt;/h1&gt;

&lt;p&gt;foo([1,2])&lt;/p&gt;

&lt;h1&gt;[1,2,9]&lt;/h1&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;[9]&lt;/h1&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;[9,9]&lt;/h1&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;[9,9,9]&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;我们需要理解的是，调用函数的时候，这个默认值会被赋成不同值是因为每次在给函数指定一个默认值的时候，python都会储存这个值。如果在调用函数的时候重写了默认值，那么这个储存的值就不会被使用。当你不重写默认值的时候，python就会让默认值引用储存的值（例子中的number）。它并不是将存储的值拷贝来为这个变量赋值，可以这样理解：有两个变量，一个是内部的，一个是当前运行时的变量。现实就是我们有两个变量来用相同的值进行交互，所以一旦number发生变化，也会改变python里面保存的初始记录。&lt;/p&gt;

&lt;p&gt;但是问题不是我们想想那么简单的，比如下面&lt;/p&gt;

&lt;p&gt;```python
def foo(count=0):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;count+=1
print count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;1&lt;/h1&gt;

&lt;p&gt;foo()&lt;/p&gt;

&lt;h1&gt;1&lt;/h1&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;为什么上面函数运行的时候又是符合预期的呢？原因很简单，整形是一种不可变的类型，跟list不同，在函数的执行过程中，整形变量是不能被改变的。当我们执行count+=1的时候，我们并没有改变count的值，而是将count指向了新的地址；而在前面使用list的时候，我们是直接在当前地址操作了变量。&lt;/p&gt;

&lt;p&gt;需要记住的有两个点：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;在python中，函数的默认值是在函数定义的时候实例化的，而不是在函数调用的时候！&lt;/p&gt;

&lt;p&gt;默认值会发生改变，是因为我们直接操作的默认值的地址。&lt;/p&gt;&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>博客搬家</title>
     <link href="http://dantangfan.github.io/nothing"/>
     <updated>2014-11-10T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/nothing</id>
     <content type="html">&lt;p&gt;新地址给出之前，这里都不会停止更新&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>重用命令记录</title>
     <link href="http://dantangfan.github.io/command"/>
     <updated>2014-11-09T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/command</id>
     <content type="html">&lt;h2&gt;基础命令：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
显示时间：date
显示日历：cal [ [ month] year ]
计算器：bc
列出文件：ls
复制：cp
切换目录：cd
切换用户：su
内核版本查看：uname [ra]
查看当前目录：pwd
创建删除目录：mkdir 、 rmdir
移动和重命名文件：mv
删除文件：rm
查看文件内容：cat [AbEnTv]
反向查看文件内容：tac
添加行号打印：nl
翻页查看：more，less
提取数据部分行：head，tail
读取非纯文本文件：od [acdfox]
修改文件创建时间或新建文件：touch
文件默认权限：umask
文件影藏属性：chattr（设置），lsattr（显示）
查看文件类型：file
查找执行文件：which
寻找特定文件：whereis，locate，find（后面做详细介绍）
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;linux文件属性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
权限：rwx权值分别是421
chgrp：更改文件所属用户组 chgrp group1 test.txt
chown：更改文件所有者： chown user1 test.txt
chmod：更改权限 chmod 744 test.txt
参数-R可以递归将文件夹下面的所有更改
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;硬件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
查看主板的序列号: dmidecode | grep -i ’serial number’
用硬件检测程序kuduz探测新硬件：service kudzu start ( or restart)
查看CPU信息：cat /proc/cpuinfo [dmesg | grep -i 'cpu'][dmidecode -t processor]
查看内存信息：cat /proc/meminfo [free -m][vmstat]
查看板卡信息：cat /proc/pci
查看显卡/声卡信息：lspci |grep -i ‘VGA’[dmesg | grep -i 'VGA']
查看网卡信息：dmesg | grep -i ‘eth’[cat /etc/sysconfig/hwconf | grep -i eth][lspci | grep -i 'eth']
查看PCI信息：lspci (相比cat /proc/pci更直观）
查看USB设备：cat /proc/bus/usb/devices
查看键盘和鼠标:cat /proc/bus/input/devices
查看系统硬盘信息和使用情况：fdisk &amp;amp; disk – l &amp;amp; df
查看各设备的中断请求(IRQ):cat /proc/interrupts
查看系统体系结构：uname -a
查看及启动系统的32位或64位内核模式：isalist –v [isainfo –v][isainfo –b]
dmidecode查看硬件信息，包括bios、cpu、内存等信息
测定当前的显示器刷新频率：/usr/sbin/ffbconfig –rev /?
查看系统配置：/usr/platform/sun4u/sbin/prtdiag –v
查看当前系统中已经应用的补丁：showrev –p
显示当前的运行级别：who –rH
查看当前的bind版本信息：nslookup –class=chaos –q=txt version.bind
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
dmesg | more 查看硬件信息
lspci 显示外设信息, 如usb，网卡等信息
lsnod 查看已加载的驱动
lshw
psrinfo -v 查看当前处理器的类型和速度（主频）
prtconf -v 打印当前的OBP版本号
iostat –E 查看硬盘物理信息(vendor, RPM, Capacity)
prtvtoc /dev/rdsk/c0t0d0s 查看磁盘的几何参数和分区信息
df –F ufs –o i 显示已经使用和未使用的i-node数目
isalist –v
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Cpuinfo 主机CPU信息
Dma 主机DMA通道信息
Filesystems 文件系统信息
Interrupts 主机中断信息
Ioprots 主机I/O端口号信息
Meninfo 主机内存信息
Version Linux内存版本信息
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;备注： proc – process information pseudo-filesystem 进程信息伪装文件系统&lt;/p&gt;

&lt;h2&gt;系统&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# uname -a # 查看内核/操作系统/CPU信息
# head -n 1 /etc/issue # 查看操作系统版本
# cat /proc/cpuinfo # 查看CPU信息
# hostname # 查看计算机名
# lspci -tv # 列出所有PCI设备
# lsusb -tv # 列出所有USB设备
# lsmod # 列出加载的内核模块
# env # 查看环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# free -m # 查看内存使用量和交换区使用量
# df -h # 查看各分区使用情况
# du -sh # 查看指定目录的大小
# grep MemTotal /proc/meminfo # 查看内存总量
# grep MemFree /proc/meminfo # 查看空闲内存量
# uptime # 查看系统运行时间、用户数、负载
# cat /proc/loadavg # 查看系统负载
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;磁盘和分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mount | column -t # 查看挂接的分区状态
# fdisk -l # 查看所有分区
# swapon -s # 查看所有交换分区
# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)
# dmesg | grep IDE # 查看启动时IDE设备检测状况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网络&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ifconfig # 查看所有网络接口的属性
# iptables -L # 查看防火墙设置
# route -n # 查看路由表
# netstat -lntp # 查看所有监听端口
# netstat -antp # 查看所有已经建立的连接
# netstat -s # 查看网络统计信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ps -ef # 查看所有进程
# top # 实时显示进程状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# w # 查看活动用户
# id &amp;lt;用户名&amp;gt; # 查看指定用户信息
# last # 查看用户登录日志
# cut -d: -f1 /etc/passwd # 查看系统所有用户
# cut -d: -f1 /etc/group # 查看系统所有组
# crontab -l # 查看当前用户的计划任务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# chkconfig –list # 列出所有系统服务
# chkconfig –list | grep on # 列出所有启动的系统服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# rpm -qa # 查看所有安装的软件包
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;linux文件目录内容：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
/ 与开机系统有关，/usr与软件安装执行有关，/var与系统运作有关
/usr 软件放置处
/opt第三方软件
/etc配置文件
/boot开机与内核文件
/var/mail用户邮件
/var/run程序相关
/var/spool/news新闻
/var/lock程序相关
/bin可执行文件
/dev设备与接口
/home主文件夹
/lib函数库
/media可以删除的设备
/mnt暂时挂载的额外设备
/root管理员文件夹
/sbin管理员才能执行的命令，多数是用来设置系统环境
/srv是service缩写，网络服务启动后所需要取用的目录数据
/tmp一般用户正在执行的程序暂时放置，建议开机启动时候清空
/lost+found文件系统发生错误时，丢失的片段放置位置
/proc虚拟文件系统，不占空间，内容都在内存中，如内核、进程、外设、网络状态等信息
/sys虚拟文件系统，记录内核相关信息，包括已加载模块和硬件设备等
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;几个主要目录&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
根目录/：/etc,/bin,/dev,/lib,/slib必须放在根目录下。
/usr目录（UNIX software resource）：操作系统软件资源，类似于c:\windows和c:\program files的合体
/usr/D11R6：xwindow系统主要数据目录
/usr/bin：巨大部分用户可以使用命令都在这里，与/bin不同的是是否与开机过程相关
/usr/include：头文件和liclude文件放置处
/usr/local：系统管理员在本机安装自己下载软件，建议到此目录
/usr/sbin：非系统正常运行所需要的系统命令
/usr/share：共享文件
/usr/src：源码文件建议放置处
/var目录：针对变动性文件
/var/cache：进程缓存文件
/var/lock
/var/log：登录文件放置处
/var/mail：个人电子邮件
/var/run：程序或者进程pid放置处
&lt;/code&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>服务器编程的几种常见模型</title>
     <link href="http://dantangfan.github.io/server-program-model"/>
     <updated>2014-10-20T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/server-program-model</id>
     <content type="html">&lt;p&gt;废话不说，进入主题，例子都用为代码描述。&lt;/p&gt;

&lt;h2&gt;同步阻塞式&lt;/h2&gt;

&lt;p&gt;这是最简单的一种IO模型，它就是一个一问一答的形式。多数的python网络编程socket一节都会有一个简单服务器例子，就是这个模型：
```c
bind(serverfd);
listen(serverfd);
while(1):{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clientfd = accept(serverfd, ...); //接收客户端传来的数据
read(clientfd, buf, ...); //读取客户端数据
do_logic(buf); //对数据进行操作，内部逻辑处理
write(clientfd, buf); //返回客户端数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;很明显的可以看到，上面有几个地方是需要等待的。
1. 等待客户端请求，如果没有客户端发起请求的话，就会一直等着。
2. 读取客户端数据，建立请求后，就需要等着客户端送来数据(我们知道tcp连接是有几次握手的，所以不能直接来数据)，此时不能接受其他客户端的连接。
3. 同样，写回客户端的时候也需要等待。&lt;/p&gt;

&lt;h2&gt;多进程&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>Python Tornado学习</title>
     <link href="http://dantangfan.github.io/study-tornado"/>
     <updated>2014-10-08T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/study-tornado</id>
     <content type="html">
</content>
   </entry>
   
   <entry>
     <title>学习记录</title>
     <link href="http://dantangfan.github.io/findwork"/>
     <updated>2014-10-03T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/findwork</id>
     <content type="html">&lt;p&gt;找工作的时候和平时复习的时候遇到的一些个问题，幸好都简单记录下来了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/4cefea0f-5c4c-4f54-8c32-c848bdf79fa2/f5d310e23af425a1ab2af19c07b26edf&quot;&gt;简单算法篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65313&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/4d78c743-340e-489e-9c7d-a799834bd08d/f9f548dd3410e6ec45896f0edeafa5ff&quot;&gt;C++语言基础篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65314&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://app.yinxiang.com/shard/s33/sh/87d176ad-3fcb-4f82-a6d1-daf7072532d9/67be614287ee2321fcaefb00d4a2af65&quot;&gt;乱七八糟问题篇&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/dantangfan/note/65316&quot;&gt;备用地址&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>python2.7.x和python3.x的简单区别</title>
     <link href="http://dantangfan.github.io/diff-py2-py3"/>
     <updated>2014-09-11T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/diff-py2-py3</id>
     <content type="html">&lt;p&gt;许多python初学者都在为难到底是选择python2还是python3，我刚刚学python的时候也有这个疑问。大佬们各有个的说法，但学完基础之后，我觉得你选一个适合自己的就是最好的了，看哪个爽就学哪个。开源东西没有专门维护和标准，果然还是够但疼。&lt;/p&gt;

&lt;p&gt;我觉得也没有什么好坏之分，简单了解了之后，你会发现他们支持的库已经基本差不太多了。这里就简单的说说两个版本的一些区别，以免后面东西学咋了就什么都忘了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;future&lt;/strong&gt;模块&lt;/h2&gt;

&lt;p&gt;这应该是python中最有用的模块之一了，虽然python3中有一些python2不支持的关键字和特性，但他们都可以在python2的&lt;code&gt;__future__&lt;/code&gt;中找到。所以如果你打算在你的python2中体验python3语言的特性，就可以简单通过导入&lt;strong&gt;future&lt;/strong&gt;模块。比如说我们想在python2中使用python3的整除算法，可以这样做&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
from __future__ import division
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，&lt;strong&gt;future&lt;/strong&gt;并不是专门为从python2跨越到python3准备的，它只是提供了向后兼容，也就是说python2.1中的&lt;strong&gt;future&lt;/strong&gt;可以导入python2.2的特性，以此类推。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/library/__future__.html#module-__future__&quot;&gt;更多的&lt;strong&gt;future&lt;/strong&gt;特性可以从官方文档中看到&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;print函数&lt;/h2&gt;

&lt;p&gt;print在python2中还只是一个表达式，但在python3中已经成了一个函数调用了，所以括号必不可少。&lt;/p&gt;

&lt;p&gt;python2里面这样写&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print 'Python', python_version()
print 'Hello, World!'
print('Hello, World!')
print('Hello','World!')
print &quot;text&quot;, ; print 'print more text on the same line'
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;它会给出这样的答案&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Python 2.7.6
Hello, World!
Hello, World!
('Hello','World!')
text print more text on the same line
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;python3中这样写&lt;/p&gt;

&lt;p&gt;```python
print('Python', python_version())
print('Hello, World!')&lt;/p&gt;

&lt;p&gt;print(&quot;some text,&quot;, end=&quot;&quot;)
print(' print more text on the same line')
```&lt;/p&gt;

&lt;p&gt;会给出这样的答案&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Python 3.4.1
Hello, World!
some text, print more text on the same line
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，如果你不争气的在python3中写出了这样的代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print 'Hello, World!'
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那你就只能得到这样的答案&lt;/p&gt;

&lt;p&gt;```bash
  File &quot;&lt;ipython-input-3-139a7c5835bd&gt;&quot;, line 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print 'Hello, World!'
                    ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SyntaxError: invalid syntax
```&lt;/p&gt;

&lt;h2&gt;整除方法&lt;/h2&gt;

&lt;p&gt;这个改变有点变态，因为如果当你把python2的代码移植到python3上的时候，虽然写法一样，但是操作结果却不一样。&lt;/p&gt;

&lt;p&gt;比如在python2中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print 'Python', python_version()
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出是这样的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Python 2.7.6
3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是在python3中同样的代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print('Python', python_version())
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出却是这样的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Python 3.4.1
3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以这个坑等着你跳，而且相信有很多人会跳&lt;/p&gt;

&lt;h2&gt;字符串&lt;/h2&gt;

&lt;p&gt;python2使用的是ASCII编码来表示字符串，与unicode()不同，而且没有byte类型。
python3默认是使用Unicode(UTF-8)来表示字符串，并且有byte和bytearrays两种类型(类)。&lt;/p&gt;

&lt;p&gt;python2的如下代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print type(unicode('this is like a python3 str type'))
print type(b'byte type does not exist')
print 'they are really' + b' the same'
print type(bytearray(b'bytearray oddly does exist though'))
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将得到如下输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
&amp;lt;type 'unicode'&amp;gt;
&amp;lt;type 'str'&amp;gt;
they are really the same
&amp;lt;type 'bytearray'&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print('strings are now utf-8 \u03BCnico\u0394é!')
print(' has', type(b' bytes for storing data'))
print('and Python', python_version(), end=&quot;&quot;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将得到下面输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
strings are now utf-8 μnicoΔé!
has &amp;lt;class 'bytes'&amp;gt;
also has &amp;lt;class 'bytearray'&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;异常处理&lt;/h2&gt;

&lt;p&gt;这里只是写法不一样，python2允许使用两种错误抛出的写法，python3中值允许一种，如下：&lt;/p&gt;

&lt;p&gt;在python2中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
raise IOError, &quot;file error&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
raise IOError(&quot;file error&quot;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;都可以可以得到输出&lt;/p&gt;

&lt;h2&gt;```&lt;/h2&gt;

&lt;p&gt;IOError                                   Traceback (most recent call last)
&lt;ipython-input-8-25f049caebb0&gt; in &lt;module&gt;()
----&gt; 1 raise IOError, &quot;file error&quot;&lt;/p&gt;

&lt;p&gt;IOError: file error
```&lt;/p&gt;

&lt;p&gt;在python3中只有&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
raise IOError(&quot;file error&quot;)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;才能得到正确的输出&lt;/p&gt;

&lt;h2&gt;except&lt;/h2&gt;

&lt;p&gt;python2中的except表达式如下&lt;/p&gt;

&lt;p&gt;```python
try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let_us_cause_a_NameError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except NameError, err:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print err, '--&amp;gt; our error message'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;但在python3中必须使用as关键字，有些不习惯。&lt;/p&gt;

&lt;p&gt;```python
try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let_us_cause_a_NameError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except NameError as err:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(err, '--&amp;gt; our error message')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;他们都能输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
name 'let_us_cause_a_NameError' is not defined --&amp;gt; our error message
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;for循环&lt;/h2&gt;

&lt;p&gt;这是一个很棒的改进，for-loop中的变量不再会泄漏到全局命名空间了！&lt;/p&gt;

&lt;p&gt;比如在python2中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
i = 1
print 'before: i =', i
print 'comprehension: ', [i for i in range(5)]
print 'after: i =', i
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会得到这样的输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在python3中，就正常了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
i = 1
print('before: i =', i)
print('comprehension:', [i for i in range(5)])
print('after: i =', i)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出是这样的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;比较大小&lt;/h2&gt;

&lt;p&gt;还有一个重要的改变是比较功能，不同类型比较的时候python3会抛出错误了。&lt;/p&gt;

&lt;p&gt;python2代码如下&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print &quot;[1, 2] &amp;gt; 'foo' = &quot;, [1, 2] &amp;gt; 'foo'
print &quot;(1, 2) &amp;gt; 'foo' = &quot;, (1, 2) &amp;gt; 'foo'
print &quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样的比较能得到结果，是c/c艹程序员想都不敢想的。但python2就能得到结果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
[1, 2] &amp;gt; 'foo' =  False
(1, 2) &amp;gt; 'foo' =  True
[1, 2] &amp;gt; (1, 2) =  False
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在跑一趟好哦你3中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print(&quot;[1, 2] &amp;gt; 'foo' = &quot;, [1, 2] &amp;gt; 'foo')
print(&quot;(1, 2) &amp;gt; 'foo' = &quot;, (1, 2) &amp;gt; 'foo')
print(&quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2))
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会抛出异常&lt;/p&gt;

&lt;h2&gt;```&lt;/h2&gt;

&lt;p&gt;TypeError                                 Traceback (most recent call last)
&lt;ipython-input-16-a9031729f4a0&gt; in &lt;module&gt;()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1 print('Python', python_version())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;----&gt; 2 print(&quot;[1, 2] &gt; 'foo' = &quot;, [1, 2] &gt; 'foo')&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  3 print(&quot;(1, 2) &amp;gt; 'foo' = &quot;, (1, 2) &amp;gt; 'foo')
  4 print(&quot;[1, 2] &amp;gt; (1, 2) = &quot;, [1, 2] &amp;gt; (1, 2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeError: unorderable types: list() &gt; str()
```&lt;/p&gt;

&lt;h2&gt;input&lt;/h2&gt;

&lt;p&gt;python3的input函数也有所改变，它把把接收的数据都当成&lt;code&gt;str&lt;/code&gt;处理。而在python中，我们还需要raw_input()来解决这个问题&lt;/p&gt;

&lt;p&gt;python2代码&lt;/p&gt;

&lt;p&gt;```shell&lt;/p&gt;

&lt;blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;my_input = input('enter a number: ')
enter a number: 123
type(my_input)
&lt;type 'int'&gt;
my_input = raw_input('enter a number: ')
enter a number: 123
type(my_input)
&lt;type 'str'&gt;
```&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;python3代码&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;my_input = input('enter a number: ')
enter a number: 123
type(my_input) &lt;class 'str'&gt;
```&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;

&lt;h2&gt;xrange()&lt;/h2&gt;

&lt;p&gt;在python2总我们广泛的使用&lt;code&gt;xrange()&lt;/code&gt;来做迭代，通常情况下&lt;code&gt;xrange()&lt;/code&gt;会比&lt;code&gt;range()&lt;/code&gt;快一点，但是python3中取消了&lt;code&gt;xrange()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;比如函数如下&lt;/p&gt;

&lt;p&gt;```python
import timeit&lt;/p&gt;

&lt;p&gt;n = 10000
def test_range(n):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return for i in range(n):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;def test_xrange(n):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in xrange(n):
    pass    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;在python2中调用&lt;/p&gt;

&lt;p&gt;```python
print '\ntiming range()'
%timeit test_range(n)&lt;/p&gt;

&lt;p&gt;print '\n\ntiming xrange()'
%timeit test_xrange(n)
```&lt;/p&gt;

&lt;p&gt;得到输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
timing range()
1000 loops, best of 3: 433 µs per loop
timing xrange()
1000 loops, best of 3: 350 µs per loop
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在python3中调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
print('\ntiming range()')
%timeit test_range(n)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
timing range()
1000 loops, best of 3: 520 µs per loop
&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;不断继续补充中。。。。。&lt;/h4&gt;
</content>
   </entry>
   
   <entry>
     <title>LinOTP简单使用教程</title>
     <link href="http://dantangfan.github.io/linotp"/>
     <updated>2014-08-07T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/linotp</id>
     <content type="html">&lt;p&gt;LinOTP是Google官方开源的one time password企业管理应用，但在国内使用的企业貌似不多。实习的时候老师要求配置一个系统，但国内很少有人给出了实际使用方法，而且官方的document写得真的是不忍吐槽。于是就自己写一个简单教程，也算是对官方教程的一个简单翻译和整合。&lt;/p&gt;

&lt;p&gt;看完这个教程，你将能搭建最基础的应用。但是如果你想把它作为你的企业应用，最好还是自己摸索一番，或者直接联系开发者和邮件列表。&lt;/p&gt;

&lt;h2&gt;一、从安装说起&lt;/h2&gt;

&lt;p&gt;ubuntu和debian有标准的一键安装，加入软件源后直接可用，red hat和centos等其他发行版需要使用pypi安装，并且手动安装所有依赖。
这里以centos6.5为例子，说明简要的安装过程：&lt;/p&gt;

&lt;p&gt;首先安装virtualenv用于建立一个隔离的python环境，由于virtualenv的存在，我们可以在任何一个发行版中用pypi安装和使用linotp&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shell
yum install python-virtualenv
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;单独建立一个文件夹来构造linotp独立的python环境&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shell
mkdir -p /opt/LINOTP
virtualenv –-no-site-packages /opt/LINOTP
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;进入LINOTP文件夹，开始并切换工作目录到当前虚拟环境，&lt;strong&gt;每次需要启动或者使用LINOTP文件夹内的app时都需要使用下面命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shell
cd /opt/LINOTP
source bin/activate
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用下面命令退出虚拟环境&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shell
deactivate
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们需要在虚拟环境中安装所需的依赖&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
yum install python-devel swig gcc openssl-devel openldap-devel mysql-devel
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在可以直接使用pip安装linotp&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
pip install linotp
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装使用各种token所需要的依赖（可能并不是所有包到都能安装）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
pip install pil
pip install m2crypto
pip install psycopg2
pip install MySQL-python
pip install SMSProvider
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;注意：为了方便，我们应该把配置文件都放在/etc文件夹下，而不是直接放在/opt/LINTOP/etc/linotp2下面，所以直接拷贝配置文件到/etc目录下&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;
cp -rf /opt/LINOTP/etc/linotp2 /etc/linotp2
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;警告：pip不会自动的更新所安装的软件，所以我们安装的依赖并不是最新的，也最好不要手动编译安装，LinOTP提供了更新命令&lt;code&gt;linotp-pip-update&lt;/code&gt;，但是一定不要使用（至少在centos6.5下不要使用），因为高版本的库并不支持linotp。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;二、建立你的数据库&lt;/h2&gt;

&lt;p&gt;如果使用的是mysql，可以直接使用下面命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
mysql -u root -p mysql
create database L2demo;
grant all privileges on L2demo.* to 'linotp'@'localhost' identified by 'mySecret';
flush privileges;
quit;
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;注意：linotp里面有个默认配置叫&lt;code&gt;/etc/linotp2/linotp.ini.example&lt;/code&gt;，为使用此配置，我们需要重命名该文件为&lt;code&gt;/etc/linotp2/linotp.ini&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;在linotp.ini中找到&lt;code&gt;sqlalchemy.url&lt;/code&gt;，并修改为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
sqlalchemy.url = mysql://linotp:mySecret@localhost/L2demo
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还需要创建一个加密密钥&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
dd if=/dev/urandom of=/etc/linotp2/encKey bs=1 count=96
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建log文件夹&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
mkdir /var/log/linotp
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在就可以正式创建数据库表单了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
paster setup-app /etc/linotp2/linotp.ini
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;三、在apache上把样例跑起来&lt;/h2&gt;

&lt;p&gt;我们需要借用apache使用webUI的管理页面，首先使用下面命令创建一个文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
htdigest /etc/linotp2/admins “LinOTP2 admin area” admin
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们需要安装并激活以下模块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
yum install mod_wsgi
yum install mod_ssl
&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;注意：在使用过程中端口会遭到iptables的拦截，这时候我们可以简单的关闭iptables&lt;code&gt;/etc/init.d/iptables stop&lt;/code&gt;或者开放指定端口,在/etc/sysconfig/iptables文件中添加如下命令(或许还需要更多端口)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;
-A INPUT -p tcp -m tcp --sport 443 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -p tcp -m tcp --sport 3389 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 3389 -j ACCEPT
-A INPUT -p tcp -m tcp --sport 5001 -j ACCEPT
-A INPUT -p tcp -m tcp --dport 5001 -j ACCEPT
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还需要建立一个wsgi的文件夹，不然WSGI模块不能正常启动&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
mkdir /var/run/wsgi
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在我们可以进一步配置apache-server了。
首先创建一个认证文件&lt;code&gt;touch /etc/[httpd|apache2]/linotp-auth.conf&lt;/code&gt;(centos是httpd文件夹下)
在此文件中添加以下内容&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
AuthType Digest
AuthName “LinOTP2 admin area”
AuthDigestProvider file
AuthUserFile /etc/linotp2/admins
Require valid-user
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;无论LinOTP的配置文件放在哪里，都需要包含以下内容。这里我直接添加到&lt;code&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;文件的最后（针对不同的系统，可能要对文件中文件的路径进行修改）&lt;/p&gt;

&lt;p&gt;```
Listen 443
WSGIPythonHome /opt/LINOTP
WSGISocketPrefix /var/run/wsgi
&lt;VirtualHost _default_:443&gt;
   ServerAdmin webmaster@localhost
   DocumentRoot /var/www
   &lt;Directory /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Options FollowSymLinks
  AllowOverride None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Directory&gt;
   &lt;Directory /var/www/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Options Indexes FollowSymLinks MultiViews
  AllowOverride None
  Order allow,deny
  allow from all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Directory&gt;&lt;/p&gt;

&lt;p&gt;   Alias /doc/html         /usr/share/doc/linotpdoc/html
   WSGIScriptAlias /       /etc/linotp2/linotpapp.wsgi
   #
   # The daemon is running as user 'linotp'
   # This user should have access to the encKey database encryption file
   WSGIDaemonProcess linotp processes=1 threads=15 display-name=%{GROUP} user=linotp
   WSGIProcessGroup linotp
   WSGIPassAuthorization On&lt;/p&gt;

&lt;p&gt;   &lt;Location /admin&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Include /etc/httpd/linotp-auth.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /audit&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Include /etc/httpd/linotp-auth.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /gettoken&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  AuthType Digest
  AuthName &quot;LinOTP2 gettoken&quot;
  AuthDigestProvider file
  AuthUserFile /etc/linotp2/gettoken-api
  Require valid-user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /manage&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         Include /etc/httpd/linotp-auth.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /selfservice&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # The authentication for selfservice is done from within the application
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /system&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Include /etc/httpd/linotp-auth.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /license&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Include /etc/httpd/linotp-auth.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;
   &lt;Location /validate&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # No Authentication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Location&gt;&lt;/p&gt;

&lt;p&gt;   ErrorLog /var/log/httpd/error.log
   LogLevel warn&lt;/p&gt;

&lt;p&gt;   # Do not use %q! This will reveal all parameters, including setting PINs and Keys!
   # Using SSL_CLIENT_S_DN_CN will show you, which administrator did what task
   LogFormat &quot;%h %l %u %t %&gt;s \&quot;%m %U %H\&quot;  %b \&quot;%{Referer}i\&quot; \&quot;%{User-agent}i\&quot; &quot; LinOTP2
   CustomLog /var/log/httpd/ssl_access.log LinOTP2&lt;/p&gt;

&lt;p&gt;   #   SSL Engine Switch:
   #   Enable/Disable SSL for this virtual host.
   SSLEngine on&lt;/p&gt;

&lt;p&gt;   #   If both key and certificate are stored in the same file, only the
   #   SSLCertificateFile directive is needed.
   SSLCertificateFile    /etc/ssl/certs/linotpserver.pem
   SSLCertificateKeyFile /etc/ssl/private/linotpserver.key
   &lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  SSLOptions +StdEnvVars
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/FilesMatch&gt;
   &lt;Directory /usr/lib/cgi-bin&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  SSLOptions +StdEnvVars
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/Directory&gt;
   BrowserMatch &quot;.&lt;em&gt;MSIE.&lt;/em&gt;&quot; \&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; nokeepalive ssl-unclean-shutdown \
 downgrade-1.0 force-response-1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   ErrorDocument 500 &quot;&lt;h1&gt;Internal Server Error&lt;/h1&gt; Possible reasons can be missing modules or bad access rights \&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 on LinOTP configuration files or log files. Please check the apache logfile \
                 &amp;lt;pre&amp;gt;/var/log/httpd/error_log&amp;lt;/pre&amp;gt; for more details.&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/VirtualHost&gt;
```&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;注意：centos的mod_ssl在&lt;code&gt;/etc/httpd/conf.d/&lt;/code&gt;中自带了一个&lt;code&gt;ssl.conf&lt;/code&gt;的配置文件，里面已经定义了&lt;code&gt;VirtualHost&lt;/code&gt;,所以这里需要相应的调整不然端口会发生冲突。（为方便可以直接重命名为&lt;code&gt;ssl.conf.old&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;注意：如果发现&lt;code&gt;linotpserver.pem&lt;/code&gt;等密钥不存在，那我么需要手动生成一些&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;WSGI的进程默认使用名字叫&lt;code&gt;linotp&lt;/code&gt;的用户，所以我们需要新建一个用户来使用它&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
adduser -r linotp -d /opt/LINOTP
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在可以把&lt;code&gt;/opt/LINOTP/etc/linotp2/linotpapp.wsgi&lt;/code&gt;文件复制到&lt;code&gt;/etc/linotp2&lt;/code&gt;文件夹中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
cp /opt/LINOTP/etc/linotp2/linotpapp.wsgi /etc/linotp2
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后查看我们建立的文件的权限，只有在适合的权限下才能正常使用linotp-server。我们希望看到的权限如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/etc/linotp2/linotp.ini - linotp should have read access&lt;/li&gt;
&lt;li&gt;/etc/linotp2/encKey - linotp should have read access&lt;/li&gt;
&lt;li&gt;/etc/linotp2/data/ - This is a template directory, linotp should have write access&lt;/li&gt;
&lt;li&gt;/var/log/linotp/ - linotp should have write access&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;注意：如果权限不当，可以使用&lt;code&gt;linotp-fix-access-rights -f /etc/linotp2/linotp.ini -u linotp&lt;/code&gt;来修复权限&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;重启apache和mysql&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
apachectl restart#输入你设定的密码
service mysqld restart
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在我们可以从命令行启动服务器了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
paster serve /etc/linotp2/linotp.ini
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;linotp会监听你在linotp.ini中定义的端口，接下来在浏览器中访问&lt;code&gt;http://&amp;lt;yourserverIP&amp;gt;:5001/manage&lt;/code&gt;就可以进入manage的页面。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;警告！！！：这里的管理页面是不需要用户名和密码就能登录的，只供测试使用。密码需要自行在apache中配置&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;四、admin管理界面&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage1.png&quot; alt=&quot;manage1.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;1.创建用户&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;LinOTP config-&amp;gt;useridresover&lt;/code&gt;创建一个useridresover。这里有三种创建方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuring LDAP UserIdResolver&lt;/li&gt;
&lt;li&gt;Configuring SQL UserIdResolver&lt;/li&gt;
&lt;li&gt;Configuring Passwd (Flatfile) UserIdResolver&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然最间但的是flatfile方式创建，这中格式的用户文件和*nix中的/etc/passwd文件格式一样，因此我们可以直接导入文件&lt;code&gt;/etc/passwd&lt;/code&gt;，导入后刷新就可以看到成功导入的用户。但是这样做有一个问题，&lt;code&gt;/etc/passwd&lt;/code&gt;文件中的并没有保存用户密码/加密后的信息，就让我们的用户实际无法登录，因此更好更简洁的办法是把是使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
linotp-create-pwidresolver-user -u [username] -i [userid] -p [password] -d [description]&amp;gt;&amp;gt; passwd-file
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建测试用户,可以用此方法创建多个，然后导入的时候直接导入&lt;code&gt;passwd-file&lt;/code&gt;文件&lt;/p&gt;

&lt;h3&gt;2.创建用户组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;LinOTP config-&amp;gt;realms&lt;/code&gt;按提示创建就行，并且指定一个默认的用户组&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage2.png&quot; alt=&quot;manage2.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;3.创建token&lt;/h3&gt;

&lt;p&gt;token可以从文件中导入，可以从官方文档中查看支持的token和导入方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/supported-tokens.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/supported-tokens.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/managingtokens/index.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/managingtokens/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;更简单的方法是手动创建token，点击左边侧烂&lt;code&gt;enroll&lt;/code&gt;可以看到创建token选项，这里我选择&lt;code&gt;HMAC eventbased&lt;/code&gt;，并勾选&lt;code&gt;Generate HMAC key&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage3.png&quot; alt=&quot;manage3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击&lt;code&gt;enroll&lt;/code&gt;看到了生成的二维码，点击&lt;code&gt;OK&lt;/code&gt;就可以在主页上&lt;code&gt;Token view&lt;/code&gt;看到生成的token&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage4.png&quot; alt=&quot;manage4.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;4.把user注册到token上面&lt;/h3&gt;

&lt;p&gt;方法很简单，在&lt;code&gt;Token view&lt;/code&gt;单击想要的token，切换到&lt;code&gt;User view&lt;/code&gt;下面单击相应的user，就可以在页面的左上角看到相应的信息类似如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/manage5.png&quot; alt=&quot;manage5.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;5.policy&lt;/h3&gt;

&lt;p&gt;这是最重要的一部分，关系到了用户的权限问题。policy有很多种类型，具体可以参见官方文档&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/policy/index.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/policy/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里，我以selfpolicy为例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/policy.png&quot; alt=&quot;policy.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;action是最重要的一部分，它直接指明了user的权限。不同的user类型有不同的权限，官方文档给出了一个推荐的最佳配置&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/policy/best-practice.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/policy/best-practice.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;policy配置好之后，就可以从浏览器登录用户了。&lt;/p&gt;

&lt;p&gt;浏览器输入&lt;code&gt;http://[yourIP]:5001/account/login&lt;/code&gt;根据用户名和密码就可以登录&lt;/p&gt;

&lt;h3&gt;6.system config&lt;/h3&gt;

&lt;p&gt;从manage页面我们还可以设置&lt;code&gt;LinOTP config-&amp;gt;system config&lt;/code&gt;，不过配置对简单的实验影响不大，官方文档有也把配置方式写得很清楚&lt;a href=&quot;http://www.linotp.org/doc/latest/part-management/system-config.html&quot;&gt;http://www.linotp.org/doc/latest/part-management/system-config.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;五、Selfservice Protal管理界面&lt;/h2&gt;

&lt;p&gt;登录后我们可以看到如下界面，根据对&lt;code&gt;policy-&amp;gt;action&lt;/code&gt;的设置，界面可能有所不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/portal1.png&quot; alt=&quot;portal1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;官方文档写得很简要&lt;a href=&quot;http://www.linotp.org/doc/latest/part-user/workflow.html&quot;&gt;http://www.linotp.org/doc/latest/part-user/workflow.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里，我通过一个小例子说明。&lt;/p&gt;

&lt;p&gt;比如我们选择&lt;code&gt;Enroll Google Authenticator&lt;/code&gt;，然后点击&lt;code&gt;Enroll Google Authenticator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/linotp/portal2.png&quot; alt=&quot;portal2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到页面左上生成了一个token（这个时候退回去看manage页面，发现也生成了一个token）。然后在你的iphone/Android上安装 google authenticator ，并扫描这个时候生成的二维码。再次使用该应用时候，就可以看到手机上出现了六位数字。这个数字就是你登录自己应用的时候所需要的密码。&lt;/p&gt;

&lt;p&gt;我们可以登录&lt;code&gt;http://[yourIP]:5001/auth/index&lt;/code&gt;来测试应用是否成功。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>进程同步的若干问题</title>
     <link href="http://dantangfan.github.io/process-signal"/>
     <updated>2014-05-20T00:00:00+08:00</updated>
     <id>http://dantangfan.github.io/process-signal</id>
     <content type="html">&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;首先我们来看一个&lt;code&gt;生产者-消费者&lt;/code&gt;的问题，在实际应用中我们使用&lt;code&gt;有限缓冲&lt;/code&gt;方案。生产者消费者进程共享代码如下&lt;/p&gt;

&lt;p&gt;```c&lt;/p&gt;

&lt;h1&gt;define BUFFER_SIZE 10&lt;/h1&gt;

&lt;p&gt;typedef struct{
...
} item;
item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
```&lt;/p&gt;

&lt;p&gt;共享缓冲区是通过循环数组和两个逻辑指针来实现的：in和out。变量in指向缓冲区的下一个空位；out指向缓冲区的第一个非空位。当in==out的时候缓冲区空，当(in+1)%BUFFER_SIZE==out的时候，缓冲器满。&lt;/p&gt;

&lt;p&gt;用counter记录缓冲区中的项，生产者进程有一个局部变量nextProducted存储锁新产生的项目，那么生产者的代码可以简单如下&lt;/p&gt;

&lt;p&gt;```c
while(1){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(counter==BUFFER_SIZE)
    ;
buffer[in] = nextProducted;
in = (in+1)%BUFFER_SIZE;
counter++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;消费者有一个局部变量nextConsumed存储要使用的项,消费者的代码如下&lt;/p&gt;

&lt;p&gt;```c
while(1){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(counter==0)
    ;
nextConsumed=buffer[out];
out = (out+1)%BUFFER_SIZE;
counter--;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;生产者消费者各自的程序都正确，但是当并发执行的时候他们可能并不能正确的执行。原因是他们同时执行的过程中代码交叉是乱序的，两个程序可能对counter同时进行操作，导致判断结果不准确。这样的情况，即多个进程并发访问和操作同一数据并且执行结果与访问发生的特定顺序有关，称为竞争条件。为了防止竞争条件，需要确保一段之间里面只有一个进程能操作共享数据（counter），于是就需要进程同步。&lt;/p&gt;

&lt;h3&gt;临界区&lt;/h3&gt;

&lt;p&gt;每个进程有一个代码段称为&lt;code&gt;临界区&lt;/code&gt;，该区中的进程可能修改共享变量、更新一个表、写一个文件等。这种系统的重要特征是当一个进程在临界区内执行时，没有其他进程被允许在临界区内执行。因此，临界区在时间上是互斥的。临界区的问题是设计一个进程能用来协作的协议，每个进程必须请求其进入临界区。实现这一请求的代码称为&lt;code&gt;进入区&lt;/code&gt;，临界区之后有&lt;code&gt;退出区&lt;/code&gt;，其他代码叫&lt;code&gt;剩余区&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关于临界区的问题的解答必须满足下面三项要求&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;互斥：一个进程在临界区内执行，其他进程都不能在其临界区内&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有空让进：如果没有进程在临界区且有进程希望进入临界区，那么只有哪些在剩余区内执行的进程能参加决策，选取谁能进入临界区，并且这种选取不能无限延迟&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有限等待：在一个进程作出进入其临界区的请求到被允许的其间，其他进程进入临界区的次数有一个上限&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;信号量&lt;/h2&gt;

&lt;p&gt;为了解决临界区问题，通常做法是使用称为&lt;code&gt;信号量&lt;/code&gt;的同步工具。信号量S是一个整数变量，除了初始化之外，只能通过两个标准的&lt;code&gt;原子操作&lt;/code&gt;wait和signal来访问。wait的经典定义可以用位代码表示为&lt;/p&gt;

&lt;p&gt;```c
wait(S){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(S&amp;lt;=0)
    ;
   S--;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;signal的经典定义可以用伪代码表示&lt;/p&gt;

&lt;p&gt;```c
signal(S){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;在wait和signal操作中，对信号量整数值的修改必须不可分的执行，当一个进程修改信号量时，不能有其他进程同时修改同一信号量。而且对于wait操作，对s数值的测试（S&amp;lt;=0）和对其可能的修改(S++)也必须没有中断的执行。&lt;/p&gt;

&lt;h3&gt;用法&lt;/h3&gt;

&lt;p&gt;可以用信号量来解决n个进程临界区问题。n个进程共享一个信号量mutex并初始化为1,每个进程的组织结构就如下&lt;/p&gt;

&lt;p&gt;```c
do{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait(mutex);
临界区;
signal(mutex);
剩余区；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}while(1);
```&lt;/p&gt;

&lt;p&gt;也可以用信号量来解决各种同步问题。比如两个正在并发执行的进程P1,P2，P1有语句S1,P2有语句S2,假设只有S1执行完之后才能有S2。那么我们可以让两个进程共享一个信号量synch,并且初始化为0,在P1中插入语句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
S1;
signal(synch);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在P2中插入语句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
wait(synch);
S2;
&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;简单的信号量主要的缺点就是&lt;code&gt;忙等待&lt;/code&gt;：当一个进程位于其临界区时，任何其他试图进入其临界区的进程都必须在其进入代码中连续的循环。为了克服忙等待，可以修改wait和signal的定义，当一个进程执行wait时，发现信号量不为正则它必须等待。然而，该进程不是忙等待而是&lt;code&gt;阻塞&lt;/code&gt;自己。阻塞操作讲一个进程放入到放入到与信号量相关的等待队列中，且该进程状态被切换成等待状态。接着，控制被转到CPU&lt;code&gt;调度程序&lt;/code&gt;，以选择一个进程执行。&lt;/p&gt;

&lt;p&gt;一个进程阻塞且等待信号量S，可以在其他进程执行signal后重新被执行。该进程的重新执行通过一个wakeup操作来进行，该操作讲进程从等待状态切换到就绪状态，接着放入就绪队列中。我们可以将信号量定义成一个结构&lt;/p&gt;

&lt;p&gt;```c
typedef struct{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int value;
struct process *L;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}semaphore;
```&lt;/p&gt;

&lt;p&gt;每个信号都有一个整数值和一个进程表，当一个进程必须等待信号量shah，就加入到进程链表上。操作signal会从等待进程链表中取出一个进程唤醒。&lt;/p&gt;

&lt;p&gt;信号量wait操作可以如下定义&lt;/p&gt;

&lt;p&gt;```c
void wait(semaphore S){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S.value--;
if(S.value&amp;lt;0){
    add this process to S.L;
    block();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;信号量signal操作如下&lt;/p&gt;

&lt;p&gt;```c
void signal(semaphore S){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;S.value++;
if(S.value&amp;lt;=0){
    remove a process P from S.L;
    wakeup(P);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;操作block挂起调用它的进程。操作wakeup重新启动阻塞的进程，他们都是操作系统提供的系统调用。&lt;/p&gt;

&lt;p&gt;信号量的关键之处是他们原子执行。必须确保没有两个进程能同时对一个信号量进程wait和signal操作。其实现在定义的信号量也没有取消忙等待，只是取消了应用程序进入临界区的忙等待。而且把忙等待限制在了wait和signal操作的临界区内。&lt;/p&gt;

&lt;h3&gt;死锁&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;死锁&lt;/code&gt;：两个或多个进程无限的等待一个事件，而该事件只能又这些等待进程之一来产生。&lt;/p&gt;

&lt;h2&gt;经典同步问题&lt;/h2&gt;

&lt;h3&gt;哲学家就餐&lt;/h3&gt;

&lt;p&gt;哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
